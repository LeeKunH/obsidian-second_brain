---
{"dg-publish":true,"permalink":"/distribute/python/python-grammar-algorithm-100/record-of-python-grammar-algorithm-solution-process/","noteIcon":""}
---

# 참고/연관된 기록 =>
- 깃허브 주소 : https://github.com/LeeKunH/NIPA_Seoul_Web/tree/main/Python_Algorithm_Problem

-------
# 행동에 대한 이유/근거 =>

### 1.
파이썬 언어에 대한 이해를 올리기 위해 해당 언어를 가지고 프로그램 개발을 해본다.


### 2.
캠프 기간 동안에 프로젝트 역량을 올리기 위해 파이썬 플라스크를 이용한 웹 사이트 프로젝트를 준비 중.
	
이 프로젝트에 붙일 미니 프로젝트를 만들어보기 위해

-----


### 코드1
```python
print("it's fine")
print('it\'s fine')
print('''it's fine''')

```
결과=>

-------------
### 코드2
```python
# 파이썬에서 한 줄 주석

'''
파이썬에서
여러 줄 주석
docstring
'''

```
결과=>

-------------
### 코드3
```python
print('"Life is too short, we need python!"')
print("\"Life is too short, we need python!\"")
print('''"Life is too short, we need python!"''')


```
결과=>

파이썬 공부 중.
파이썬에서 탈출문자, 개행문자, 이스케이프코드 모두 같은 용어?

탈출문자(escape character), 개행문자(newline character), 이스케이프 코드(escape code)는 비슷한 의미를 가지지만 약간 다른 용어로 사용

큰 틀은 같은데
세부적인 내용이 다르다

탈출문자 = 이스케이프코드
	중에서
	개행문자

이 세 용어는 모두 특정한 의미를 갖는 문자열 내의 특수한 문자를 나타내기 위해 사용됩니다.

**탈출문자 (Escape Character)**:

- 탈출문자는 일반적인 문자열 내에서 특별한 의미를 가지는 문자를 표현하기 위해 사용됩니다. 보통 백슬래시(`\`)와 함께 사용되며, 백슬래시 뒤에 특정 문자를 붙여서 사용합니다.

**개행문자 (Newline Character)**:
개행문자는 줄바꿈을 나타내기 위해 사용되는 특수한 문자입니다. 대표적으로 줄바꿈을 나타내는 역할을 하는 문자는 `\n`


-------------
### 코드4
```python

# 문제 의도 파악
# 출력해야 할 한 문장에 작은-큰 따옴표 모두 있다면?
print('you\'ll only see a "C:\Program Files" folder.')
print('''you'll only see a "C:\Program Files" folder.''')

```
결과=>

you'll only see a "C:\Program Files" folder.

-------------
### 코드5
```python
print('-' * 40)
print('절취선')
print('-' * 40)

print('''
----------------------------------------
절취선
----------------------------------------
      ''')

# 생각하지 못했던 해설풀이 기록
# 개행문자를 사용해 출력
print('-' *40 + '\n절취선\n' +'-' *40)

```
결과=>

-------------
### 코드6
```python

num1 ="72"
num2 =72

print(f'num1은 {type(num1)}데이터이고 num2는 {type(num2)}데이터이다.')
```
결과=>

-------------

### 코드7
```python
# 변수 선언
num1 ="72"
num2 =72

new_num1 = int(num1)

print(new_num1 == num2)

# 해설풀이 기록
num1, num2 = "72", 72
print(int(num1) == num2)

```
결과=>

-----------------
### 코드8
```python

print('아버지가','방에','들어가신다')
print('아버지가\t방에\t들어가신다')
```
결과=>


파이썬 공부 중.
탈출문자 중에서 띄어쓰기 기능 존재?


-------------
### 코드9
```python
#  sol)1 따옴표 세 개를 사용하는 방법
print(
'''
서울에서 제주도를 가는 방법
1. 비행기를 탄다.
2. 수영을 한다.
'''
)

# sol)2 개행문자 사용 풀이
print("서울에서 제주도를 가는 방법\n1. 비행기를 탄다. \n2. 수영을 한다.")



```
결과=>

-------------
### 코드10
```python
a = 2
b = 4

print(f'{a+b} {a-b} {a*b} {a/b}')

# 해설풀이
print(a+b,a-b,a*b,a/b)

```
결과=>

같은 데이터 타입
하나의 출력함수로 출력 가능
, 구분을 통해

-------------
### 코드11
```python
age = 31
height = 169.4

# 1. 포맷코드 사용
print('준빈이는 올해 %d살,키는 %0.1f이다.'%(age, height))

# 2. format 메서드 사용
print('준빈이는 올해 {}살,키는 {}이다.'.format(age, height))

#3. 문자열 스트링 방법 사용
print(f'준빈이는 올해 {age}살,키는 {height}이다.')

```
결과=>

파이썬 공부 중.
포맷코드 용어와 서식 지정자 용어 같은 용어?


"포맷 코드(format code)"와 "서식 지정자(format specifier)" 같은 의미로 사용
이들은 문자열 포맷팅을 위해 사용되며, 출력 형식을 지정할 때 어떻게 값을 포맷하는지를 결정하는 데 사용됩니다.



-------------
### 코드12
```python

# 적절한 변수 명명
name = '람머스'
age = 70

print("나의 이름은 %s이고, 나이는 %d이다."%(name, age))

```
결과=>

-------------
### 코드13
```python
print('철수','영희','민수','나', sep="랑 ")
```
결과=>

출력함수
안에 매개변수 정의되어 있음
매개변수안에 기본값 인수 들어가 있음
기본 설정값 존재/옵션 값 존재
sep 매개변수/옵션

ㅡ
ㅡㅡㅡㅡㅡㅡ파이썬 공부 중.
print() 출력함수에 숨겨진 sep 매개변수가 존재한다.
이러한 숨겨진 매개변수를 "옵션"이라는 용어를 사용?


"옵션"이라는 용어는 프로그래밍에서 함수나 메서드의 매개변수 중에서 선택적으로 설정할 수 있는 값들을 가리킬 때 사용됩니다. `print()` 함수의 `sep` 매개변수도 이에 해당하는 옵션 중 하나입니다.

선택적으로 설정 가능한 (옵션) 매개변수


-------------
### 코드14
```python
n = 2
m = 3

print(n**m)
```
결과=>

-------------
### 코드16
```python
print("hello", end=" ")
print("python")
```
결과=>
출력함수
end 옵션/매개변수 존재


-------------
### 코드17
```python
price = 20000

print(f"정상가격 : {price}원")
print(f"20% 할인 적용 가격 : {int(price*(1-0.2))}원")

#해설 풀이
price = 20000
sale = 80/100
print(price*sale)

```
결과=>
20% 할인
4000원 할인
원가X0.80 
원가X(1-20%)
원가X(1-0.20)
	GSAT 적성고사 문제 풀이 확인



-------------
### 코드18
```python
print(type(15),type(0.13),type("홍길동"),type([1,2,3]),type((1,3,5)),type({3,5,7}))

# 반복문 사용 풀이
datas = [15, 0.13, "홍길동", [1,2,3],(1,3,5),{3,5,7}]
for data in datas :
    print(type(data), end="")

```
결과=>
변수타입 확인 함수
type
출력함수 end 옵션 매개변수
파이썬 객체지향 언어
	부모클래스
		인스턴스 객체



-------------
### 코드19
```python
age = 34
name = "김진우"
height = 184.5

print("내 이름은 %s, 나이는 %d살이고 키는 %0.1f"%(name,age,height))

```
결과=>

------------
### 코드20
```python
txt = 'show me the money'
print(txt[8])

```
결과=>



-------------
### 코드21
```python
txt = 'show me the money'
print(len(txt))

```
결과=>

파이썬
문자열 길이 반환 함수 존재

-------------
### 코드22
```python
txt = 'show me the money'

print(txt.split())

```
결과=>

split() 문자열 메서드
옵션 매개변수 존재?

"기본값이 설정되어 있는 특정한 함수의 매개변수"를 "옵션이 설정되어 있는 매개변수"로 표현하는 것은 옳은 방식입니다. 이런 매개변수들은 함수 호출 시 옵션으로 사용될 수 있으며, 값을 명시하지 않았을 경우에는 기본값이 적용되게 됩니다.

-------------
### ~~코드23~~
	복습/기록
```python
rainbow = "빨주노초파남보"
print(rainbow.find('노'))

```
결과=>

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ파이썬 공부 중.
find()는 함수라고 표현? 메서드라고 표현?

-------------
### ~~코드24~~
	복습/기록
```python
hello = 'hello world'
print("a" in hello)
# print(hello in 'a')
```
결과=>


-------------
### 코드25
```python

name = '    홍킬동  '
print(name.lstrip()) # 좌
print(name.rstrip()) # 우
print(name.strip()) # 양쪽
```
결과=>

-------------
### 코드26
```python
hello = 'hello world'
HELLO = "HELLO WORLD"

print(hello.upper())
print(hello.lower())

```
결과=>

-------------
### 코드27
```python
proverb = 'By doubting we come at the truth'
# c문자의 인덱스를 찾는다
# print(proverb.find('c'))
print(proverb[proverb.find('c') : proverb.find('c')+4])

```
결과=>

ㅡ 질문
파이썬
find() 기능
특정 값 중 첫번째로 등장하는 인덱스 확인 알고 있음.
만약 두번째로 등장하는 인덱스를 확인하고 싶다면?

`find()` 메서드로 문자열 내에서 두 번째로 등장하는 인덱스를 확인하려면 두 번째 등장 이후의 부분 문자열을 검색하는 방법을 사용해야 합니다. 이를 위해서는 `find()` 메서드의 검색 시작 위치 매개변수를 사용하면 됩니다.

예를 들어, 아래 코드는 문자열 `"Hello, World! Hello!"`에서 두 번째 `"Hello"`의 인덱스를 찾는 방법을 보여줍니다:

```python
text = "Hello, World! Hello!"
first_index = text.find("Hello")
second_index = text.find("Hello", first_index + 1)  # 첫 번째 인덱스 이후부터 검색

print(first_index)  # 출력: 0 (첫 번째 "Hello"의 인덱스)
print(second_index) # 출력: 13 (두 번째 "Hello"의 인덱스)
```

위 코드에서 `text.find("Hello", first_index + 1)`는 첫 번째 `"Hello"` 이후부터 검색하도록 설정하여 두 번째 `"Hello"`의 인덱스를 찾습니다. 결과적으로 `second_index` 변수에는 `13`이 저장되어 두 번째 `"Hello"`의 인덱스가 출력됩니다.


`str.find()` 메서드의 두 번째 매개변수는 검색을 시작할 위치를 지정하는 매개변수입니다. 이 매개변수를 사용하면 특정 위치 이후부터 검색을 수행할 수 있습니다. 따라서 첫 번째 매개변수로 검색하려는 값, 두 번째 매개변수로 검색을 시작할 위치를 지정합니다.

```python
str.find(sub, start, end)
```

- `sub`: 찾을 부분 문자열
- `start` (선택사항): 검색을 시작할 인덱스. 기본값은 0.
- `end` (선택사항): 검색을 종료할 인덱스. 기본값은 문자열의 끝까지.



-------------
### 코드28
```python
proverb = 'By doubting we come at the truth'
# c문자의 인덱스를 찾는다
# print(proverb.find('c'))
print(proverb[-5 :])

```
결과=>

-------------
### 코드29
```python
proverb = 'By doubting we come at the truth'
print(proverb.replace('we','I'))

```
결과=>



-------------
### 코드30
```python

ph_price = 825900 # phone
monthly_price = 14900 # monthly_fee
total_day = 2 # period
total_price = ph_price + monthly_price*total_day*12

print(f'{total_day}년간 총 통신료는 {total_price}원 입니다.')

```
결과=>

폰 가격 
요금제 
월단위
총가격

Phone price
payment system 
Monthly unit
the total price

ph_price
monthly_price
total_price

-------------
### ~~코드31~~
	복습ㅇ
```python
population = '51,820,000'
# , 제거
population = population.replace(',','')
# 정수형 타입 변환 후 타입까지 출력
print(type(int(population)))
print(population)
```
결과=>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ파이썬.
replace() 메서드는 원본값을 수정하는 것?

ㅡ `str.replace()` 메서드는 원본 문자열을 직접 수정하지 않
	
대신에 원본 문자열을 변경한 새로운 문자열을 반환
	이렇게 함으로써 원본 문자열은 그대로 유지되며, 대체된 결과를 가진 새로운 문자열이 생성

##### 추가내용 =>
	원본값을 수정한다.
	새로운 객체를 반환한다.
	이해를 위한 추가내용

- 원본값을 수정하는 메서드/함수 예시:
- 새로운 객체를 반환하는 메서드/함수 예시:

```python
# 리스트의 append() 메서드는 원본 리스트에 새로운 값을 추가합니다.
my_list = [1, 2, 3]
my_list.append(4)  # 원본 리스트가 수정됩니다
print(my_list)     # 출력: [1, 2, 3, 4]


# 리스트의 sort() 메서드는 정렬된 새로운 리스트를 반환합니다.
my_list2 = [3, 1, 4, 2]
sorted_list = sorted(my_list2)  # 원본 리스트를 수정하지 않고 (변수에 할당하면서) 새로운 리스트를 반환합니다
print(sorted_list)  # 출력: [1, 2, 3, 4]
print(my_list2)      # 출력: [3, 1, 4, 2]


# 리스트의 sort() 메서드는 정렬된 새로운 리스트를 반환합니다.
my_list2 = [3, 1, 4, 2]
print(sorted(my_list2))  # 원본 리스트를 수정하지 않고 새로운 리스트를 반환(새로운 리스트 객체)도 하지 않고 바로 결과 출력됨
print(my_list2)      # 출력: [3, 1, 4, 2]

```

결과=>
![[Pasted image 20230831113718 1 1.png\|Pasted image 20230831113718 1 1.png]]
![[Pasted image 20230831113811 1 1.png\|Pasted image 20230831113811 1 1.png]]




-------------
### 코드32
```python
data = '1948-08-15'
print(data.split('-'))

```
결과=>

-------------
### 코드33
```python
member = ['홍길동', 185.4, 86]

print("{} 회원님의 키는 {}이고 몸무게는 {}kg입니다.".format(member[0],member[1],member[2]))

```
결과=>

-------------
### 코드34
```python
food = ['햄버거', '피자', '치킨', '부닭찌개', '족발']
print(food)
```
결과=>

-------------

### ~~코드35~~
```python
food_list = ['햄버거', '피자', '치킨', '부닭찌개', '족발']
food_list.append('김밥')
print(food_list)
```
결과=>

-------------
### ~~코드36~~
ㅡ 참고자료	: [[distribute/Python 파이썬/Content record folder/리스트 슬라이싱-슬라이스 객체\|리스트 슬라이싱-슬라이스 객체]]

```python



```
결과=>

리스트 자료형
데이터 삭제
del 키워드
pop()

- **Q. 헷갈린 부분**

ㅡ
del 키워드 문법상 
안쪽에 인덱스를 넣어서 리스트안에 들어있는 요소값을 삭제한다는데?
	
리스트 슬라이싱은 원본 리스트에서 가져온 값들에 대한 새로운 리스트는 반환출력 하는거 아님?
	
즉 del키워드 문법상 오류가 발생할 줄 알았는데 삭제가 되네?
이유가?

=>
애초에 헷갈린 부분이 틀림
del 키워드의 정의된 규칙?을 제대로 몰랐음.
인덱스를 넣어서 리스트 안에 있는 요소값을 삭제하는게 아님
정확한 설명은 아래와 확인






-------------
### ~~코드37~~
```python
food_list = ['햄버거', '피자', '치킨', '부닭찌개', '족발', '김밥']
food_list[3] = '부대찌개'
print(food_list)

```
결과=>



리스트 자료형
값 교체 메서드 존재?

replace() 메서드를 사용하는 것입니다. 이 메서드는 특정 값을 다른 값으로 교체합니다. 하지만 이 ==메서드는 문자열에서만 사용==할 수 있으므로, 리스트에서는 사용할 수 없습니다.

==리스트에서 값 교체를 위해서는 인덱스를 사용==하는 것이 가장 간단하고 효과적인 방법입니다.



-------------
### ~~코드38~~
```python
AmongUs = ['시민' ,'시민', '임포스터', '시민', '시민', '시민', '시민']
AmongUs.remove('임포스터')
print(AmongUs)

```
결과=>

리스트 자료형
특정 값
특정 요소 삭제 메서드


-------------
### ~~코드39~~
```python
food_list = ['햄버거', '피자', '치킨', '부대찌개', '족발', '김밥']
food_list.insert(4,'불고기')
print(food_list)

```
결과=>

리스트
값 삽입 메서드


-------------
### ~~코드40~~
```python
num_list = [1,3,5,7,11,123,1240,9999]
print(f'최솟값은 {min(num_list)}이고 최댓값은 {max(num_list)}입니다.')

```
결과=>

리스트 자료형
최대값
최소값 메서드
min
max


-------------
### ~~코드41~~
```python
animals = ['dog' ,'cat', 'rabbit', 'cow', 'goat', 'sheep', 'mouse']
new_list = []
for animal in animals :
    if len(animal) == 3 :
        new_list.append(animal)

print(new_list)

```
결과=>

파이썬 로직 작성문제

-------------
### ~~코드42~~
```python
# sol)1
dot = [1.5, 3.6, 4.53, 5.48, 6.87, 7.87, 8.89]
dot10 = []
for num in dot :
    dot10.append(num*100)

print(dot10)

# sol)2
# 반복 횟수 7번
dot = [1.5, 3.6, 4.53, 5.48, 6.87, 7.87, 8.89]
i = 0
while i < len(dot) :
    dot[i] = dot[i]*100
    i += 1

print(dot)

# 복사 여부 확인
dot = [1.5, 3.6, 4.53, 5.48, 6.87, 7.87, 8.89]
# dot100 = dot # 얇은 복사 진행
dot100 = dot[:] # 깊은 복사 진행 > 원본 객체 값 유지
i = 0
while i < len(dot) :
    dot100[i] = dot[i]*100
    i += 1

print(dot100)
print(dot)


```
결과=>

so1
for 반복문

sol 2
	while문

-------------
### ~~코드43~~
```python
# 평균 = 총합 / 개수
score = [60, 75, 85, 85, 85, 90, 70, 90, 80]
avg = sum(score)/len(score)
print(avg)

```
결과=>

-------------
### ~~코드44~~
```python

a = 5
b = 6
c = 7

s = (a+b+c)/2
S = (s*(s-a)*(s-b)*(s-c))**0.5

print(f'삼각형의 넓이는 {S}')


# 처음 풀이 오류 발생
a = 5
b = 6
c = 7

s = (a+b+c)/2
S = (s(s-a)(s-b)(s-c))**0.5

print(f'삼각형의 넓이는 {S}')


```
결과=>
이미 문제에서 공식을 알려줌
그대로 작성하면 됨
이게 알고리즘 문제인가?

TypeError: 'float' object is not callable 오류는 일반적으로 함수처럼 호출하려고 하는데 실제로는 float 객체인 경우 발생합니다

즉 함수가 아닌데 객체인데 함수처럼 "()"를 사용해 호출하고 있을 때 발생하는 타입오류
	
예시코드
s = 10.5
print('Cost: %0.2f' % s())
	
함수처럼 호출하지 않고, 그냥 변수로 사용해야 합니다.
s = 10.5
print('Cost: %0.2f' % s)



-------------
### ~~코드45~~
```python
num_list = [100,101,102,103,104,105,106,107]

odd_nums = []
for num in num_list :
    if num%2 == 1 :
        odd_nums.append(num)

print(odd_nums)
```
결과=>
키워드 풀이 기록

리스트 요소
홀수 출력



-------------
### ~~코드46~~
```python
num_list = [1,2,3,4,5,6,7,8,9]

# so1)
print(num_list[2::3])

# sol)2
nums = []
for num in num_list :
    if num%3 == 0  :
        nums.append(num)

print(nums)

```
결과=>
키워드 풀이
리스트 슬라이싱


-------------
### ~~코드47~~
```python
num_list = [1,2,3,4,5,6,7,8,9]
print(num_list[::-1])

```
결과=>
키워드 풀이

리스트 슬라이싱 특징 생각
역순출력




-------------
### ~~코드48~~
```python
message = "나는/너를/사랑해"
print(message.split("/"))
print(message)

```
결과=>
키워드 풀이

문자열 나누기
split 메서드 사용

-------------
### ~~코드49~~
```python

animals1 = ['dog' ,'cat', 'rabbit', 'cow', 'goat', 'sheep', 'mouse']
animals2 = ['dog' ,'cat', 'rabbit', 'cow', 'goat', 'sheep', 'mouse']
# animals3 = animals1.extend(animals2)
print(animals1.extend(animals2))
print(animals1) # 원본 객체 업데이트
```
결과=>

키워드 풀이

extend() 메서드 
서로 다른 리스트 합침

-------------
### ~~코드50~~
```python
results = [True ,False, False, True, False, True, True, False, True]

print(f'리스트 results는 총 {len(results)}개의 요소를 가지고 있고, True는 {results.count(True)}개 False는 {results.count(False)}개입니다.')

```
결과=>
키워드 풀이

count()
len()
이용

-------------
### 코드51
```python

# # 튜플 선언 1
tuple1 = (700, "왕라면", 65.3, True)
print(tuple1)
print(type(tuple1))

# 튜플 선언 1 -1
# 소괄호 생략 가능
tuple1 = 700, "왕라면", 65.3, True
print(tuple1)
print(type(tuple1))

```
결과=>
키워드 풀이

튜플 자료형 선언 2가지 방법
	리스트 자료형 차이점


변수에 
여러 값들을 한번에 할당하면 자동으로 튜플 자료구조 형태로 할당되는구나

변수에 여러 값들을 한번에 할당하면 자동으로 튜플 자료구조 형태로 할당

-------------
### 코드52
```python
nums = 1,2,3,4,5,6,7,8,9
print(nums, type(nums))

# 일부로 오류 발생 > 메세지 확인
nums.append(6)
# AttributeError: 'tuple' object has no attribute 'append'

```
결과=>


-------------
### 코드53
```python
nums = 1,2,3,3,4,5
print(nums, type(nums))


print(f"튜플의 총 길이는 {len(nums)}이고 최댓값은 {max(nums)}, 최솟값은 {min(nums)} 입니다.")

```
결과=>

키워드 풀이

튜플 자료형
길이 파악 
최대값
최소값 파악 메서드/함수

-------------
### 코드54
```python
text = "가나라다마바사"
print(tuple(text))

```
결과=>
키워드 풀이

튜플 형변환
튜플함수

일반
내장
기본
데이터 타입


-------------
### 코드55
```python
nums = 1,2,3,4,5

# 리스트로 형변환
list_nums = list(nums)

# sol 1 for 풀이
for num in range(6,30+1) :
    list_nums.append(num)

# sol 2 while 풀이
i = 6
while (i < 31) :
    list_nums.append(i)
    i += 1

# 출력
print(nums)
print(list_nums)

```
결과=>

키워드 풀이

list 형변환

반복문 로직 작성
6~30 요소 추가
range함수

1번 for 풀이
2번 while 풀이


-------------
### 코드56
```python
import sys

tnums = 1,2,3,4,5
lnums = [1,2,3,4,5]

print(f"튜플 메모리 사이즈 {sys.getsizeof(tnums)}bytes, 리스트 메모리 사이즈 {sys.getsizeof(lnums)}bytes 이다.")

```
결과=>

키워드 풀이

튜플 <> 리스트 자료형 차이점 생각
수정 x <> 수정 ㅇ
	따라서 당연
	튜플 사이즈 더 작음



-------------
### 코드57
```python

rainbow = '빨' ,'주', '노', '초', '파', '남', '보'
print(rainbow[:4])
print(rainbow[2::2])
print(rainbow[:3:-1])

```
결과=>

키워드 풀이

변경가능한 <> 변경불가능한 자료형 차이점
인덱싱 유뮤가 X 
	리스트, 튜플 모두 가능


ㅡ 
('보', '남', '파')
처음엔 출력결과 이해 x

이제 이해 ㅇ

튜플 내 요소의 순서를 역순으로 바꾸어 `('보', '남', '파', '초', '노', '주', '빨')`를 결과로 반환 후 

[:3] 슬라이싱 연산이 진행되는 것
따라서
전체적인 순서가 역순 변경 후
처음부터 ~ 3인덱스 전까지 슬라이싱되면
보 남 파 출력


-------------
### 코드58
```python
# 1번 풀이
num_list = []

for num in range(100, 79,-1) :
    # print(num)
    if num%2 ==0 :
        num_list.append(num)

num_tuple = tuple(num_list)
print(num_tuple)

# 2번 풀이
nums = tuple(range(100,79,-2))
print(nums)

```
결과=>

키워드 풀이

range함수
세 개의 매개변수를 가지고 있어서 세 개의 인수를 입력할 수 있습니다.


ㅡ 
2번풀이
더 쉽게 푸는 방법이 존재

반복문 로직을 사용할 필요 없이 
한번에 range함수 간격 매개면수를 이용

-------------
### 코드59
```python

nums = tuple(range(1, 1500+1))
print(sum(nums))

```
결과=>

ㅡ 키워드 풀이

range함수
튜플자료형


-------------
### 코드60
```python
# set 자료형 특징 생각

# 다양한 자료형
a = 7
b = 3.14
c = True
d = 1,2,3
e = [1,2]

list1 = [a,b,c,d,e]
print(list1)


set1 = a,b,c,d,e
print(set1,type(set1))

```
결과=>

ㅡ 키워드 풀이

세트 집합 자료형 
특징 생각
	추가 삭제 가능
	하지만
	인덱스x 중복 x


-------------
### 코드61
```python
set1 = {1,2,3,4,5}
for i in range(6, 11) :
    set1.add(i)

print(set1)

list1 = [11,12,13,14,15]
# print(set(list1))
# set1.update(set(list1))
set1.update(list1)

print(set1)

```
결과=>


add , update 메서드 사용


update() 메서드는 세트 자료형에 다른 세트나 반복 가능한(iterable) 객체의 모든 요소를 추가하는 메서드입니다.
예를 들어, 다음과 같이 두 개의 세트를 만들고 update() 메서드를 사용하여 첫 번째 세트에 두 번째 세트의 요소를 추가
```
set1 = {1, 2, 3}
set2 = {4, 5, 6}

set1.update(set2)

print(set1)  # 출력: {1, 2, 3, 4, 5, 6}
```

, update() 메서드는 세트에 반복 가능한(iterable) 객체의 요소를 추가할 수도 있습니다. 예를 들어, 다음과 같이 리스트를 사용하여 세트에 요소를 추가
```
set1 = {1, 2, 3}
set2 = {4, 5, 6}

set1.update(set2)

print(set1)  # 출력: {1, 2, 3, 4, 5, 6}
```

----------------
### 코드62
```python
a = [1,2,3]
b = [4,5,6]
c = a + b
print(c)

a = {1,2,3}
b = {4,5,6}
c = a + b
print(c)


# 2번 풀이
odd_nums = {1,3,5,7,9}
even_nums = {2,4,6,8,10}
nums = odd_nums.union(even_nums)

print(f'집합 set1은 {odd_nums}, 집합 set2는 {even_nums} 이고 두 집합의 합집합 set3는 {nums} 입니다.')


```
결과=>

키워드 풀이
set 집합 자료형
합집합 기능 메서드 존재


리스트끼리는 결합 연산이 되는데 세트 자료형끼리는 왜 결합 연산이 오류 발생? 이유는? 

단순 정의 차이
1. 리스트(list)는 결합 연산을 지원합니다. 두 개의 리스트를 `+` 연산자로 결합할 수 있습니다.
    
2. 세트(set)는 결합 연산을 지원하지 않습니다. 따라서 세트를 `+` 연산자로 결합하려고 하면 TypeError가 발생합니다.


--------------
### 코드63
```python
# 1번 풀이 오류가 발생했던 풀이 =>
num_set = {1,2,3,4,5,6,7,8,9,10}
num_set_copy = num_set.copy()
for num in num_set_copy :
    if num%2 != 0 :
        num_set_copy.remove(num)

print(num_set)
print(num_set_copy)

#1번 풀이 수정
num_set = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
num_set_copy = set()  # 빈 집합 생성

for num in num_set:
    if num % 2 == 0:
        num_set_copy.add(num)  # 짝수인 경우만 복사 집합에 추가

print(num_set)
print(num_set_copy)


# 2번 풀이
# 2번 풀이
num_set = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
for i in range(1, 10, 2) :
    num_set.remove(i)

print(num_set)


```
결과=>

집합 자료형 특징 생각
반복문
remove 메서드
discard 메서드


- 1번 풀이
오류가 발생하는 이유는 num_set_copy라는 집합(Set)을 반복하면서(for num in num_set_copy) 해당 집합을 수정하려고 시도하기 때문입니다. 파이썬에서는 집합을 반복하면서 수정하는 것이 안전하지 않으며, 이로 인해 예기치 못한 동작이 발생할 수 있습니다.
집합을 수정하려면 별도의 데이터 구조를 사용하거나 반복하면서 수정할 요소를 다른 컨테이너(예: 리스트)에 저장한 다음 집합을 수정하는 것이 좋습니다.

지금은 새로운 빈 집합을 생성하는 방법으로 작성
이렇게 수정하지 않은 집합을 기반으로 수정된 집합을 생성하는 것이 안전합니다.

근데 문제에선 제거하는 메서드를 사용하라고 했는데?
집합을 반복하면서 수정하려고 하는건 오류가 발생하고
반복하지 않고 단순 제거하는건 오류가 발생하지 않는다?


ㅡ 내용기록
1번 풀이에서 `num_set_copy`를 복사한 후 반복문에서 집합을 수정하려고 하면 오류가 발생하는 이유는, 집합을 반복하면서 그 집합을 수정하면 반복 중에 집합의 구조가 변경되어 예기치 못한 동작이 발생할 수 있기 때문입니다. 이러한 동작은 파이썬에서 안전하지 않다고 판단되며, 따라서 오류가 발생

2번 풀이에서는 집합(`num_set`)을 직접 수정하는 대신 `range(1, 10, 2)`를 사용하여 1에서 10까지 홀수 값을 생성하고, 이 값들을 집합에서 직접 제거하고 있습니다. 이 경우 집합을 반복하면서 수정하는 것이 아니라, 직접 특정 값을 제거하므로 오류가 발생하지 않습니다.


직접 수정하다
	set 자료형안에 들어있는 요소값들을 가지고 수정을 하려고 하면...

파이썬에서 컨테이너(예: 리스트, 집합)를 반복하면서 수정하려면 보통 원본 컨테이너를 복사하고 수정할 때 복사본을 수정하는 것이 권장됩니다. 1번 풀이에서는 `num_set`을 수정하고 싶은 경우 `num_set_copy`를 수정하는 것이 좋습니다.

즉 복사본을 만들어서 거기에 원하는 값을 넣어가면서 수정하는 방식으로


집합(set)은 일반적으로 반복(iteration) 중에 직접 수정되지 않도록 설계되어 있습니다.
	따라서 반복문을 이용해 직접 요소들에 접근해서 수정하는게 아니라
	복사본을 만들어서 거기에 데이터를 하나씩 넣으면서

------------
### 코드64
```python

## sol 1)  내 풀이
# 2배수 리스트에 할당
num_2 = []
for num in range(2, 100) :
    if num%2 == 0 :
        num_2.append(num)
# 중간 확인
# print(num_2)

# 3배수 리스트에 할당
num_3 = []
for num in range(3, 100) :
    if num%3 == 0 :
        num_3.append(num)
# 중간 확인
# print(num_3)

multiple2 = set(num_2)
multiple3 = set(num_3)

print(multiple2 & multiple3)
print(multiple2.intersection(multiple3))

print("ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ")

## sol 2)  해설풀이
# 반복문 사용하지 않고 리스트 컴프리헨션 사용해 리스트 값들을 표현
multiple2 = [i for i in range(2,100,2)]
multiple3 = [i for i in range(3,100,3)]
# # 확인
# print(multiple2)
# print(multiple3)
print(set(multiple2) & set(multiple3))


추가내용 =>

# 세트 요소값으로 리스트 자료형들의 값들 ㅇ 
numbers = [1, 2, 3, 4, 5]
number_set = set(numbers)
print(number_set)  # {1, 2, 3, 4, 5}

# 세트 요소값으로 리스트 자료형 x 
number_set = set([[1, 2, 3, 4, 5]])
print(number_set) # TypeError: unhashable type: 'list'

```
결과=>

set자료형
특징 복기

순서 x
중복값 x
D 가능 = mutable 자료형
	수정-변경-삭제

set에 들어가는 값들은 immutable

교집합 메서드

ㅡ 추가자료
세트 자료형에 리스트로 값을 할당한다는 것은, 리스트의 요소들을 세트에 추가하는 것을 의미합니다.
리스트 값 자체를 들어갈 수 없지만
예를 들어, 다음과 같이 리스트를 세트에 할당할 수 있습니다:
```
numbers = [1, 2, 3, 4, 5]
number_set = set(numbers)
print(number_set)  # {1, 2, 3, 4, 5}
```
세트에 리스트로 값을 할당하는 것은 세트에 고유한 값들을 추가하고 중복을 제거하는 효과가 있습니다.


ㅡ 추가자료
**Hashing**
**Type Casting 또는 Type Conversion**
**Casting**
"해슁하다", "형변환하다", "캐스팅하다"는 모두 같은 의미를 가지며, 데이터의 타입을 변환하는 것을 의미합니다. 이러한 용어들은 프로그래밍에서 자주 사용되는 표현이며, 데이터를 다른 형식으로 변환하는 작업을 의미합니다. 예를 들어, 정수를 실수로 변환하거나 문자열을 정수로 변환하는 것이 형변환의 예입니다.

---------------
### 코드65
```python
dict_box = {
    '삼성1' : 21900,
    '삼성2' : 21900,
    '삼성3' : 21900,
    '삼성4' : 21900
}

print(dict_box)
```
결과=>
키워드 풀이

딕셔너리 자료형
	특징

세트와 딕셔너리 자료형
공통 특징 존재
	중괄호 정의
	중복x
	인덱스 = 순서 x 


-------------
### ~~코드66~~
```python
# sol 1
dict_box = {
    '삼성1' : 21900,
    '삼성2' : 21900,
    '삼성3' : 21900,
    '삼성4' : 21900
}

print(dict_box)

# 값 추가 방법 1.
dict_box['애플1'] = 398610
dict_box['애플2'] = 185600
print(dict_box)

# 값 추가 방법 2.
dict_box.update({'애플1' : 398610})
dict_box.update({'애플2': 185600})
print(dict_box)

```
결과=>



-------------
### ~~코드67~~
```python
dict_box = {
    '삼성1' : 21900,
    '삼성2' : 21900,
    '삼성3' : 21900,
    '삼성4' : 21900
}

# print(dict_box)

dict_box.update({'애플1' : 398610})
dict_box.update({'애플2': 185600})
# print(dict_box)

dict_box_key = dict_box.keys()
print(dict_box_key) # dict_keys(['삼성1', '삼성2', '삼성3', '삼성4', '애플1', '애플2'])
print(list(dict_box_key)) # ['삼성1', '삼성2', '삼성3', '삼성4', '애플1', '애플2']
dict_box_value = dict_box.values()
print(dict_box_value)
print(list(dict_box_value))

```
결과=>


-------------
### ~~코드68~~
```python
animals = {
    '개' : 'dog',
    '고양이' : 'cat',
    '소' : 'cow',
    '양' : 'sheep'
}

# 풀이 1
for animal in animals.keys() :
    print(animal, end=' ')

# 풀이 2
for animal in animals :
    print(animal, end=' ')


```



-------------
### ~~코드69~~
```python
animals = {
    '개' : 'dog',
    '고양이' : 'cat',
    '소' : 'cow',
    '양' : 'sheep'
}

# 풀이 1
for animal in animals.values() :
    print(animal, end=' ')
```



-------------
### ~~코드70~~
```python
animals = {
    '개' : 'dog',
    '고양이' : 'cat',
    '소' : 'cow',
    '양' : 'sheep'
}


for k, v in animals.items() :
    print(f'key = {k}, value = {v}')
```

-------------
### 코드71
```python


```
결과=>
키워드 풀이

파이썬 로직 작성 문제
변수를 선언

조건문 사용

기본해설 간단하다
좀 더 사용자 친화적인
반응적인 코드로 수정


-------------
### 코드72
```python


```
결과=>

사용자가 입력한 값에 따른 다른 출력값
결과 흐름을 제어
제어문 조건문  반복문 사용하면 될듯



-------------
### 코드73
```python
import random

random_number1 = random.randint(1, 100)
print(random_number1)
random_number2 = random.randint(1, 100)
print(random_number2)
random_number3 = random.randint(1, 100)
print(random_number3)


if random_number1 > random_number2 :
    if random_number1 > random_number3 :
        print("random_number1 제일 큼")
    else :
        print("random_number3 제일 큼")
elif (random_number2 > random_number3) :
    print("random_number2 제일큼")
else :
    print("random_number3 제일 큼")

# 시행횟수 파악
반복_횟수 = 0
while True :
    random_number1 = random.randint(1, 100)
    print(random_number1)
    random_number2 = random.randint(1, 100)
    print(random_number2)
    random_number3 = random.randint(1, 100)
    print(random_number3)

    반복_횟수 += 1
    print("현재 시행 횟수 =>", 반복_횟수)
    if (random_number1 == random_number2 == random_number3) :
        print("3개 모두 일치할 때 시행 횟수", 반복_횟수)
        break
    # elif (random_number1 == random_number2 or random_number2 == random_number3 or random_number1==random_number3 ) :
    #     print("3개 중 2개 같을 때 시행 횟수는?", 반복_횟수)
    #     break


```
결과=>
데이터 종류
int 자료형

출력결과
입력한 값 중에서
가장 큰 수 판별하는 기능

각각 한번씩 크기비교


해설풀이
각각의 경우의 수
한줄로 표현
추가 경우의 수 존재
모든 수가 같을 수도 있음
	확률은 낮다

-------------
### 코드74
```python


```
결과=>
키워드 풀이

70점 이상이면 합격

시험점수 리스트 자료형안에 요소값들로 존재

로직 작성
조건문
요소값마다 조건 파악 > 출력

리스트 자료형
접근 가능한
순서가 있는
시퀀스 자료형
반복문 사용
조건문작성

몇 명인지 파악하기 위해
합격자 만점자 불합격자 
비어있는 리스트 자료형 변수 생성
할당시킨다
마지막에 내장함수 사용 
길이파악

출력문
문자열 포매팅
내장함수 사용
	길이파악

ㅡ 해설풀이
합격자 조건문 작성
합격자 중에서 만점자를 한번 더 조건 확인 하는 것 

현재 상황
카운팅만 하면 되는 상황
따라서 굳이 리스트에 할당 x 

3개 중 2개를 알면 1개를 구할 수 있다
지원자수 = 합격자 + 불합격자 



-------------
### 코드75
```python
# 비어있는 수열값을 담을 리스트
a = []
n = 12

# 이 반복문 로직을 작성한 이유
# 리스트 자료형 특징 생각
# 비어있는 리스트에 인덱스/인덱싱을 이용해 새로운 값을 할당 x 오류발생
# 따라서 주어진 주열 마지막 n값으로 비어있는 리스트에 값을 할당해두고 값을 인덱싱으로 수정해 나가는 방향으로 작성
for i in range(n) :
    a.append(i)
print(a) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

for i in range(12) :
    if( i >= 2 ) :
        a[i] = a[i-1] + a[i-2]

    else :
        # i = 0, 1 일 땐 수열 리스트에 바로 할당
        a[i] = i

print(a) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]





```
결과=>
키워드 풀이

인적성문제
수열
	피보나치수열
수열 관계식 생각
1번자리 + 2번자리 = 3번자리
	2번자리 + 3번자리 = 4번자리......

ㅡ
리스트에 이미 값이 존재하는 경우에는 인덱스를 통해 해당 위치의 값을 수정할 수 있습니다. 하지만 리스트가 비어있는 경우에는 인덱스를 통해 값을 할당할 수 없습니다. 이는 리스트에 해당 인덱스가 존재하지 않기 때문입니다.  
  
비어있는 리스트에 값을 할당하려면 append() 메서드를 사용하여 값을 리스트에 추가해야 합니다.

그렇다면
주어진 n값에 따라
미리 리스트에 아무런 값을 대입


ㅡ 해설풀이 =>
내 풀이보다 해설풀이가 더 적절한 풀이 같다

어떻게 풀었을까
생각 / 행동?
배운다


비어있는 리스트
피보나치수열 규칙? 생각
1번항 2번항은 규칙x 
	따라서
	바로 리스트 값 추가

3번 항부터 규칙이 적용되야함
	3번항 = 2번항 + 1번항

나와 다른점
값을 리스트에 수정하는 방식이 아닌
값을 바로바로 넣어주는 방식
메모리 상
해설풀이가 더 적절




-------------
### 코드76
```python


```
결과=>
키워드 풀이

문제의도
정수 자료형 들어있는 변수
1의 자리에서 반올림한 결과를 출력

로직/프로그램을 작성 안 하고
이미 정의된 내장함수에 반올림 기능이 있지 않나?

ㅡ 해설풀이
이 관점 생각
2자리 자연수
1의 자리 확인하기 위해선
10으로 나눈 나머지를 확인

3자리 자연수
십의 자리 확인하기 위해선
100으로 나눈 나머지 확인
동시에
일의 자리 확인하기 위해선
출력된 나머지에서 다시 10으로 나눈 나머지를 확인 
. . .

좀 더 명확하게 표현하면
	두 자리 자연수에서 일의 자리 숫자를 확인하기 위한 관계식

저러한 수학적 표현으로
반올림결과를 표현했구나
5보다 작을땐 
	뺀다
5보다 클 땐
	더한다
	그냥 더하는게 아니라 
	10 - 나머지 값 = 나온값을
다른 방법으로도 표현 가능
	원래값 - 나머지값 + 10
같은 결과를 출력


-------------
### 코드77
```python
year = int(input("확인하고 싶은 해를 입력 => "))

# if (year % 400 == 0) or (year % 4 ==0 or year % 100 ==0)  :
if (year % 4 ==0) and (year % 100 !=0)  :
    print(f'{year}년은 윤년입니다.')
# elif (year % 4 ==0) and (year % 100 != 0) :
elif (year % 4 ==0) :
    print(f'{year}년은 윤년입니다.')
else :
    print(f'{year}년은 윤년이 아닙니다.')

```
결과=>
키워드 풀이

윤년
조건을 잘 생각

4의 배수인지 아닌지 확인
100의 배수인지 아닌지 확인
400의 배수인지 아닌지 확인

ㅡ 해설풀이
내 풀이와 같음
패스

-------------
### 코드78
```python


```
결과=>
키워드 풀이

현재 무게
	131
일주일
	-2 목표
		100미만 목표

반복문 사용
주차별 무게 출력
100미만 시 축하메세지 출력



ㅡ 툭툭 간단 풀이

변수에 무게 할당

무한반복문 사용
특정한 조건/상황에 도달하면 중단되도록 작성
	무게 < 100 일때 중단


시행될떄마다
새로운 값으로 수정됨

무게 기본값 설정
주차 기본값 설정



-------------
### 코드79
```python
# 내 풀이
# 마지막 값 100
# 비어있는 변수
num = 0

# 문제에 존재하는 로직 표현
# 규칙파악 =>
    # 짝수일 땐 -
    # 홀수일 땐 + 연산 진행
for i in range(1, 100+1) :
    if i%2 == 0 :
        # 짝수일 때 연산 작성
        print(f'현재 num값 = {num}')
        num -= i
        print(f'{i}는 짝수, 따라서 현재 num 값에 - {i} 하면 = {num} 이다')

    else :
        # 홀수일 때 연산 작성
        print(f'현재 num값 = {num}')
        num += i
        print(f'{i}는 홀수, 따라서 현재 num 값에 + {i} 하면 = {num} 이다')

print(num)


```
결과=>

ㅡ 의도파악
주어진 수식을 계산하는 로직 작성

ㅡ 기억
문제에서 최종 출력하고자 하는 값이 어떠한 형태인지 파악
로직 생각
규칙 생각

ㅡ 해설풀이

-------------
### 코드80
```python


```
결과=>

키워드 풀이

주어진 수식 해결하는 수학적인 로직 작성

ㅡ 해설풀이
규칙성 파악
수식으로 표현

1
	2
		3
			4...
				55

55
	54
		53
			...1

반복문 사용 

-------------
### 코드81
```python
money = int(input("잔돈 입력 : "))

# 로직작성
money_10000 = money//10000
money_5000 = (money%10000)//5000
money_1000 = ((money%10000)%5000)//1000
money_500 = (((money%10000)%5000)%1000)//500
money_100 = ((((money%10000)%5000)%1000)%500)//100
money_1 = (((((money%10000)%5000)%1000)%500)%100)//1

# 원하는 형태로 출력 문자열 포맷팅
print(f'잔돈 : {money}\n10000원권 : {money_10000}\n5000원권 : {money_5000}\n1000원권 : {money_1000}\n500원권 : {money_500}\n100원권 : {money_100}\n 1원 : {money_1}')

```
결과=>

키워드 풀이

ㅡ
문제의도

프로그램작성
로직작성

돈을 입력했을때
단위별로 파악


ㅡ 해설풀이 =>
수학적
수식적으로 접근

똑같이 풀었네




-------------
### 코드82
```python


```
결과=>
키워드 풀이

프로그램작성
로직작성

시급정해져있음

조건문 작성
흐름제어
8시간을 기준

8시간이하
	시급 x 일한시간 출력

8시간 이상
	시급 x 일한시간 x (일한시간 - 8 )(시급 / 2 )

ㅡ 해설풀이
단순
수학 관계식 작성 후
코드 작성

적절한 변수 명명 규칙

hour
money
	시간당 얼마
overtime
	초과 시간당 얼마

조건문 사용
흐름제어
상황/조건에 따른 결과 출력

소수점 제거 원함
int 내장함수 사용

-------------
### 코드83
```python
# 구구단
for i in range(2, 9+1) :
    print(f"<{i}단>")

    for j in range(1,9+1) :
        print(f"{i} X {j} = {i*j}")

    print()

```
결과=>
너무 대표적인 문제
바로 푼다
이건

ㅡ  해설풀이
하나의 상황을 
단계적으로 쪼개서 생각
	~한 결과 나온다
	단계적으로 쪼갠다




-------------
### 코드84
```python
n = 5 # 초기 개수

while (n >= 1 ) :
    print(str(1) * n)
    n -= 1

```
결과=>
너무 대표적인 문제
바로 푼다

ㅡ 내 풀이 

변수 초기 개수 할당

n 개수가 
5 4 3 2 1 
1보다 작아지는 순간 반복문이 종료
따라서 while 반복문 

출력되야 하는건 1
파이썬 문법 복기
문자 타입 x 숫자 타입 가능
문자타입이 숫자 만큼 곱해져서 출력됨

시행마다 
n 개수 1씩 감소하면서
무한반복을 피함

ㅡ 해설풀이
for 이중 반복문을 이용해 풀이 가능
range



-------------
### ~~코드85~~
```python
```
결과=>

- 과정별/키워드 풀이
ㅡ
시행마다
0이 점점 증가 <> 1이 점점 감소
	
화면에 보이는 숫자를 문자형으로 인식
왜?
	문자 타입 <> 숫자타입 연산 처리 가능하기 때문
	
1 카운팅 개수가 1보다 작아지면 종료




-------------
### 코드86
```python
# gpt 풀이 
size = int(input("마름모의 크기를 입력하세요: "))

for i in range(size):
    print(" " * (size - i - 1) + "*" * (2 * i + 1))

for i in range(size-2, -1, -1):
    print(" " * (size - i - 1) + "*" * (2 * i + 1))

```
결과=>

ㅡ gpt 해설 이해

표현식 이해가 필요
```
for i in range(5, 2, -1) :
    print(i)
```

5부터 역순으로 출력한다
2미만까지
	5 4 3

마름포를 표현을 이렇게 생각했고
이러한 로직으로 풀었구나
	첫 번째 반복문에서는 마름모의 윗부분을 출력하고, 두 번째 반복문에서는 마름모의 아랫부분을 출력합니다. 공백과 `*`을 적절히 조합하여 마름모 모양을 만들

윗 부분
	0 출력 개수 점점 감소
	별 출력 개수 점점 감소
아랫부분
	0 출력 개수 점점 증가
	별 출력 개수 점점 증가


ㅡ 해설풀이
과정별 상황 파악
	0 n개 / 1 m개 / 0 n개
	0 n-1개 / 1 m+2개 / 0 n-1개

윗 부분
아랫부분
역순으로 진행되는 상황 규칙 파악
따라서
윗부분
아랫부분
나눠서 생각한다



1번 반목분
시행횟수 의미 = 출력횟수 의미

2번 반복문
실질적으로 출력할 것들 의미
개수를 의미

반복할 것들에 대한 for 반복문을 각각 작성
	이렇게도 생각할 수 있구나
0에 대한 반복문
1에 대한 반복문-

신기함
같은 문제
같은 출력
	하지만 완전히 다른 
	접근방식 로직작성


해설풀이 이해 ㅇ
1번 풀이
2번 풀이 중 1번풀이 더 좋은 풀이
왜?
중복되는 코드행 적다
직관적이다





-------------
### 코드87
```python


```
결과=>
ㅡ 해설풀이

한 줄당 9번 출력
총 9줄 출력이구나 

1번 반복문 총 출력 횟수
2번 반복문 각각 출력 횟수
	반복 실행 횟수를 의미함

즉 range함수는
있는그대로 숫자를 이용할수도 있고
단순 반복실행횟수를 이용할 수도 있다
	2가지 기능으로 수행가능



-------------
### ~~코드88~~
```python
# 1번 풀이


```
결과=>

```python
# 3번 풀이

```

- 문제 상황 파악
ㅡ
프로그램 작성
	로직작성

ㅡ
10보다 작은 수에서
3 또는 5 배수
	3 6 9
	5 
다 더하면 23
따라서
1000보다 작은 수
3또는 5배수 총합구해라

ㅡ 
3번 풀이가 가장 짧고 간단하다.
	
조건문에 or연산자를 사용해서 동시에 확인을 거치면서
나중에 공배수값들을 한번에 빼줄필요 없이
2개 조건 중 1개가 먼저 참이면 바로 더해지도록 해서
중복되는 값이 더해지지 않도록 작성함
	
즉 더 좋은 풀이


-------------
### ~~코드89~~

```python
# 1번 풀이


```

=>
첫 풀이 틀림
문제에 나와있는 것 처럼 num이 24일땐 문제없음
하지만 소인수들은 2와 3말고 더 있었다.
ex) 5...7..11..13..
	
매번 소수들을 확인하는 if문을 작성하는건 비효율


```python
# 2번 풀이


```
결과=>
키워드 풀이

ㅡ
소인수분해 해주는 프로그램 작성
과정별 내용 생각
	로직 작성

ㅡ
2로 나눈다
나머지가 1이 나올 떄 까지
	
저렇게 코드를 작성해야
처음 2로 먼저 계속 나누고 > 3으로 계속 나누고 > 5 나누고....
이런식으로 진행되는구나

ㅡ
빈 리스트 정의
인수들을 1개씩 넣어준다
변형가능한 자료형 특징 활용

ㅡ
while 반복문 
	n이 1이 되는순간 반복문 종료되야함
	
n을 i = 2 로 나눠서 나눠떨어지면 확인
	나눠떨어진다면
	2를 리스트에 할당
	
기존에 존재하면 n에 새로운 값을 할당시킴
	갱신
	덮어쓰기

ㅡ
소인수분해 과정 생각
2로 계속 나눠보다가
안되면 3으로 나누기를 시작
	i += 1로 표현했음
		이 생각을 못했네
	
반복문이 종료되면
n이 1이 될때까지 나눈 상황
	
따라서 반환출력함 리스트를 


##### 메모
ㅡ 참고자료 : [[제너레이터 표현식_컴프리헨션 표현식]]


```python


```

=>
3번 풀이 이해 ㅇㅇㅇ
하지만 2번 풀이가 좀 더 깔끔하다.





-------------
### ~~코드90~~
```python

```
결과=>

ㅡ 문제 의도 
	
함수 정의 문제


-------------
### ~~코드91~~
```python


```
결과=>

ㅡ 문제 의도파악

매수가격
매도 가격
수량
	함수 매개변수 설정

stock() 함수 정의
	함수 호출 후 출력 
	print() 

이미 필요한
수식/관계식을 알려줌
고민할 필요 x 문제



-------------
### ~~코드92~~
```python


```
결과=>


ㅡ 문제 의도 파악

위에서 stocks 함수 정의함
이 함수에 대한 설명을 확인할 수 있는 기능을 가지고 있는 help함수 정의


ㅡ 해설풀이

사용자 정의 함수에 대한 설명을 작성 시
함수 내부에 독스트링으로 작성 가능
확인 가능




-------------
### ~~코드93~~
```python
```
결과=>

ㅡ 문제 의도파악

인수로 문자열 들어감
거꾸로 출력 기능 구현
함수 정의

- 1번 풀이
ㅡ
함수 정의
	문자형 인수를 받는 매개변수
ㅡ
리스트 내장함수 사용 형변환

ㅡ
while 반복문 사용

내부 조건명제
bool 함수 사용
	기능생각
	리스트안에 아무런 값도 없으면 F 출력됨

ㅡ
pop메서드 함수 
	값을 추출하는 기능
	제거하는 기능
	
추출하다가 남는게 없는 순간 
반복문 종료

- 2번 풀이
리스트 자료형 특징 생각
슬라이싱
역순출력
	-1
반복문




-------------
### ~~코드94~~
```python
```
결과=>

ㅡ 문제 의도 파악
	
리스트 타입이 들어가는 매개변수 정의
	
파이썬
랜덤하게 선택 후 출력 기능 
random 모듈 존재
	
random 모듈 임모트
	필요한 함수 임포트
	
쉬워서 바로 풀어도 될듯

ㅡ
random 모듈의 choice() 함수
choice() 함수는 주어진 시퀀스에서 임의의 요소를 선택하여 반환해줍니다.

ㅡ 해설풀이
	
랜덤 모듈안에 다양한 랜덤 기능을 구현하는 함수들 존재
나와 다른 랜덤 함수를 사용함
	randint


-------------

### ~~코드95~~
```python



```
결과=>

ㅡ
주피터 확인
ㅡ
문제 pdf확인




ㅡ
함수 정의
인수가 들어가도록 n 매개변수 사용

ㅡ
전체 n값 사용
출력되는 0개수 조절
	+ i값 사용 
	출력되는 0 개수 조절

ㅡ
반복문 2개를 사용
1번 반복문 상단 작성
2번 반복문 하단 작성




-------------
### ~~코드96~~
```python
```
결과=>
ㅡ 코드 설명
###### 포맷코드
==이 포맷 코드는 숫자를 2자리로 표현==하고, ==만약 숫자가 한 자리라면 앞에 0을 붙여줍니다.==  예를 들어, 숫자 5를 포맷 코드 '{:02d}'로 표현하면 '05'가 됩니다.


ㅡ 문제의도파악
	
사각형을 출력하는 기능을 가지고 있는 함수 정의
	
규칙파악
1번행
	1 2 3 4
2번행
	2 4 6 8
3번행 
	
이해 ㅇ
각행마다 의미 존재
규칙성 존재
	구구단
	배수임

1행은 1단
2행은 2단
3행은 3단
	
ㅡ 질문
파이썬에서는 다양한 포맷코드-기능이 존재
1자리 수 일때는 앞에 0이 같이 출력되고
2자리 수 일때는 0이 없어져야 하는 상황
적절한 포맷코드 큐칙 알려줘
	
파이썬에서 숫자를 포맷팅할 때, 원하는 자릿수에 맞게 0을 채우거나 0을 제거하는 포맷코드를 사용할 수 있습니다.
	
만약 1자리 수일 때 앞에 0을 붙여 출력하고 싶다면, 포맷코드로 '{:02d}'를 사용하면 됩니다. 예를 들어:
기억난다
포맷해서 출력할건데
2자리수로 포맷
남는자리는 0으로 할게
```
number = 9
formatted_number = '{:02d}'.format(number)
print(formatted_number)
```

이렇게 포맷코드를 사용하여 숫자를 원하는 자릿수에 맞게 포맷팅할 수 있습니다. 자릿수에 따라 0을 채우거나 제거하는 포맷코드를 적절히 선택하여 사용하면 됩니다.


ㅡ
이 문제는 바로 풀어본다

4를 입력했을 땐
4단까지 진행

ㅡ 내풀이 과정별 해석

함수 정의
숫자를 인수로 받는 매개변수

구구단 출력하는
파이썬 로직/구조 생각

문제 예시 상황 분석
4를 입력 > 4단이 마지막

9를 입력하면 > 9단 마지막

출력함수
옵션 매개변수 생각

문자열 포맷팅
숫자 포매팅 
포맷코드
생각
	자리수에 해당하는 출력하는 형태 조절 가능


ㅡ 해설풀이
	
나는 포맷코드를 사용해서 
출력하는 포맷을 설정함
	
해설풀이에서는
조건문을 사용해서 출력하는 포맷을 설정함






-------------
### ~~코드97~~
```python
```
결과=>

ㅡ 문제 의도파악
	
딕셔너리 자료형을 인수로 받는 함수 정의
	
딕셔너리 자료형 특징 생각
	순서가 없는 자료형
	하지만 키 값으로 인덱싱 가능
	
딕셔너리 타입 변수에 있는 키 값이라면 키-인덱싱
	
없는 타임일땐
흐름제어
조건문 


ㅡ 번 풀이
처음 생각
딕셔너리 자료형
없는 키값 인덱싱
오류발생
	
따라서 오류를 잡는 로직을 작성
KeyError가 발생




ㅡ 2번 풀이
굳이 오류를 잡는 로직말고
다른풀이도 가능
	
딕셔너리에서 특정 키를 인덱싱하기 전에 해당 키가 딕셔너리에 있는지 확인하는 것이 좋습니다. 이를 위해 in 키워드를 사용하여 키의 존재 여부를 확인할 수 있습니다.
복기
	in 키워드 기능 2가지
		반복문에서
		조건문에서
```
if 'grape' in my_dict:
    print(my_dict['grape'])
else:
    print('해당 키가 딕셔너리에 없습니다.')
```


ㅡ 해설풀이 
키워드 기록
	
딕셔너리 자료형에 반복문 사용
	굳이?
이해 ㅇㅇㅇ
	
바로 키값으로 인덱싱 가능하지만
해설영상에서는
오류처리구문 없이
없는 키를 호출했을 때 흐름을 제어하기 위함
	
ㅡ 해설풀이
for반복문
딕셔너리 자료형 할당 시
키값들이 1개씩 접근 호출됨
	
즉 현재 풀이는
내가 인수로 넣은 값과 딕셔너리 자료형 안에 있는 키 값들으 모두 가져와 1번씩 비교하고 있음
	
모두 한 번씩 비교했을 때 
원하는 결과값 출력 
	
다음 블럭에서 조건문 사용
왜?
같은 블럭 내부에 작성하게 되면 
반복해서 없음을 출력할테니
	
keys 메서드 함수를 사용
키값이 없다면
if코드블럭이 실행되도록 로직 작성 


-------------
### ~~코드98~~
```python


```
결과=>

ㅡ 
BMItest()함수 정의
	키와 몸무게 값을 인수로 받는 매개변수 정의

ㅡ
비만도 계산 수식 이미 알려줌
그대로 사용

ㅡ
조건문을 사용해서
4가지 경우의 수에 따른 다른 출력값이 나오도록 작성


ㅡ 해설풀이
	
원하는 형태로 
문자열을 출력하기 위해
숫자를 출력하기 위해
포맷팅 사용
포맷코드
	숫자와 포맷코드를 함께 사용하면
	정렬기능과...공백기능? 



-------------
### ~~코드99~~
```python

```
결과=>

ㅡ
random.randint(a, b) : a 이상 b 이하의 랜덤한 정수를 반환

ㅡ
my_set = {} 와 같이 작성하면 파이썬은 이를 딕셔너리로 인식
따라서, 빈 집합을 정의하려면 set() 생성자를 사용
	my_set = set()

ㅡ
정렬 메서드를 사용하여 리스트를 정렬
sort() 메서드


- 해설풀이 =>
해설풀이 더 좀 더 좋은 풀이.
왜?
아직 사용하지 않는 값을 메모리/가상공간에 만들어 두는 것 보다 필요할 때 그떄마다 생성해서 사용하는게 좋다
	메모리 관점

ㅡ
랜덤모듈
랜덤함수 사용
어떤값이 나왔는지 출력확인

ㅡ
비어있는 리스트 정의
조건문 사용
	리스트안에 랜덤한 수가 들어있는지 확인 후 추가

ㅡ
while반복문
리스트 안 요소 개수/길이가 7이면 중단

ㅡ
리스트 슬라이싱 이용
마지막 지점을 제외하고
1개씩 접근 후 반환출력


-------------
### ~~코드100~~


