---
{"dg-publish":true,"permalink":"/distribute/python/content-record-folder//","tags":["파이썬"],"noteIcon":""}
---

### 날짜 2023-11-13 14:48


---
# 참고/연관된 기록 =>
위에서 작성한 내용과 연관성이 있는 기록-노트를 연결.
" [[]] "
- 


-------------------------------
- ### 3회독 기록/요약-영구노트 단계 =>
	ㅡ 키워드 및 밑줄들을 내 언어로 문장 요약.
	ㅡ "키워드-참고노트화"에서 생겨난 키워드 기반 기존 노트들과 연결 진행


ㅡ 사진
	![Pasted image 20231113172843.png](/img/user/%EC%B2%A8%EB%B6%80%ED%8C%8C%EC%9D%BC/Pasted%20image%2020231113172843.png)

알고리즘을 풀다 보면 원본배열 보존을 위해 배열 복사할 필요 존재
	> 깊은 복사 진행
	
ex) copy모듈의 deepcopy() , 클래스가 가지고있는 copy() 함수, 리스트 슬라이싱

객체를 복사하는 다양한 방법들 존재
	**얕은 복사(Shallow Copy)** - 원본 객체 주소값을 복사한 상태
	**깊은 복사(Deep Copy)** - 객체 자체를 복사한 상태 - 따라서 다른 주소값


ㅡ 객체 특징 Mutable과 Immutable 존재
	
**mutable 변경 가능한 자료형** 
	메모리 공간 상에서 객체가 생성되면 그 주소/위치에서 값이 변경되도 주소 값이 동일함 = 그 공간에서 값이 변경되는 것
	
**immutable 변경 불가능한 자료형** 
	메모리 공간 상에서 객체가 한번 생성되고 사이즈가 고정된 상태를 생각. 따라서 데이터를 추가하면 새로운 객체가 필요함




-----------------
- ### 2회독 기록/키워드_밑줄-참고노트 단계 =>
	- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
		ㅡ 임시메모에서 생겨난 기록들을 밑줄치면서 요약

- 객체의 특징
	- Mutable - 변경/수정 가능한 자료형
		- 리스트 타입
		- 얕은 복사(Shallow Copy)
			- "원본 객체 주소값만을 복사한 상태"
			- 주소값 같다 = 객체 동일
			-
	- Immutable - 변경/수정 불가능한 자료형
		- int 타입
		- 깊은 복사(Deep Copy) - 원본 배열 보존
			- "원본 객체 자체를 복사한 상태" 
			- 새로운 주소 값 = 새로운 객체
			-
	- copy모듈 - deepcopy()
	- 클래스의 copy() 함수
	- 리스트 슬라이싱




---
- ### 1회 기록/대략적 기록/임시메모 단계 =>



# Metadata
- Author: Crackerjack's IT shack
- Category: article
- URL: https://crackerjacks.tistory.com/14
# Highlights

# ㅡ 파이썬 (Python) - **깊은 복사 (Deep Copy)**
Note: 제목
==알고리즘을 풀다 보면 원본배열의 보존을 위해 배열을 복사할 필요==를 느낄때가 많다.
	
객체를 무작정 복사해서 사용하면 원본 객체가 핸들링되어 데이터가 변경되어서 큰 문제를 야기할 수 있기 때문에 객체를 복사할 때에는 주의해서 다뤄야 한다.
	
==객체를 복사하는 다양한 방법==에 대해 알아보고자 한다.
	
객체를 복사하기 전에 먼저 객체의 특징 중 **Mutable과 Immutable**의 의미에 대해 알 필요가 있다.

### ㅡ Mutable, Immutable 객체
Note: 제목
파이썬에서 변수는 ==자신에게 대입된 객체를 가리키는 일종의 포인터/화살표== 같은 존재
	
> [!NOTE]
> 	=>
> 	값이 직접적으로 들어가 있는 상태가 아니라
	
==파이썬에서 변수는 자체 저장공간을 할당받지 않으며 객체를 가리키는 개념==이다.
	
무슨 말인가?
	
ㅡ C언어에서 변수의 선언을 살펴보자.
##### 코드
```c
int a = 1;
```
위 Integer 자료형 변수 a는 1의 값을 가지며 변수 a와 1은 같은 존재라고 볼 수 있다.

ㅡ 파이썬에서 변수의 선언
##### 코드
```
a = 1
```
파이썬에서는 ==a와 1은 별개의 존재==다.
	
a라는 변수는 ==Integer 1이라는 객체를 가리키고 있을 뿐 a의 변수에 정수 1의 값이 할당 된 것이 아니다.==


ㅡ **Mutable과 Immutable의 개념**은 여기서 적용된다. 
	
Mutable과 Immutable은 글자 그대로, **'변한다'와 '변하지 않는다'** 라는 뜻을 가지고 있다.
	
> [!NOTE]
> Note: 위 내용
> 파이썬에서 변수가 값을 어떻게 가지고 있는지를 제대로 알고 있어야 mutable<>immutable 의미를 제대로 파악 가능

예시를 살펴보자.
##### 코드
[[distribute/Python 파이썬/Content record folder/객체특징-얕은복사-깊은복사-메모리주소-추가내용#코드1\|객체특징-얕은복사-깊은복사-메모리주소-추가내용#코드1]]
	
```
a = 1 
b = a
print(a, b) # 1 1
```
	
a와 b는 동일하게 (정수 1) 이라는 객체를 가리키게 된다.
여기서 b의 값을 2로 바꾸면 어떻게 될까?
```
a = 1 
b = a 
print(a, b) # 1 1 
b = 2 
print(a, b) # 1 2
```
=>
당현한 것처럼 위의 결과가 출력된다.
	
이는 **int의 자료형**이 **Immutable한 특징**을 가졌기 때문
immutable한 객체는 생성이 된 후 값 수정이 불가능하다.
	
Mutable한 객체에는 대표적으로 list가 있다.
	
파이썬에서 다음과 같이 배열을 선언해보고 출력
```
a = [1, 2, 3, 4] 
b = a 
print(a, b) # [1, 2, 3, 4] [1, 2, 3, 4]
```
Note: 코드
위의 방식대로 b의 값을 바꾸면 어떨까?

	a = [1, 2, 3, 4] 
	b = a print(a, b) # [1, 2, 3, 4] [1, 2, 3, 4] 
	b[1] = 0 # 배열 b의 두번째 값을 0으로 바꿔준다. 
	print(a, b) # [1, 0, 3, 4] [1, 0, 3, 4]
Note: 코드
위 결과와는 다르게 원본 배열 a의 두번째 값도 바뀌어 버렸다.
	
이는 ==리스트가 Mutable한 특징==을 가졌기에 값이 바뀔 수 있기 때문에 ==원본배열의 값이 바뀌어 버린 것==이다.
	
> [!NOTE]
> 	Note: 원본배열
> 	원본값
> 	원본객체가 값이 수정됨
	
자세히 설명하자면, 위에서 ==a와 b는 같은 주소값을 참조==한다. 그런데 ==list는 Mutable 하기 때문에 b의 값을 바뀌어 버리면 그 주소값에 있는 값을 바꾸어 버리기 때문에== 같은 주소값을 참조하던 a도 값이 바뀌게 나오게 되는 것
	
##### 코드
	[[distribute/Python 파이썬/Content record folder/객체특징-얕은복사-깊은복사-메모리주소-추가내용#코드2\|객체특징-얕은복사-깊은복사-메모리주소-추가내용#코드2]]
	
위 구문에서 a와 b, c와 d는 각각 동일한 레퍼런스(주소값)를 참조하고 있다.
	
정수의 경우 -5 ~ 256 까지 ==기존 메모리에 생성되어있는 객체를 참조==하기에 이 외의 값은 변수를 생성 할 때 다른 주소값을 참조하므로 정확한 말은 아니니 참고
	
> [!NOTE]
> Note: 자주 사용하는 정수값 5~256은 새로운 객체가 생성되는게 아니라 기존에 이미 생성되어 있는/저장되어 있는 객체를 참조한다
> 	=> 참고자료
> 	ㅡ [[캐싱-caching-용어\|캐싱-caching-용어]]

##### 코드
	[[distribute/Python 파이썬/Content record folder/객체특징-얕은복사-깊은복사-메모리주소-추가내용#코드3\|객체특징-얕은복사-깊은복사-메모리주소-추가내용#코드3]]
	
==Integer형 변수는 Immutable 하므로 값이 바뀔 수 없어 다른 id값==을 가지지만,
	
==list형 변수는 Mutable하므로 값만 바뀌고 여전히 같은 주소값을 참조==한다. 때문에 d의 값을 바꿔도 c의 값이 따라서 바뀌는 것이다.


### ㅡ 참고) Mutable 자료형과 Immutable 자료형
	[[distribute/Python 파이썬/Content record folder/객체특징-얕은복사-깊은복사-메모리주소-추가내용#사진2\|객체특징-얕은복사-깊은복사-메모리주소-추가내용#사진2]]
	
즉
**mutable 변경 가능한 자료형**이란 메모리 공간 상에서 객체가 생성되면 그 주소/위치에서 값이 변경되도 주소 값이 동일함 = 그 공간에서 값이 변경되는 것
	
**immutable 변경 불가능한 자료형**이란 메모리 공간 상에서 객체가 한번 생성되고 사이즈가 고정된 상태를 생각. 따라서 데이터를 추가하면 새로운 객체가 필요함


### ㅡ 얕은 복사(Shallow Copy) 와 깊은 복사(Deep Copy)
		[[distribute/Python 파이썬/Content record folder/객체특징-얕은복사-깊은복사-메모리주소-추가내용#사진1\|객체특징-얕은복사-깊은복사-메모리주소-추가내용#사진1]]
	
**얕은 복사**는 객체를 새로운 객체로 복사하지만 ==원본 객체의 주소값을 복사하는 것==이고,
	
**깊은 복사**는 ==전체 복사로 참조된 객체 자체를 복사하는 것==을 말한다.
	**사진1 확인**

위 예제들에서 리스트들은 모두 얕은 복사를 통해 주소값만 복사되어서 복사된 객체에서 값을 바꾸었던 것이 Mutable한 list의 특성때문에 원본 객체의 값도 바뀐 것을 확인
	
==코딩을 하다보면 원본 배열의 보존을 할 필==요가 허다하기 때문에 ==이럴때는 배열을 '깊은 복사'== 하여야 한다.
	
단순함이 강점인 파이썬에서는 깊은 복사를 위한 여러가지 방법이 존재한다.
Note: 약 2개 정도 알고 있었음
생각보다 더 다양하다


-----
##### ㅡ **copy모듈의 deepcopy() 이용**
	**코드4**
	
가장 많이 쓰이는 방법으로 **파이썬 내장 모듈 copy**를 import 하여 **deepcopy 메소드**를 사용하는 방법
	
**copy 모듈의 copy() 메소드**와의 차이점은 copy() 는 배열의 내부 객체까지 깊은 복사를 해주지 않는 차이점이 있다. (즉, 이중 이상의 배열은 완전한 깊은복사가 이루어지지 않음)

-----
##### ㅡ **클래스가 가지고있는 copy() 함수 이용**
**코드5**

파이썬의 ==기본적인 클래스들이 가지고있는 copy() 함수==를 이용하는 것으로,  ==list 클래스 역시 copy() 함수를 가지고 있다.==


- **list를 생성할 때 매개변수에 원본을 전달, 혹은 생성후 원본 리스트를 확장**
	**코드6**

##### ㅡ **리스트 슬라이싱**
**코드7**

- **배열 요소로의 접근을 통한 복사**
	**코드8**

이렇게 다양한 방법을 통해 ==깊은 복사를 하면 값은 같더라도 기존에 있던 객체와는 완전히 다른 객체를 하나 만들어 낼 수 있다.==
	
리스트 슬라이싱이나 제네릭 copy의 copy() 메소드는 리스트가 오브젝트를 포함할 경우 그 오브젝트들은 얕은복사되는 것만 주의해서 사용하면 된다.
	
어떤 방법을 쓰는게 좋을가? 취향에 따라 쓰면 된다.
	
다만 ==각 방법 별로 처리속도가 다르니 이는 참고==하는게 좋다. ==처리속도는 리스트 슬라이싱이 가장 빠르고 copy 모듈의 deepcopy() 메소드가 가장 느리다==고 한다.
	
다음은 깊은복사 방법 별 처리속도를 정리한 것이니 참고 바라며 포스팅을 마친다.


---
