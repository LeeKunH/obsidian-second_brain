---
{"dg-publish":true,"permalink":"/distribute/it-cs-development-terminology/it-development-terminology-cs-knowledge-brain/","tags":["개발용어_CS지식","목차"],"noteIcon":""}
---

### 날짜 2023-11-06 15:18



----
# <디지털 환경-세계 인프라 아키텍처>


##### - [[디지털인프라-개발직군-직무-역량 이해\|디지털인프라-개발직군-직무-역량 이해]]
- 디지털 인프라
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:#d3f8b6">디지털 인프라 아키텍처 기반 다양한 개발직군 이해-이미지</span>
	- 웹 기술/개발 관련 직군
		- 제품/서비스(만) 기획 직무
		- UI/UX 제품-서비스 기획 직무
			- 웹 디자인 직무
			- 웹 퍼블리셔 직무
				- 실제 개발을 담당하는 직무들 =>
				- 프론트엔드 개발 - 화면에 보이는 로직구현
				- 백엔드 개발 - 안 보이는 서버쪽 로직구현
				- DBA - 데이터베이스 개발
					- 
	- 기획자/디지털 마케터 : 
		- 하나의 서비스를 성공적으로 진행되게 하기 위한 기능명세서/기획안 작성
		- 예시 =>
			- 네이버에서 특정한 서비스/기능을 사용자들에게 제공 
			- 화면을 사용자친화적 >  어떻게 디자인? 어떤 색? 어떻게 배치? 어떤 내용? 
		- 
	- 클라이언트 측:
	    - 운영체제 개발자: 운영체제의 설계와 개발을 담당
	    - 소프트웨어 개발자: 클라이언트 응용 프로그램을 개발
	    - 프론트엔드 개발자: 웹이나 모바일 애플리케이션의 사용자 인터페이스 개발
	    - 
	- 서버 측:
	    - 백엔드 개발자: 서버 사이드 로직, 데이터베이스 관리, 서버와 클라이언트 간의 통신을 담당
		- DBA(Database Administrator) : 데이터베이스의 설계, 구현, 유지보수, 보안 강화 등을 담당하며, 이를 통해 데이터의 안정성과 접근성을 확보
		- 
	- 네트워크 영역:
	    - 시스템 엔지니어/데브옵스: 클라이언트와 서버 간의 원활한 통신과 상호작용을 보장하며, 인프라의 배포, 관리, 운영을 담당
- <span style="background:#d3f8b6">디지털 인프라 기반 다양한 개발역량-이미지</span>
	- app 개발을 위한 UX/UI 이해 = 분석-설계-기획
	- app 개발을 위한 언어 이해
		- app 개발을 위한 프레임워크/라이브러리 이해
	- 개발한 app 유저와 커뮤니케이션 영역 프론트 이해
	- 개발한 app을 서비스화 하기 위한 서버 이해
		- 서버영역에서 비즈니스 흐름 처리/로직 백엔드 이해
	- 데이터를 수집-저장-관리를 위한 데이터베이스 이해
	- 형상관리-빌드-배포자동화-테스트자동화 이해
	- app 개발을 위한 물리/가상 환경/장비 이해


---

# <컴퓨터 시스템>



##### - [[시스템-프로그램-용어이해\|시스템-프로그램-용어이해]]
- 컴퓨터 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- "시스템" 용어
	- 다양한 문맥에서 사용
	- 개별적인 구성 요소들이 서로 상호작용하여 특정한 목표나 기능을 달성하기 위해 함께 작동하는 집합체 의미
	- 따라서 각각의 프로그램, 모듈, 컴포넌트 상호작용을 한다면 시스템! 용어 사용 가능
		- 프로그램 = 코드(파일)덩어리 
			- 모듈 <=> 컴포넌트 용어
				- : '각 컴포넌트는 인터페이스를 통해 상호작용'
				- 특정 기능 담당 독립적인 코드단위/수행 단위
				- 프로그램 일부 
	- ex)
		- DB 시스템(Database System)
			- 데이터베이스 관리 시스템(DBMS)과 데이터베이스로 구성
			- 데이터의 저장, 검색, 관리 등을 효율적으로 수행하기 위해 상호작용
		- 컴퓨터 (시스템) (Computer System)
			- 하드웨어(프로세서, 메모리, 입출력 장치 등)와 소프트웨어(운영 체제, 응용 프로그램 등)가 결합 > 각 하드웨어 구성요소와 소프트웨어가 상호작용하여 컴퓨터가 원활하게 동작
		- 파일 시스템(File System)
			- 파일과 데이터를 효율적으로 저장, 검색, 관리하기 위해 운영 체제에 의해 사용되는 시스템
			- 디스크 내의 데이터를 조직화하고, 파일에 대한 접근 및 관리를 가능하게 하는 여러 구성요소로 이루어져 있습


# ㅡ 1. **컴퓨터 구조** - 큰 개념

##### - [[비트(bit)용어\|비트(bit)용어]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 비트 용어 이해
	- 비트 정의
		- 비트(bit)는 'binary digit'의 줄임말
		- 컴퓨터는 모든 데이터/정보를 이진 형태로 처리하기 때문에, 비트는 컴퓨터가 데이터를 처리하는 기본 단위로 사용
		- 1비트는 **데이터의 크기 단위**이며, 컴퓨터나 기타 디지털 시스템에서 정보를 저장하고 처리하는 가장 작은 단위 > 따라서 "1비트를 처리한다"는 것은 실제로 '데이터 포인트 한 개를 처리한다'는 것과 동일한 의미를 가지며, 이 데이터 포인트는 0 또는 1의 값 중 하나를 가질 수 있음
	- 비트와 데이터 표현 
		- <span style="background:#d3f8b6">비트-스위치-이해-이미지</span>
			- 이미지 설명 =>
			- 4비트 상황 = 스위치가 4개인 상황
			- 스위치/비트 1개 당 표현할 수 있는 경우의 수 2가지.
			- 따라서 현재 4비트인 상황에서 표현할 수 있는 경우의 수/종류는 16개!
			- 
		- 1비트는 두 가지 상태(0 또는 1)를 나타낼 수 있습
		- 이는 하나의 비트가 표현 가능한 데이터의 '개수' 또는 '가능성'을 의미. 
		- 즉, 1비트에 의해 표현될 수 있는 값의 경우의 수/종류는 두 가지.
		- 
	- 메모리와 비트
		- 메모리에서 1비트의 용량은 그 메모리가 저장할 수 있는 정보의 최소 단위를 나타냅
			- 주의 : 1비트는 두 가지 가능한 정보 값을 저장할 수 있는 최소 단위로, 크기가 '2'를 의미하지는 않습
		- 1비트는 0 또는 1, 즉 두 가지의 다른 상태를 나타낼 수 있으므로, 메모리에서 1비트는 두 가지 가능한 상태를 저장할 수 있는 공간을 의미
		- = 1비트는 두 가지 상태를 표현할 수 있는 **용량**을 가진다고 이해
		- 
	- 요약 : 비트는 데이터 최소/기본 크기 단위 (데이터 포인트 1개..) 이지만, 이는 동시에 그 비트로 표현할 수 있는 데이터 값의 '경우의 수' 또한 나타냅. + 메모리 입장에선 1비트는 2가지 값 상태를 표현할 수 있는 용량을 가지고 있음을 의미
	- 
	- <span style="background:#d3f8b6">비트-진법-손풀이-이미지</span>
		- 이미지 설명 =>
		- 10진수로 표현된 512 숫자 존재
		- 특정한 진법으로 표현되어 있는 숫자는 `각 자리 숫자 x 해당 진법의 자리값` 끼리 더하면 해당 값이 나온다.
		- 
		- 이미지 설명 =>
		- 2진수로 표현된 1001 숫자 존재
		- `각 자리 숫자 x 해당 진법의 자리값` 끼리 더하면 1001 이진수 값에 대한 십진수 값을 파악 가능



##### - [[CPU-메모리저장된값-이용과정\|CPU-메모리저장된값-이용과정]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
    - 메모리 계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>



##### - [[저장장치-캐시계층-구조\|저장장치-캐시계층-구조]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- **캐시 메모리** 계층 존재
	- ==캐시 메모리? =>== | [[캐시메모리-성능-작동원리\|캐시메모리-성능-작동원리]]
	- 
	- 현재 대부분의 마이크로프로세서는 여러 레벨의 캐시(L1, L2, 때로는 L3까지)를 내장하고 있음
	- L1, L2, L3 캐시는 각기 독립적인 레벨의 캐시 메모리로 존재
	- 주의
		- 캐시 메모리는 L1, L2, L3과 같은 여러 레벨로 나눌 수 있지만, 반드시 모든 시스템이 이 세 가지 레벨을 모두 갖추고 있는 것은 아닙
		- 오래된 컴퓨터 시스템에서는 L1과 L2 캐시만을 사용할 수도 있고, 고성능 시스템에서는 L1, L2, L3 캐시를 모두 활용하여 데이터 처리 효율을 높일 수 있습
		- 
	- L1 캐시
		- 거의 모든 현대 프로세서에 존재하며, CPU 코어에 매우 가까워서 가장 빠른 액세스 속도를 제공
	- L2 캐시
		- L1보다는 느리고 크지만, 여전히 빠른 데이터 접근을 제공하여 CPU의 성능을 향상
	- L3 캐시
		- 주로 멀티코어 프로세서에서 볼 수 있으며, 여러 코어 사이에 데이터를 공유하는 데 도움을 줍
		- 
	- 
	- 다양한 형태-구조 캐시 메모리 존재 = 캐시 메모리 위치
		- CPU 내부에도 존재할 수 있고, 과거에는 CPU와 RAM 사이에 위치하는 외부 캐시로 구현
		- 현대의 컴퓨터 아키텍처에서는 주로 내부 캐시를 말합
		- 과거 컴퓨터 아키텍처에서는 CPU 외부에 별도의 캐시 메모리를 두는 경우가 더 흔했음 > 하지만 기술의 발전으로, 특히 반도체 제조 공정이 미세화되면서, 캐시 메모리를 CPU 칩 내부에 통합할 수 있게 되었습 > 내부 통합 캐시는 더 짧은 지연 시간과 빠른 접근 속도를 제공하며, CPU의 성능을 대폭 향상
		- 
		- <span style="background:#d3f8b6">계층적 캐시 메모리-이미지</span>
			- 
		- <span style="background:#d3f8b6">멀티코어 프로세서 캐시 메모리-이미지</span>
			- L3코어가 공유되는 형태
			- L1, L2 각각 코어에 존재
		- <span style="background:#d3f8b6">분리형 캐시 메모리-이미지</span>
			- 멀티코어 구조와 비슷하지만, L1 캐시 메모리가 분리된 구조



##### - [[플래시메모리-기반보조기억장치\|플래시메모리-기반보조기억장치]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 1. ==플래시 메모리(Flash Memory) 기반 보조기억장치==
	- ex) SSD(Solid State Drive), USB(Universal Serial Bus)
		- 
	- 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치 > 따라서 비플래시 메모리 즉, hdd와 모양이 많이 다름
		- 
	- 플래시 메모리(Flash Memory)
		- 플래시 메모리는 실제로 존재하는 물리적인 하드웨어 요소(물리적인 저장 매체) 이면서 동시에 그 하드웨어가 데이터를 저장하고 관리하는 '기술' 의미도 포함
		- 플래시 메모리의 핵심 기능은 데이터를 저장하는 것이며, 이러한 저장 기능은 다양한 형태와 용도로 전자 기기에서 구현
			- = 보조기억장치에만 한정되지 않는다는 점을 이해 = 범용성이 높다
			- ex) 휴대폰, 태블릿, USB 드라이브 등에서도 널리 사용
			- 
		- ==플래시 메모리를 이루고 있는 저장 단위/용어== => [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
		- 
	- 특징
		- 플래시 메모리에서는 비플래시-하드디스크와 달리 데이터를 직접 수정하거나 덮어쓰는 것이 불가능
			- = 수정된 새로운 데이터는 항상 새로운 공간에 저장
		- ~ 특징으로 인한 플래시 메모리에서 데이터를 업데이트할 때의 기본적인 동작 프로세스 - 상황예시
			- <span style="background:#d3f8b6">플래시메모리-가비지 컬렉션 과정-이미지</span>
			- 이미지 설명 =>
				- 한 칸 = 한 페이지 가정
				- 새로운 데이터 c 를 저장 = 블록 x 3번 페이지에 저장
				- 1번 페이지에 존재하던 A데이터를 수정을 진행. A > A' 
				- 따라서 1번 페이지에 존재하던 A데이터는 필요없는 값이 되어버림 = Invalid 상태
				- 가비지 컬렉션 진행
					- 1. 기존 x블록에 존재하는 유요한 페이지들만을 새로운 블록으로 복사
					- 2. 기존 x 블록 삭제
				- 
		- 이 과정을 통해 유효하지 않은 페이지는 지워지고, 해당 공간은 새로운 데이터 저장을 위해 다시 사용 가능해집 > 이러한 프로세스-과정은 메모리의 수명을 연장하고, 데이터의 무결성과 안정성을 보장
		- 시스템은 정기적으로 또는 필요할 때 'Invalid' 상태의 페이지를 정리하는 **가비지 컬렉션**을 수행
		- 가비지 컬렉션? =>
			- 유요한 페이지들만 새로운 블록으로 복사한 후 기본 블록을 삭제해 공간을 정리하는 기능/과정
			- 상황예시
				- 워드 문서를 편집하고 저장할 때를 생각
				- 처음 문서를 저장하면 해당 데이터는 플래시 메모리의 특정 페이지에 기록
				- 이후 같은 문서를 수정하고 다시 저장하면, 수정된 새로운 데이터는 새로운 페이지에 저장되고, 원래 페이지에 있던 데이터는 'Invalid' 상태가 됩
				- 즉, 원본 데이터는 여전히 메모리에 남아 있지만, 시스템은 그 데이터를 더 이상 유효한 정보로 인식하지 않습 이렇게 유효하지 않게 된 데이터는 나중에 가비지 컬렉션 과정에서 지워지게 됩
					- 
	- 플래시 메모리 종류
		- 1. NAND (넨드) 플래시 메모리
			- 대용량 저장 장치로 주로 사용 > 따라서 특별한 언급이 없다면 플래시 메모리는 넨드! 를 의미
		- 2. NOR 플래시 메모리


##### - [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==플래시 메모리를 이루고 있는 저장 단위/용어== 
	- <span style="background:#d3f8b6">플래시메모리-저장단위-용어-이미지</span>
	- 셀 (cell)
		- 플래시 메모리에서 데이터를 저장하는 가장 작은 단위
		- 예시를 통한 이해
			- 셀! : 데이터를 저장할 수 있는 공간/집
			- 비트! : 0과 1을 표현할 수 있는 사람 한 명
		- 셀들이 모여 MB, GB, TB 저장 장치가 됨
		- 하나의 셀에 몇 비트를 저장할 수 있는지에 따라서 **종류**가 달라짐 | [[비트(bit)용어\|비트(bit)용어]]
			- ==종류==? | [[플래시메모리-셀-종류-비트\|플래시메모리-셀-종류-비트]]
			- 
	- 데이터 저장단위/크기 단위
		- 1. 셀들이 모여 페이지(page)
			- 다양한 페이지 상태 표현 존재
				- 1. Free 상태
					- 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태
				- 2. Valid 상태
					- 이미 유요한 데이터를 저장하고 있는 상태
				- 3. Invalid 상태
					- 유효하지 않은 데이터(쓰레기 값)을 저장하고 있는 상태
		- 2. 페이지들이 모여 블록(block)
		- 3. 블록들이 모여 플레인(plane)
		- 4. 플레인들이 모여 다이(di)
		- 
	- 플래시 메모리 내부적인 특징
		- 데이터 읽기/쓰기 시 사용하는 기본 단위와 데이터 삭제 시 사용되는 기본 단위가 다르다
		- 읽기/쓰기는 페이지 단위로 이루어짐
		- 삭제는 블록 단위로 이루어짐 = 삭제 시 읽기/쓰기 보다 더 큰 단위로 삭제됨





##### - [[플래시메모리-셀-종류-비트\|플래시메모리-셀-종류-비트]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==종류==
	- 1. 한 셀에 1비트 저장 플래시 메모리 = SLC 타입 = 싱글 레벨 셀
		- 특징/장점
			- 하나의 셀에 1비트-정보 저장 가능 
				- = 하나의 셀로 두 개의 정보 표현 가능
				- EX) 1과 0 표현 가능
			- 1비트 저장으로 인한 빠른 입출력
				- 이해예시 :  하나의 공간/집에 1명만 살고 있으면 빠르게 밖으로 나갈 수 있음.
			- 긴 수명
			- 용량 대비 고가격
				- 이해예시 : 한 집에 혼자서 살고 있음. 따라서 혼자서 월세 내야함
				- 
	- 2. 한 셀에 2비트 저장 플래시 메모리 = MLC 타입 = 멀티 레벨 셀
		- 특징/장점
			- <span style="background:#d3f8b6">MLC타입-비트-이미지</span>
			- 하나의 셀에 2비트-정보 
				- = 하나의 셀로 4가지 정보 표현 가능
			- SLC보다 느린 입출력
				- 이해예시 : 하나의 공간/집에 2명이 살고 있으니 1명이 존재했을 때보다 느리게 나갈 수 있음
			- SLC보다 짧은 수명
				- 이해예시 : 입구에서 충돌이 발생하니까....
			- SLC보다 저렴
			- SLC보다 시중에서 많이 사용
				- SLC보다 저렴 + 더 많이 저장-표현이 가능하기 떄문
					- 
	- 3. 한 셀에 3비트 저장 플래시 메모리 = TLC 타입 = 트리플 레벨 셀
		- 특징/장점
			- 하나의 셀에 4비트-정보
				- = 하나의 셀로 8가지 정보 표현 가능
			- MLC보다 느린 입출력
			- MLC보다 짧은 수명
			- MLC보다 시중에서 많이 사용
				- 
	- 4. 한 셀에 4비트 저장 플래시 메모리 = QLC 타입 = 쿼드 레벨 셀
		- 
	- 종류에 따라서 메모리 **성능**, **가격**, **수명**이 달라짐.
		- <span style="background:#d3f8b6">다양한종류-셀-특징표-이미지</span>
	- 성능? =>
		- 셀 당 비트 수가 증가할수록 즉, SLC에서 QLC로 갈수록, 셀 내에서 데이터를 읽고 쓰는 **과정이 복잡**해집
		- 과정이 복잡? =>
			- 메모리의 읽기 및 쓰기 속도에 직접적인 영향을 미치며, 비트 수가 많을수록 처리 속도가 느려질 수 있습
	- 수명? =>
		- 셀의 수명은 주로 쓰기 **사이클**(데이터를 쓰고 지우는 횟수)에 의해 결정
			- = 셀이 견딜 수 있는 쓰기/삭제 작업의 횟수에 의해 결정되며, 이 횟수가 소진되면 메모리 셀이 더 이상 정상적으로 기능하지 못하게 됩
			- 사이클 횟수가 많다 = 셀이 한번에 처리/저장하는 양이 적다 = 셀이 받는 부하가 적다 = 수명이 길다 = 마모가 적다
			- 
			- "높은 데이터 쓰기 사이클을 지원한다"는 문장 존재
				- = 데이터를 저장하고 삭제하는 과정을 더 많이 견딜 수 있음을 의미
				- = 더 높은 내구성을 가진다는 것을 의미
				- = 메모리 수명이 더 길다는 것을 의미
			- 
		- SLC 메모리가 한 셀에 데이터를 한 비트만 저장 > 그 셀이 받는 부하가 적어 다른 유형의 메모리보다 더 많은 쓰기/삭제 작업을 견딜 수 있음
		- QLC 메모리는 한 셀에 더 많은 데이터를 저장 = 한 셀에 4비트를 저장
			- = 비트 수가 증가 > 표현할 수 있는, 한번에 처리할 수 있는 경우의 수 증가 > 메모리의 셀은 더 높은 수준의 전기적 스트레스와 복잡한 데이터 관리를 경험
			- = 셀 당 처리하는 정보량이 많기 때문에 더 민감하게 반응하여 더 빠른 성능 저하를 가져오고, 따라서 쓰기 사이클이 감소
		- 즉, QLC는 더 많은 데이터를 저장할 수 있지만, 이는 셀이 더 빨리 마모되는 원인이 되어 전체적인 메모리 수명을 단축
		- 
	- 가격? =>
		- 셀 당 비트 수가 증가하면 해당 메모리 셀이 더 많은 데이터를 저장할 수 있으므로, 이론적으로는 저장 용량이 늘어남 > 그렇다면 더 많은 데이터를 저장하면 더 비싸겠군! > X
		- 저장할 수 있는 데이터의 양이 메모리의 단가를 결정하는 유일한 요소는 X
		- 가격 결정에는 여러 요소가 작용
		- EX) 성능측면과 내구성 측면
			- QLC 메모리는 한 셀에 4비트를 저장할 수 있어 용량 대비 비용이 낮지만, 이는 성능과 내구성의 저하를 수반 > 수명이 짧음
			- SLC는 더 빠른 데이터 액세스와 높은 쓰기/지우기 사이클을 제공하기 때문에, 고성능을 요구하는 응용 프로그램에서 선호

##### - [[캐시메모리-성능-작동원리\|캐시메모리-성능-작동원리]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
			- 캐시
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==캐시 메모리? =>==
	- CPU 내부에 존재하는 레지스터보다 용량이 크고, 메모리보다 용량이 작지만 속도는 빠른 SRAM 기반 저장 장치
		- = 따라서 RAM에 존재하는 모든 내용을 미리 저장할 순 없다.
	- 캐시 메모리는 CPU가 실행 후 생성된 결과물 중 자주 사용되는 데이터를 **임시 저장**
	- 임시 저장? =>
		- CPU가 미래에 다시 접근할 가능성이 높은 데이터를 **예측**해 **미리 저장** 후 > 빠르게 제공하여 처리 속도를 향상시키고, 메인 메모리와의 데이터 전송 횟수를 줄이는 역할
		- 예측 > 미리저장? =>
			- 예측이 성공하면 캐시히트(Cache Hit 용어) 발생! 표현 사용
				- <span style="background:#d3f8b6">캐시히트-이미지</span>
					- 이미지 설명 =>
					- 예측이 성공한 상황 > 따라서 메모리까지 접근하지 x 
					- 상황예시
						- 자주 사용하는 값을 클라이언트가 서버에 데이터 요청 > 서버는 매번 응답 = 비효율
						- 웹 서버 자주 사용하는 데이터 클라이언트 측-캐시 저장 후 재요청 시 직접 반환 = 효율적
							- = 빈번하게 접근하는 데이터는 L1 캐시에 저장되어 빠르게 액세스할 수 있으며, 덜 접근하는 데이터는 L2 또는 L3 캐시에 저장됩
						- 자주 사용하는 값? =>
							- 정적 데이터/정적 자원
								- 웹 페이지 이미지
								- 스타일시트, 스크립트 
								- 
			- 예측이 실패하면 캐시 미스(Cache Miss 용어) 발생! 표현 사용
				- <span style="background:#d3f8b6">캐시미스-이미지</span>
			- 이러한 상황에서 사용하는 공식 존재 = 캐시 적중률!
				- 캐시 히트 횟수 / (히트 횟수 + 캐시 미스 횟수)
				- Long Tail 법칙 그래프 존재
				- 
			- 성능을 높인다! = CPU가 사용할 법한 데이터를 잘 예측한다
			- 참조 지역성의 원리 : CPU가 메모리에 접근할 때 주된 **경향성/패턴/규칙**을 바탕으로 만들어진 원리
			- 경향성 존재? =>
				- 1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
				- 2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다 = 공간 지역성
				- 
	- <span style="background:#d3f8b6">캐시메모리 존재이유-이미지</span>
	- CPU가 메모리에 접근하는 시간은 CPU 연산 속도보다 느리다.
	- CPU와 메인 메모리 사이의 데이터 전송 속도 차이/메모리 접근 시간/데이터 처리 속도를 완화하기 위한 방법 중 하나 = 중간에 캐시 메모리를 배치
		- = 이는 **프로세서의 성능**을 결정하는 중요한 요소 중 하나
		- ==프로세서(Processor) 성능? =>== | [[프로세서(Processor)-CPU-성능\|프로세서(Processor)-CPU-성능]]


##### - [[프로세서(Processor)-CPU-성능\|프로세서(Processor)-CPU-성능]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==프로세서(Processor) 성능? =>==
	- 프로세서는 그 프로그램을 실행하는 하드웨어 장치를 의미 
	- = CPU(Central Processing Unit)를 가리키는 용어로 사용
	- 
	- 각 용어는 프로세서 성능 향상의 다양한 이점을 나타내며, 비록 서로 연결되어 있기는 하지만, 각각이 강조하는 부분은 다릅
	- 1. **응답시간 단축:** 
		- 프로세서의 향상된 성능은 컴퓨터가 사용자가 입력한 명령어을 더 빠르게 처리하게 해, 사용자와 시스템 간의 상호작용이 빨라지게 합
		- 
	- 2. **로딩속도 향상:** 
		- 향상된 프로세서는 사용자가 입력한 명령어를 pc가 해석한 이후 작업인 = 메모리와의 데이터 교환을 더욱 빠르게 할 수 있어, 필요한 데이터나 애플리케이션의 로딩 시간이 단축
			- = 메모리와 데이터 교환 속도 = 데이터 처리 속도= 액세스 속도
			- = 사용자가 프로그램이나 파일을 더 빠르게 열 수 있게 합
		- 
	- 3. **서버 부하 감소:** 
		- 서버측 pc 성능 향상 이점.
		- 서버 내 프로그램을 동시에 처리할 수 있는 작업량이 증가
		- = 서버가 더 많은 사용자 요청을 처리할 수 있게 하고, 서비스의 가용성과 신뢰성을 높입


##### - [[컴퓨터구조-이미지\|컴퓨터구조-이미지]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 이미지
	- 전체구조도
	- 시스템버스
	- 시스템버스-cpu-작동예시
	- 메인보드-마더보드(mother board)-시스템보드(system board)
	- 중앙처리장치CPU-이미지
	- 주기억장치-RAM-메인메모리
	- <span style="background:#d3f8b6">보조기억장치-HDD-SSD</span>
	- 아두이노-라즈베리파이-이미지
	- 
- SSD (Solid State Drive)
	- <span style="background:#d3f8b6">SSD내부-이미지</span>
	- 전통적인 하드 드라이브보다 빠른 데이터 액세스 속도를 제공하는 저장 장치로, 여러 핵심 구성 요소를 포함
	- SSD 컨트롤러
		- SSD의 작동을 제어하며, 데이터 읽기/쓰기, 에러 수정, 웨어 레벨링 등의 작업을 관리
	- DRAM (Dynamic Random-Access Memory)
		- 데이터를 일시적으로 저장하여 SSD 컨트롤러가 빠르게 접근할 수 있도록 하는 버퍼 역할
	- 낸드 플래시 메모리 (NAND Flash Memory)
		- SSD에서 데이터를 영구적으로 저장하는 주요 구성 요소

##### - [[CPU-레지스터-작동과정예시\|CPU-레지스터-작동과정예시]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 1~4번 레지스터 작동과정 예시
	- <span style="background:#d3f8b6">1~4번 레지스터 작동과정-이미지</span>
	- 
	- 실행할 프로그램(명령어와 데이터들)이 메모리에서 1000번 ~ 1500번에 저장되어 있음
	- `프로그램 카운터`에 실행될 메모리 처음 위치가 저장됨
		- = 즉 1000번지에 존재하는 값이 필요함
	- (접근해야 하니까...)프로그램 카운터에 있던 주소 값이 `메모리 주소 레지스터`에 해당값이 복사된다 
	- 메모리 주소 레지스터에 저장된 주소위치는 `주소버스`를 통해 메모리로 전달 + 동시에 제어장치에서 생성된 제어신호는 `제어버스`통해 메모리로 전달
	- 메모리가 주소값+명령-제어신호를 받은 후 명령어대로 1000번지에 저장된 값을 CPU쪽으로 `데이터버스`를 통해 보내준다. = `메모리 버퍼 레지스터`에 보내준다. 
	- 위 작업/메모리에서 보내진 값이 `메모리 버퍼 레지스터`에 저장이 되면 동시에 다음작업 수행을 위해 `프로그램 카운터`에 있던 값을 증가시킨다. (순차적인 실행 흐름위해)
	- 메모리 에서 받은 값이 `명령어 레지스터`에 할당된다. 즉 1000번지에 존재하던 값이 해당 레지스터에 할당된다.
	- 순차적인 실행 흐름? =>
		- 순차적인 실행 흐름이 끊기는 경우 존재
			- 1. 인터럽트(Interrupt) 발생 시
				- 인터럽트 용어
					- 1. **인터럽트 과정**: 
						- 이는 CPU가 현재 실행 중인 프로세스나 작업을 일시적으로 중단하고, 더 높은 우선순위를 가진 작업을 처리하고 이 작업이 완료되면, CPU는 원래 수행 중이던 작업으로 돌아가 계속 수행 과정/매커니즘을 의미
						- 이 과정은 시스템의 효율성과 반응성을 향상
							- = 특정한 신호나 사건에 반응하여 시스템의 응답성과 효율성을 높이는 추상화된 용어
							- =  하드웨어 또는 소프트웨어에 의해 발생하는 이벤트에 대응하는 CPU의 작동 방식을 지칭하는 용어
							- =  CPU가 다양한 태스크와 요청 사이에서 멀티태스킹을 수행하는 과정을 묘사하는 용어
							- 
					- 2. **인터럽트 신호**: 
						- 인터럽트는 또한 CPU에게 현재 작업을 중단하라고 알리는 전기적인 신호로도  이해 가능
						- 이 신호는 하드웨어 장치나 소프트웨어 프로그램에서 발생
				- 
			- 2. (일반적인 상황) 프로그램 내 실행 흐름 변경:
				- 이는 프로그래머가 프로그램의 논리에 따라 의도적으로 실행 순서를 변경하는 경우
				- EX) 프로그래밍 언어(고급언어)로 조건문 작성을 통해 실행 순서 변경하는 상황
				- 위 예시 내부과정 이해 =>
					- <span style="background:#d3f8b6">파이썬 예시코드</span>
						- 파이썬 코드는 실행될 때, 파이썬 인터프리터에 의해 내부적으로 CPU가 이해할 수 있는 명령어로 변환되고 있음
						- `a > b`가 참일 경우: (CONDITIONAL JUMP) 저수준 명령어 실행되어 > "a is greater"를 출력하는 코드의 위치로 점프
						- 즉, 내부적으로 이러한 점프가 있기에 프로그램의 실행 흐름을 적절하게 제어가 되고 있던 것
					- 파이썬과 같은 고급 언어로 조건문을 작성할 때 내부적으로는직접 저수준 명령 코드를 작성하지 않지만, 컴파일러나 인터프리터는 그러한 조건문을 저수준의 명령어로 변환
					- 저수준 명령어? =>
						- JUMP, CONDITIONAL JUMP 등이 포함
						- 일반적인 사용자나 개발자는 파이썬과 같은 고급 프로그래밍 언어를 사용할 때, 그 언어의 문법과 코드 표현식을 이해하고 사용할 줄 알면 충분 =  사용자가 저수준의 명령어를 직접 다루지 않아도 됨. 이 모든 저수준 작업은 파이썬 인터프리터에 의해 추상화되어 처리됩
					- 왜? 
						- 파이썬과 같은 고급 프로그래밍 언어로 작성된 코드는 컴퓨터에서 직접 실행될 수 있는 형태가 아님
					- 주의
						- 이 과정에서 실제 메모리 주소가 변경되는 것은 아니고, `프로그램 카운터`가 가리키는 명령어의 위치가 변경되는 것
							- = 조건문 실행 시 이 프로그램 카운터의 값이 변경되어 다음에 실행할 명령어의 위치를 결정


##### - [[다양한종류-레지스터\|다양한종류-레지스터]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==다양한종류-레지스터==
	- : 각각 다른 역할/기능 수행 = 각각 다른 종류 데이터 저장
	- ==1~4번 레지스터 작동과정 예시== | [[CPU-레지스터-작동과정예시\|CPU-레지스터-작동과정예시]]
	- 
	- 1. 프로그램 카운터(Program Counter, PC)
		- CPU가 다음에(미리..) 실행할 명령어/메모리에서 가져올 명령어 주소 저장
			- = 현재 실행 중인 명령어의 주소를 가리키며, 프로그램의 실행 흐름을 관리하는 데 사용
	- 2. 명령어 레지스터(Instruction Register, IR)
		- 현재 실행 중인 명령어를 저장
		- 메모리에 존재하는 명령어들의 주소를 저장 = 제어장치가 해석할 명령어 저장
	- 3. 메모리 주소 레지스터(Memory Address Register, MAR)
		- CPU가 데이터를 저장 OR 사용하던 특정 메모리 위치에 접근할 필요가 있을 때, 그 위치의 주소 정보를 MAR에 저장
		- 메모리 컨트롤러는 이 주소를 사용하여 해당 메모리 위치와 데이터를 교환
		- MAR은 메모리와 CPU 사이의 데이터 통신을 원활하게 하기 위해 필수적인 레지스터
	- 4. 메모리 버퍼 레지스터(Memory Buffer Register, MBR) 또는 메모리 데이터 레지스터(Memory Data Register, MDR
		- 메모리에서 읽은/가져온 데이터나 메모리에 쓸 데이터를 임시로 저장하는 역할
		- 예시상황
			- CPU입장에서 데이터를 보낸다 = 데이터를 쓴다 = 메모리입장에선 데이터를 받는다
				- 반대로, CPU가 데이터를 메모리에 쓸 때, 그 데이터는 먼저 MBR/MDR에 저장된 후, 해당 메모리 주소로 전송됩
			- CPU입장에서 데이터를 받는다 = 데이터를 읽는다 = 메모리입장에서 데이터를 보낸다.
				- CPU가 메모리에서 데이터를 읽을 때, 해당 데이터는 먼저 MBR/MDR에 저장되고, 이후 CPU로 전송됩
	- 5. 상태 레지스터(Status Register) 또는 플래그 레지스터(Flag Register): 
		- 기존기록 확인
	- 6. 범용 레지스터(General Purpose Registers)
		- 프로그램 내에서 다양한 용도로 사용 = 범용 레지스터는 그 활용도가 훨씬 넓고 유연 = 다른 레지스터 기능들 범용적 수행
		- 다양한 용도? =>
			- 데이터 저장, 중간 계산 결과의 보관, 주소 계산, 루프 카운팅 등 
			- 다양한 데이터와 메모리에서 가져올 명령어 주소 값을 임시로 저장 사용
	- 7. 스택 포인터(Stack Pointer, SP)
		- 기존노트 확인 : [[자료구조-용어\|자료구조-용어]]
	- 8. 베이스 레지스터
		- ==유효한 메모리 주소에 접근하기 위한 두 가지 방식== | [[유효한메모리주소-접근방식\|유효한메모리주소-접근방식]]


##### - [[RAM메모리-작동원리-성능\|RAM메모리-작동원리-성능]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==RAM의 기본적인 작동 원리==
	- 데이터 상호작용 순서 =>
	- 1. CPU(연산처리 진행) <> 2. RAM (실행할 대상/프로그램 존재) <> 3. 보조기억장치 (보관할 대상/프로그램 존재)
	- 상황예시
		- 사용자가 컴퓨터에서 'a'라는 프로그램을 실행
		- 운영 체제는 보조기억장치에서 'a' 프로그램을 찾는다
		- 프로그램 'a'는 보조기억장치에서 RAM으로 복사 = 프로그램의 코드와 필요한 데이터가 메모리로 옮겨집 > (프로그램을 종료하면 RAM의 해당 작업 공간은 비워진다)
		- CPU는 RAM에서 'a' 프로그램을 읽어서 명령어를 처리하기 시작
		- 즉,  보조기억장치에 있는 프로그램을 실행할 때, 그 프로그램은 **RAM으로 복사됨** > 이는 실행 중인 프로그램이 빠르게 데이터에 접근하고 처리할 수 있게 해 주며, 보조기억장치에서는 해당 프로그램이 사라지지 않고 그대로 유지
		- RAM으로 복사됨? =>
			- <span style="background:#d3f8b6">RAM용량-성능-이미지</span>
				- : 보조기억 장치는 3개의 프로그램을 가지고 있는 상태. 하지만 RAM은 용량이 작아 1개만 가지고 있을 수 있는 상태 > RAM 용량-사이즈가 커지면 한번에 많은 프로그램을 가지고 있을 수 있는 상태
				- 
			- 따라서 한 번에 여러 프로그램을 실행하거나 무거운 프로그램을 실행하려면 **RAM 용량**이 높아야 한다. (한 번에 여러 프로그램 = 많은 공간)
			- 실행하고 있는 프로그램(명령어+데이터)가 RAM 위에 저장/할당/복사 된 상태
			- RAM 용량? =>
				- RAM의 용량이 크다 = 성능이 좋다


##### - [[RAM-종류\|RAM-종류]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==RAM 램의 종류==
	- 크게 4가지 존재.
	- 
	- 1. DRAM(Dynamic RAM) = 디램
		- 특징/장점/단점
			- 디램이 가진 장점으로 인해 일반적으로 메모리에 많이 사용됨
			- 메모리 셀에 데이터를 저장하기 위해 커패시터와 트랜지스터를 사용
			- 커패시터는 전하를 저장하는 방식. > 시간이 지남에 따라 **누설**되어 그 전하를 잃게 되는 특징 존재 (저장된 데이터가 동적으로 사라짐) > 이 때문에 DRAM은 저장된 정보를 유지하기 위해 주기적으로 새로 고쳐줘야 하는데, 이 과정을 "**리프레시(refresh)**"라고 함
			- 새로 고쳐준다? =>
				- DRAM의 각 셀에는 1비트의 데이터를 저장하기 위해 한 개의 커패시터와 한 개의 트랜지스터가 사용
				- 데이터는 커패시터에 전하의 형태로 저장되며, 전하의 유무로 1과 0을 표현
				- "정보를 고쳐준다"는 말은 커패시터에 전하를 다시 충전하여 데이터를 원래의 상태로 유지시키는 행위를 의미
			- 전하 누설? =>
				- DRAM 특성 상 사용하는 커패시터는 지속적으로 전하를 잃는다. 즉, 전원이 켜져 있는 동안에도 커패시터의 전하 누설로 인해 데이터가 점차 사라지기 때문에, 전원 공급 중이더라도 주기적으로 리프레시(재활성화)가 필요
				- = SRAM과 차이점 : 구조적 차이로 인해 전원 공급 중 데이터가 안정적으로 유지
				- 
	- 2. SRAM(Satic RAM) = 에스램
		- 특징
			- 전원이 공급되는 한 저장된 데이터가 사라지지 않는 RAM
			- DRAM보다 일반적으로 빠른 속도 > DRAM보다 가격이 높다
			- 주로 캐시 메모리에서 사용
			- 
	- Q. DRAM <> SRAM 어떤 것을 사용?
		- <span style="background:rgba(205, 244, 105, 0.55)">D-S-RAM표-이미지</span>
		- DRAM과 SRAM은 각각의 요구상황과 해당 RAM이 가진 특성을 고려하여 선택
		- 1. 비용 효율성 차이
			- DRAM은 SRAM보다 훨씬 비용 효율적
			- = "소비전력이 낮다"는 장기적으로 "비용적으로 효율적이다"같은 의미
			- 왜?
				- SRAM을 구성하는 데는 더 많은 트랜지스터가 필요하며, 이로 인해 SRAM은 같은 양의 데이터를 저장하기 위해 DRAM보다 더 많은 공간을 차지하고 더 비쌉 
				- = 대량의 메모리가 필요한 시스템에서는 DRAM이 훨씬 경제적
				- 
		- 2. 밀도의 차이
			- "밀도가 높다"는 표현은 물리적 공간 대비 데이터를 저장할 수 있는 용량이 크다는 것을 의미하며, "집적도가 높다"는 같은 양의 공간에서 더 많은 데이터를 저장할 수 있다는 것을 의미. 따라서 같은 맥락에서 사용
			- DRAM은 SRAM에 비해 더 높은 데이터 밀도를 제공. > 이는 DRAM이 더 적은 공간을 사용하여 더 많은 데이터를 저장할 수 있음을 의미
				- = 대용량 메모리를 필요로 하는 응용 프로그램에서 DRAM이 선호
				- 
		- 3. 용도의 차이 
			- SRAM은 그의 빠른 접근 속도 덕분에 캐시 메모리 같이 빠른 데이터 접근이 필수적인 상황에 주로 사용 
			- DRAM은 시스템의 주 메모리와 같이 큰 용량이 요구되지만 접근 속도가 SRAM만큼 민감하지 않은 경우에 사용
			- 
	- 3. SDRAM (Synchronous DRAM) - 에스디 
		- = SDR(Single Date Rate) SDRAM 표현 가능
		- 발전된 형태의 DRAM
		- = 클럭 신호화 동기화된 DRAM 표현 가능
		- 
	- 4. DDR SDRAM (Double Data Rate SDRAM)
		- <span style="background:rgba(205, 244, 105, 0.55)">SDR과 DDR 차이점-이미지</span>
		- 의미/특징
			- 최근 가장 대중적으로 사용되는 RAM 종류 중 하나
			- 발전된 형태의 SDRAM = **대역폭**을 넓혀 속도를 빠르게 만든 SDRAM
			- 대역폭이란? =>
				- 데이터를 이동 시 주고 받는 길의 너비  > 너비가 클수록 한번에 주고받을 수 있는 데이터 양이 많다진다 =  속도가 빨라진다
		- DDR2 SDRAM도 존재
			- <span style="background:rgba(205, 244, 105, 0.55)">SDR-DDR2-차이점-이미지</span>
			- DDR SDRAM 의미 생각 > 2의 제곱승으로 성능이 좋아짐
			- EX) 2 > 4 > 8 > 16 ....


##### - [[HDD구성요소\|HDD구성요소]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==HDD-구성요소== => 
- <span style="background:#d3f8b6">HDD구성요소-이미지</span>
	- 플래터(platter)
		- 비 자성체인 비금속 원판 표면에 자성체인 산화 금속 막을 양면에 도장한 것
		- 산화 금속의 막을 논리적으로 나눈(partitioning)뒤 위치를 지정(formatting)하면 정보를 저장할 수 있게 됩
		- 플래터 양면 모두 사용
		- 
		- 플래터에 존재하는 저장 단위 =>
			- 하나의 플래터는 `트랙`과 `섹터`-저장단위를 나눌 수 있음
			- 여러 플래터가 모여 + 같은 트랙들이 모이면 `실린더`! 저장단위로로 나눌 수 있음
			- 
			- <span style="background:#d3f8b6">섹터-트랙-실린더-이미지</span>
			- 트랙, 섹터 (Track, Sector)
				- 하드디스크 기록 단위의 하나로 자기 매체에 늘어선 동심원으로 구획된 하나하나를 트랙이라 부르고 그 트랙들은 다시 섹터로 나뉘게 됩
				- 섹터(sector)와 트랙(track) 단위로 데이터를 저장
				- 섹터의 크기 : 512 바이트 ~ 4096 바이트
				- 하나 이상의 섹터를 묶어 블록(block)이라고 표현하기도 함
			- 실린더(cylinder)
				- 여러 겹의 플래터 상에서 같은 트랙이 위치 한 곳을 모아 연결한 논리적 저장 단위
				- 연속된 정보는 한 실린더에 기록된다.
				- 왜?
					- 복기 - `헤드는 같이 움직인다`
					- 하나의 실린더에 연속된 데이터를 저장하면 헤드를 움직이지 않고 바로 데이터를 읽/쓸 수 있음
					- 
	- 스핀들(Spindle)
		- 플래터가 회전할 수 있도록 모터와 직접 연결된 축
		- 플래터를 일정한 속도로 회전시키는 장치인 모터가 존재 하고, HDD용 모터는 스핀들에 직접 연결이 되어 있음 = "스핀들 모터"
		- RPM 용어 : 분당 회전수
		- 플래터를 축에 단단히 고정을 시킵
		- 스핀들에 여러장의 플래터를 설치할 경우에는 플래터 사이에 지름이 1.25" 두께 1/8" 의 스페이서(Spacer)를 넣어서 함께 고정
		- 
	- 헤드(Head)
		- 플래터 표면에 정보를 저장 또는 삭제를 하는 장치 또한 저장된 정보를 읽는 역할
		- 일반적으로 해더의 수는 플래터의 수의 2배
		- 왜?
			- 플래터는 양면이기 때문에 한장의 플래터는 2개의 면으로 되어 있기 때문에 각면에 하나씩 해서 헤드가 2개가 필요. 즉, 3장의 플래터로 구성된 하드디스크는 6개의 헤드가 필요
			- 
	- 헤드 구동 장치(Actuator)
		- 주의 
			- 헤드 구동 장치(actuator)는 디스크암을 포함하는 더 큰 시스템.
			- 즉, 디스크암은 헤드 구동 장치의 중요한 부분 중 하나이지만, 전체 헤드 구동 장치 시스템을 단순히 '디스크암'이라고 부르는 것은 그 기능과 구성을 완전히 설명하지 않음
			- 헤드 구동 장치는 디스크암을 움직여서 HDD 내부의 읽기/쓰기 헤드가 디스크 표면 위에서 정확한 위치로 이동할 수 있도록 합
			- 
		- 액츄에이터 라고 불리는 장치는 헤드를 움직이는 장치
		- HDD 회로 기판으로 부터 제어신호를 받으면 actuator용 구동장치는 헤드가 부착된 암을 지정한 위치 까지 이동 시킵


##### - [[HDD작동원리-데이터접근과정\|HDD작동원리-데이터접근과정]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==HDD작동원리-데이터접근과정==
	- 하드 디스크의 작동원리
		- 하드디스크의 자성 물질로 덮인 플래터를 회전 시키고, 그 위에 헤드를 접근시켜 플래터 표면 자기 배열을 변경하는 방식으로 데이터를 읽거나 쓴다.
		- = 전자기 기술을 사용해 데이터를 저장
		- 
		- 플래터의 중심에는 플래터를 회전 시키기 위해서 `스핀들 모터`가 있고, 스핀들 모터의 회선속도(RPM)가 높을 수록 더욱 빠르게 데이터를 읽고 쓸 수가 있다. 허나 소음과 진동이 발생하는 단점 발생
		- `헤드`는 실제로 플래터와 접촉을 하고 있는 것이 아니고 표면에 살짝 더있는 상태로 데이터를 읽거나 쓴다. 따라서 하드 디스크가 동작하는 도중에 외부에서 충격이 가해지거나 갑자기 전원이 차단되면 헤드가 플래터의 표면을 긁어서 고장 나기도 합
		- 
	- HDD-데이터 접근 과정
		- 하드 디스크에 저장된 데이터를 읽거나, 저장할 때 보통 **3개의 시간**이 소요됨
			- = 하드 디스크가 저장된 데이터에 접근하는 시간
		- 3개의 시간? =>
			- 1. 탐색시간(seek time)
				- <span style="background:#d3f8b6">탐색시간-이미지</span>
				- 필요한/접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
				- ex) 0번 트랙 존재하던 헤드 > 1번 트랙으로 이동
				- 
			- 2. 회전지연(rotational latency)
				- <span style="background:#d3f8b6">회전지연-이미지</span>
				- 헤드가 있는 곳으로 플래터-섹터를 회전시키는 시간
				- 
			- 3. 전송시간(transfer time)
				- <span style="background:#d3f8b6">전송시간-이미지</span>
				- 헤드와 해당 데이터가 저장된 섹터가 만난 이후 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간
				- 
		- <span style="background:#d3f8b6">Jeff-시스템성능-접근시간표-이미지</span>
			- 이미지 설명 =>
			- Jeff Dean - numbers every programmer should know (모든 프로그래머가 알아야 하는 기본적인 숫자들)
			- ns(나노초) 단위 존재
			- 패킷 : 네트워크 기본 전송 단위
			- 해당 표에 나와있는 시간 단위/HDD 데이터 접근 과정시 발생하는 시간 작아 보이더라도 전체적인 관점/컴퓨터 시스템에서 발생하게 되는 시간들에 비해서 굉장히 큰 시간이라고 표현 가능
			- 
			- CPU와 가까울 수록 빠름
				- = 내부 메모리 접근 시간이 네트워크를 통한 접근 시간보다 훨씬 빠르다
				- = Jeff Dean의 숫자에 따르면 메모리에 데이터를 읽는 데는 일반적으로 몇 십 나노초가 걸리지만, 네트워크를 통해 데이터를 보내는 데는 수십 밀리초가 소요될 수 있음
				- 
			- 상황예시
				- 웹 어플리케이션을 개발할 때 데이터베이스 응답 시간을 최적화하고자 할 때, 이러한 숫자들을 참고하여 로컬 메모리 접근이 네트워크 요청보다 월등히 빠르다는 것을 확인하고  설계-캐싱 전략을 구현
				- 즉,  웹 애플리케이션에서 자주 요청되는 데이터를 로컬 메모리에 캐싱하는 것은 네트워크를 통해 서버로부터 매번 데이터를 가져오는 것보다 훨씬 빠르고 효율적 = 서버의 부하를 줄이고 응답 시간을 단축시켜 사용자 경험을 향상
		- Jeff Dean이 제안한 컴퓨터 시스템의 성능 측정을 위한 기준 숫자 존재 > 소프트웨어를 설계하거나 문제를 해결할 때 참고해야 할 중요한 시스템 연산과 네트워크 지연 시간에 대한 기준점를 제공함
			- = 데이터를 어디에 저장하고 접근하는 것이 효율적인지를 판단하는 데 도움



##### - [[유효한메모리주소-접근방식\|유효한메모리주소-접근방식]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
	    - 레지스터, 캐시
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==유효한 메모리 주소에 접근하기 위한 두 가지 방식== | [[유효한메모리주소-접근방식\|유효한메모리주소-접근방식]]
	- 메모리 주소 접근하는 방식이 존재하는 이유?
		- 메모리에 연속적으로 저장된 데이터에 대해 유연하고 동적으로 접근할 수 있게 하는 것 > 이 방식을 통해 프로그램은 실행 시점에 데이터 구조 내의 특정 요소에 효율적으로-유연하게 접근 가능
			- = 메모리에 접근하는 유연성을 향상시키는 방식
		-  이 방식은 프로그램의 시작점 또는 기준이 되는 주소에 변위(오프셋) 값을 더하거나 빼서 원하는 메모리 위치에 접근. 즉, 레지스터에는 기준이 되는 주소 1개만 저장 > 변위값을 이용해 각각에 접근
		- 모든 주소를 고정하여 저장하는 것보다 메모리를 더 효율적으로 사용
			- = 프로그램을 더 동적으로 만들며, 재사용성과 유지 보수성을 개선
		- 모든 주소를 있는 그대로 저장하는 방식 사용? =>
			- 여러 가지 제약사항과 단점이 발생
			- 모든 주소값을 사전에 알고 있어야 하며, 프로그램이 런타임에 데이터 구조의 크기나 위치가 변경되었을 경우 이를 적절히 처리할 수 없습
				- = 동적으로 접근 X 
				- = 유연성 X 
			- 프로그램이 특정 메모리 주소에 고정되어 있기 때문에, 코드의 재사용성이 떨어지고 유지 보수가 어려워집
			- 프로그램이나 데이터 구조의 확장이 필요할 때, 모든 관련된 주소 참조를 업데이트해야 하는 번거로움
			- 상황예시
				- 배열이나 리스트와 같은 연속된 메모리 구조에서 시작 주소만 알고 있으면, 그 시작 주소에 인덱스와 데이터 타입의 크기를 곱한 값을 더해 각 원소에 접근 가능
				- 이렇게 하면, 데이터 구조의 크기가 변경되거나 다른 메모리 위치로 이동해도 동일한 접근 방식을 유지할 수 있습
				- 
	- <span style="background:#d3f8b6">메모리주소-접근방식-이미지</span>
		- : 어떤 방식을 사용하는지에 따라 어떤 레지스터가 사용될지 달라짐
		- 
	- : 두 방식은 모두 메모리 주소를 동적으로 계산하는 방법이지만, 사용되는 기준점이 다릅
	- 변위 주소 지정은 특정 베이스 주소로부터의 오프셋을 이용하는 반면, 상대 주소 지정은 현재 코드의 위치나 명령어의 위치를 기준으로 한 오프셋을 사용
	- 
	- 1. 변위 주소 지정 방식(Displacement-Addressing)
		- <span style="background:rgba(205, 244, 105, 0.55)">베이스레지스터-동작과정-이미지</span>
			- ex) 50일 경우 > 기준/처음 위치에서 얼만큼 떨어져서...
		- 베이스 주소(또는 시작 주소)에 변위(또는 오프셋) 값을 더해 최종 주소를 계산
		- 상황예시
			- 배열이나 구조체에서 특정 요소에 접근할 때, 배열의 시작 주소가 베이스 주소가 되고, 배열 내에서의 요소 위치가 변위 값이 됩
			- 
		- 베이스 레지스터는 프로그램 실행 중 사용되는 데이터나 명령어의 주소를 기준으로 삼아 다른 메모리 접근을 용이하게 하는 데 사용
			- = 베이스 레지스터에 저장된 주소를 기반으로 하여, 인덱스 레지스터의 값(배열의 인덱스 등)과 변위값을 더해 최종적인 유효한 메모리 주소를 계산
			- = 현재 코드의 위치를 기준으로 다른 코드 또는 데이터의 위치를 찾는 방식
			- = 베이스 레지스터 값은 기준 역할 수행 (실제 메모리에서 프로그램 시작점/기준점 물리주소 존재)
			- 변위? =>
				- 주어진 기준점(베이스 레지스터의 값)으로부터 얼마나 떨어진 위치인지를 나타내는 값
				- 
	- 2. 상대 주소 지정 방식(Relative Addressing)
		- <span style="background:rgba(205, 244, 105, 0.55)">
		상대주소 지정방식-이미지</span>
			- 
		- 상대 주소 지정 방식에서는 현재 주소나 실행 중인 명령어의 주소를 기준으로 하여 메모리 주소를 계산
		- 상황예시
			- `프로그램 카운터(PC)`가 현재 실행 중인 명령어의 주소를 가리킬 때, 상대 주소는 이 PC 값을 기준으로 하여 다음에 실행할 명령어의 위치를 결정
			- 프로그램 카운터 레지스터 기존기록 복기!


##### - [[CPU-근첩순서-메모리계층-접근속도\|CPU-근첩순서-메모리계층-접근속도]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
    - 메모리 계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:rgba(205, 244, 105, 0.55)">메모리계층-이미지</span>
	- 1. 레지스터 (Registers)
	- 2. 캐시 메모리 (Cache Memory)
		- L1 캐시: CPU 내부, 가장 빠른 접근.
		- L2 캐시: CPU에 가까움, L1보다 느린 접근.
		- L3 캐시: CPU에 가까우나 L1, L2보다 느리고 더 큰 용량.
	- 3. 메인 메모리 (Main Memory or RAM)
	- 4. 보조 메모리 (Secondary Storage)


##### - [[제어장치-제어신호\|제어장치-제어신호]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==제어장치== 
	- <span style="background:#d3f8b6">제어장치-신호발생-이미지</span>
	- : 제어신호 발생 > 각 부품들에게 전기적인 제어신호를 보내는 기능 + 명령어를 해석하는 기능
	- 
	- 컴퓨터 부품들을 동작시키기 위해선 크게 2가지 신호를 생성.
		- 1. ~ 위해 ~ 데이터가 필요하니 메모리 "읽기 신호" 보낸다!
			- 데이터 필요하다 = 접근하다 = 읽는다 = 사용하다
		- 2. ~위해 ~ 데이터가 저장되어 있어야 하니 메모리에 "쓰기 신호"를 보낸다!
			- 데이터를 저장하다 = 메모리에 쓴다 = 적재한다 = 위에 올린다 = 할당한다
			- 
	- 컴퓨터 부품들을 동작시키기 위해 크게 2가지 방향으로 신호를 보낸다.
		- 1. CPU 내부쪽으로 전달되는 제어신호
			- 1. 레지스터 전달
			- 2. ALU 전달
		- 2. CPU 외부쪽으로 전달되는 제어신호
			- 1. 메모리 전달
			- 2. 입출력장치 전달
				- 동작을 지시하는 제어 신호
				- 
	- 신호를 받는다.
		- 1. 명령어 레지스터에서 해석할 명령어를 받아들임
			- 명령어를 받아들이고 해석해야 기능수행/연산에 필요한 값들에 대한 제어신호를 발생 > 보낼 수 있음
		- 2. 플래그 레지스터에서 플래그 값을 받아들임
		- 3. 제어신호를 받아들임
			- 제어장치가 주로 제어 신호를 발생시키는 주체지만, 다른 구성 요소들도 특정 상황에서는 제어 신호/상태 신호를 발생시킬 수 있음.
			- 상황예시
				- 메모리가 데이터 읽기/쓰기 작업을 완료했을 때 완료 신호를 CPU에 보내거나, I/O 장치가 데이터 전송 준비가 되었음을 알리는 신호를 보낼 수 있음
		- 4. 클럭 신호 존재 
			- 클럭신호? =>
			- <span style="background:#d3f8b6">클럭-이미지</span>
			- 이해를 위한 상황예시
				- 클럭 신호를 학교의 종소리에 비유
				- 학교에서 종이 울리면, 모든 학생과 선생님이 무엇을 해야 하는지 알게 됩 > 수업 시작이다! 공부시작 , 쉬는 시간이다! 공부 마무리! 
				- 즉, 종소리는 '지금 이 시간에 해야 할 일'을 모두에게 알려주는 신호
				- 
			- 클럭 신호는 CPU 내부의 모든 부품에 '지금 이 순간 무엇을 시작하거나 끝내야 하는지'를 알려줍 > 즉 클럭 신호는 컴퓨터 내의 각 부품이 작업을 언제 시작하고 마무리해야 하는지를 알려주는 타이밍 신호
			- EX)
				- 클럭 신호가 한 번 발생할 때마다 CPU 내의 부품들은 다음 단계의 작업을 시작! OR 현재 단계의 작업 마무리!
				- 
			- 클럭 신호 존재 이유
				- 클럭 신호가 존재해야 각 부품이 동기화되어 함께 작동하면서 컴퓨터는 명령을 처리하고, 프로그램을 실행됨.
				- CPU 내의 모든 구성 요소들이 정확히 동기화되어 함께 작동해야 컴퓨터는 효율적으로 데이터를 처리하고 명령을 실행 가능
					- = 클럭 신호 없이는 컴퓨터의 다양한 부품들이 서로 조화롭게 작동하기 어려움. 즉, 작업을 시작하는 타이밍이 모두 일치해야 효율적





##### - [[ALU-산술논리장치-플래그레지스터\|ALU-산술논리장치-플래그레지스터]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==ALU-산술 논리 장치==
	- : 계산기와 같은 연산 기능 수행
	- 
	- <span style="background:#d3f8b6">ALU 받아들이는 정보-이미지</span>
	- 레지스터로부터 피연산자 값을 받아들이고 제어장치로부터 제어신호를 받아들임
	- 상황예시
		- 연산을 수행하기 위해선 연산자!와 피연산자! 값 필요 (데이터와 명령어 필요)
		- 1 + 2 연산 수행 상황
			- 1 피연산자, 2 피연산자, + 연산자
		- 
	- ALU 내보내는 정보
		- ALU는 연산의 결과를 내보낼 때, 그 결과에 대한 추가적인 정보를 제공하는 플래그 값을 플래그 레지스터에 전달
		- 플래크 (flag)? =>
			- 연산결과에 대한 부가정보/연산결과의 특정 특성을 나타내는 비트로 구성
			- 컴퓨터가 다음 연산을 어떻게 처리할지 결정하는 데 중요한 정보
				- = 플래그 레지스터의 정보가 CPU 결과 값의 해석에 핵심적인 역할을 하며, 특히 부호 플래그는 결과가 양수인지 음수인지를 나타냅
			- 중요한 정보, 핵심적인 역할? =>
				- <span style="background:#d3f8b6">플래그 레지스터 내부-이미지</span>
					- EX) 플래그 레지스터 내부-부호플로그에 1이 존재 > 해당 값은 음수!
				- 컴퓨터는 모든 데이터를 이진수 형태로 처리 함. 하지만 이진수 형태의 데이터만으로는 값의 부호를 직접적으로 알 수 X =  이진수 자체는 부호 정보를 내포하고 있지 X 
					- EX) 0101(2) 해당 이진수 값은 +5? -5?
				- 예를 들어, 연산 결과의 부호(양수 또는 음수), 제로(결과가 0인지 여부), 오버플로우(연산 결과가 처리 가능 범위를 초과했는지 여부) 등을 나타냅
			- 플래그(값) 종류 다양
				- <span style="background:#d3f8b6">다양한 플래그 값 표-이미지</span>
					- 부호 플래그
					- 제로 플래그
					- 캐리 플래그
					- 오버플로우 플래그
					- 인터럽트 플래그
					- 슈퍼바이저 플래그


##### - [[자료구조-용어\|자료구조-용어]]
- 1. **컴퓨터 구조** - 큰 개념
    - 메모리 계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 자료구조(Data Structure) 용어
	- : 데이터를 메모리에 어떻게 효율적으로 저장하고 접근할지를 방법을 정의한 개념 > 따라서 프로그래밍 시 적절한 자료구조를 활용해 메모리 내 데이터를 최적화해서 저장-관리해야함
		- = 프로그래밍 시 데이터를 관리하는 방식을 결정
	- 주의
		- 메모리 내 특정 '영역'이 사전에 자료구조 유형별로 지정되어 있는게 X 
			- = 미리 메모리 내 스택영역, 큐 영역, 배열 영역 등등 존재하는 상태가 X 
		- 프로그램 내에서 데이터를 저장하기 위해 특정 자료구조를 사용할 결정을 하면, 그 자료구조는 실행 시 메모리 내에 생성되고, 필요에 따라 확장
			- = 자료구조를 사용하겠다는 코드가 작성되고 실행될 때, 그때 해당 자료구조에 대한 메모리 공간이 동적으로 할당되는 것
			- = 자료구조는 실행 시간에 메모리에 할당
		- 예시
			- 자바에서 `Stack<Integer> stack = new Stack<>();` 코드를 사용하여 스택을 생성하면, 이 코드가 실행될 때 메모리 내에서 스택을 위한 공간이 할당됨
			- 자바에서 `List<Integer> list = new ArrayList<>();`를 실행하면, 리스트를 위한 초기 메모리 할당이 이루어짐
			- 
	- 스택(Stack) 자료구조
		- <span style="background:#d3f8b6">메모리-스택자료구조-이미지</span>
		- 스택 주소 지정 방식=스택 자료구조 방식
		- 특징/의미
			- 후입선출(Last In, First Out; LIFO) 방식으로 데이터를 관리 = 이는 마지막에 들어온 데이터가 가장 먼저 나가는 방식
			- '스택'은 데이터를 저장하는 추상적인 개념이자 방법론/규칙이며, 이 개념은 실제 물리적 메모리 내에 구현됨. 
				- = 실제 메모리 내에는 이 규칙에 따라 데이터가 저장되고 관리되는 구체적인 영역이 존재
				- = 스택은 메모리 내에서 연속적인 공간을 차지
		- 스택 자료구조는 스택 포인터 (레지스터 )(Stack Pointer) 필요
			- <span style="background:#d3f8b6">스택포인터-동작원리-이미지</span>
		- 상황예시
			- 함수 호출, 괄호 매칭 등 다양한 프로그래밍 상황에서 활용
				- 이는 스택의 최상단을 가리키는 레지스터로, 현재 스택의 꼭대기를 나타냅. 즉, 스택에서 가장 최근에 저장된 데이터의 메모리 주소를 가리킵
				- 상황예시
					- 어떤 함수가 호출되면, 해당 함수의 실행에 필요한 매개변수, 반환 주소, 지역 변수 등이 스택에 저장
						- 1. 함수의 매개변수 저장
							- 함수를 호출할 때 전달되는 매개변수 값이 스택 메모리에 저장
						- 2. 반환 주소 저장
							- : 현재 함수가 끝나고 제어가 반환될 위치, 즉 호출한 함수로 돌아가기 위한 주소가 스택에 저장
						- 3. 지역 변수
							- : 함수 내에서 선언된 지역 변수들이 스택 메모리에 할당
					- 이 모든 정보들은 함수가 호출될 때 스택의 상단에 순차적으로 쌓이며, 함수가 종료될 때 이들은 스택에서 제거되어 메모리가 반환
					- 이때 스택 포인터는 스택의 최상단을 가리키게 되며, 데이터가 스택에 추가될 때마다 위로 이동하고, 데이터가 제거될 때마다 아래로 이동합
					- 
	- 큐(Queue) 자료구조 
		- 선입선출(First In, First Out; FIFO) 방식으로 데이터를 관리 = 첫 번째로 들어온 데이터가 가장 먼저 나가는 방식
		- 버퍼, 대기열 관리 등에 사용
	- 배열(Array)
	- 리스트(List)
	- 해시테이블(Hash Table)


-----
# ㅡ 2. **운영 체제** - 큰 개념


##### - [[운영체제-OS-메모리관리\|운영체제-OS-메모리관리]]
- 2. **운영 체제** - 큰 개념
    - 운영 체제의 역할과 기능
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:#d3f8b6">운영체제-이미지</span>
- <span style="background:#d3f8b6">OS-메모리관리-메모리내부구조-메모리공간-이미지</span>
	- 연관노트 : [[커널영역-사용자영역\|커널영역-사용자영역]]



##### - [[운영체제-파일데이터-저장-할당방법\|운영체제-파일데이터-저장-할당방법]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
-  ==파일 할당 방법==
- 운영체제는 파일/디렉토리를 **블록 단위**로 읽고 쓴다 = 블록 단위로 관리! 
	- 연관노트 : [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
	- 주의 : 
		- 플래시 메모리와 운영체제가 데이터를 저장하는 단위에 차이 존재
		- 운영체제 : 대부분의 파일 시스템은 '**블록**' 단위로 데이터를 저장
		- 블록? =>
			- 운영체제의 블록은 일반적으로 하드 드라이브 또는 SSD 상의 연속된 데이터 덩어리로, 파일이나 데이터의 논리적 조각을 추상화한 것
			- ex) 파일 크기 작다 = 적은 수의 블록 차지하면서 저장
	- 상황예시
		- 파일 시스템에서 하나의 파일을 저장할 때, 운영체제는 파일의 크기에 따라 하나 이상의 블록을 할당
		- 파일이 블록 크기보다 작더라도 최소한 하나의 블록을 차지 > 디스크 공간의 일부가 낭비될 수 있음을 의미합(이를 '**슬랙 스페이스**'라고 합). 
		- 파일이 여러 블록에 걸쳐있을 경우, 각 블록의 위치는 파일 시스템의 **디렉토리 엔트리**에 저장되어 있어, 파일을 읽을 때 필요한 모든 블록을 찾을 수 있습
		- 
		- 슬랙 스페이스 <> 외부 단편화 의미 차이 =>
			- 두 용어는 저장 공간 관련 문제를 설명하지만, 발생 원인과 처리 방식이 다릅
			- 요약 : 슬랙 스페이스는 **단일 파일 내부의 낭비**를, 외부 단편화는 **전체 저장 공간의 비효율적 활용**을 각각 나타내는 용어
			- 
			- 1. 슬랙 스페이스(Slack Space)
				- 하나의 파일이 할당받은 블록 내에서 사용되지 않는 공간을 의미 = 내부적으로 발생하는 공간 낭비
				- 파일이 할당받은 블록의 크기와 실제 파일 크기 사이의 차이 때문에 발생
				- 상황예시
					- 하나 블록 = 4KB 가정
					- 7KB의 문서 파일을 저장하기 위해 파일 시스템이 8KB를 할당 > 이때 남는/사용하지 않는 1KB는 슬랙 스페이스
			
			- 2. 외부 단편화(External Fragmentation)
				- 파일 시스템 전체에서 작은 자유 공간 덩어리들이 흩어져 있어서, 큰 파일을 저장하기 위한 충분하고 연속된 공간을 확보하기 어려운 상황 = 외부적으로 발생하는 공간의 낭비
				- 상황예시
					- 여러 번의 파일 저장과 삭제 후, 디스크에 3KB, 2KB, 5KB 크기의 여러 자유 공간 조각이 생긴 상황 > 10KB 크기의 새 파일을 저장하려 하지만, 이 크기의 연속된 공간이 없어 저장할 수 없습
					- 
- 파일을 (보조기억장치)블록에 할당하는/저장하는 다양한 방법 존재 =>
	- 1. 연속 할당
		- <span style="background:#d3f8b6">블록저장-연속할당-이미지</span>
		- 가장 단순한 방법
		- 이름 그대로 보조기억장치 내 연속적인  블록에 파일 할당
		- 해당 방식으로, 연속된 파일에 접근하기 위해선 디렉토리 엔트리에는 파일이름 / 첫 번째 블록 주소 / 블록 단위 길이 3가지가 명시
		- 
		- 단점
			- <span style="background:#d3f8b6">블록저장-연속할당-단점-외부단편화-이미지</span>
			- 구현 자체는 단순하지만 **외부 단편화**를 야기할 수 있음
			- 똑같은 사이즈를 가진 파일이 생성되기 전까진 중간에 비어있는 공간이 생길 수 있음 > 이러한 단점을 극복한 방식이 바로 `불연속 할당 방식`
		- 
	- 2. 불연속 할당 (주된 방식)
		- 1. 연결 할당
			- <span style="background:#d3f8b6">불연속할당-연결할당-이미지</span>
			- 디렉토리 엔트리에 저장되는 값
				- 파일 이름 / 첫 번째 블록 주소 / 길이 OR 마지막 블록 주소
			- 각 블록의 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당/저장됨 > 따라서 파일이 여러 블록에 흩어져 저장되어도 상관 X 
			- 파일을 이루는 데이터 블록은 연결 리스트로 관리
			- 단점
				- 반드시 첫 번째 블록부터 하나씩 읽어들어야 함 = 파일 임의 위치에 접근하는 속도가 느리다.
				- 오류 발생 시 해당 블록 이후 블록 접근이 어려움
				- 이러한 단점을 보완한 방식 > `색인 할당`
			- 
		- 2. 색인 할당
			- <span style="background:#d3f8b6">불연속할당-색인할당-이미지</span>
			- 파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 모아 관리하는 방식 > 파일 내 임의 위치에 접근하기 용이해짐
				- =  색인 블록에는 파일 데이터가 저장되는게 아닌 파일 데이터를 가지고 있는 블록들의 주소가 담겨져 있는 느낌
			- 디렉토리 엔트리에 저장되는 값
				- 파일 이름 값 / 색인 블록 값 저장



##### - [[리눅스-윈도우-기본파일시스템\|리눅스-윈도우-기본파일시스템]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==리눅스-윈도우-기본파일시스템==
	- 리눅스 운영체제 파일 시스템 =>
		- 리눅스 운영체제는 유닉스를 기반으로 개발되었기 때문에 유닉스 파일 시스템의 개념을 많이 차용
			- =  리눅스 파일 시스템에서도 i-node(inode) 방식을 사용하여 파일과 디렉터리의 메타데이터를 저장
			- = 리눅스에서는 이 **i-node 구조**를 기반으로 여러 파일 시스템을 구현
			- 
			- i-node(inode) 방식? =>
				- I-node는 유닉스 및 유닉스 계열 시스템(리눅스 포함)에서 파일의 메타데이터를 저장하는 데이터 구조
				- 이 메타데이터에는 파일의 권한, 소유자 정보, 파일 크기, 생성 및 수정 날짜, 데이터가 저장된 블록의 위치 정보 등이 포함
				- 주의
					- I-node 자체는 파일의 실제 데이터를 저장하지 않고, 데이터가 저장된 위치를 가리키는 역할
			- 
		- 리눅스 운영체제 명령어
			- `ls -i` 명령어
				- 파일의 i-node 번호를 표시하여 해당 파일의 메타데이터가 저장된 i-node를 확인
			- `df -T` 명령어
				- 파일 시스템의 세부 정보 확인 가능 
				- 마운트된 파일 시스템의 종류와 사용 중인 파티션의 정보를 볼 수 있습
				- 
		- Ext4는 일반 데이터 저장용으로 사용
			- Ext2, Ext3, Ext4 등
			- 리눅스 배포판을 설치할 때 기본적으로 **Ext4 파일 시스템**을 사용하도록 설정되어 있음
		- FAT32는 다양한 운영체제 간의 호환성이 필요한 외장 하드 드라이브에 주로 사용
		- Btrfs는 스냅샷이나 데이터 복구 기능이 필요할 때 사용
		- XFS는 높은 성능과 대용량 파일 처리에 적합하여 대규모 데이터 저장소나 서버 환경에서 유리
						- 
	- 윈도우 운영체제 파일 시스템 =>
		- **NTFS**: 보안, 파일 압축, 대형 파일 및 볼륨 지원 등의 기능을 제공
			- 대부분의 윈도우 시스템은 **NTFS**로 설치됩
		- **FAT32**:  광범위한 호환성을 제공하지만, 파일 크기와 볼륨 크기에 제한이 있어, 작은 데이터를 저장하는 이동식 드라이브에 주로 사용
		- **exFAT**:  FAT32의 제한을 넘어서며, 큰 파일과 볼륨을 지원
		- 
	- 하나의 컴퓨터에서 여러 개 파일 시스템을 사용 가능
		- = 운영체제는 하나의 파일 시스템 프로그램을 사용한다기보다는, 다양한 파일 시스템을 지원 (다양한 프로그램과 기능을 포함)
		- = 저장할 데이터의 종류-유형, 필요에 따라 선택할 수 있는 옵션을 제공
		- = 파일 시스템들은 각각 데이터를 저장하고 관리하는 최적의 방법을 제공하기 위해 설계
		- 
		- 윈도우 운영체제에서 사용 중인 파일 시스템을 확인하고, 다른 파일 시스템으로 변경하는 방법
			- 1. 파일 시스템 확인 방법
				- 시작 메뉴에서 파일 탐색기 > 내 PC 클릭
				- 사용 중인 파일 시스템을 확인하고 싶은 드라이브를 마우스 오른쪽 버튼으로 클릭한 후 '속성'을 선택
				- 드라이브 속성 창의 '일반' 탭에서 파일 시스템 유형이 표시됩 (예: NTFS, FAT32).
			- 2. 파일 시스템 변경 방법
				- 파일 시스템을 변경하기 위해서는 해당 드라이브를 포맷해야 합
				- 주의: 포맷 과정에서 드라이브의 모든 데이터가 삭제되므로, 중요한 데이터는 반드시 다른 곳에 백업
			- 
		- **Q.** 다양한 파일 시스템이 존재? 사용자는 매번 선택해야됨?  
			- 드라이브를 처음 포맷할 때 파일 시스템을 선택하면 그 이후로는 해당 드라이브에 데이터를 저장할 때 자동으로 선택한 파일 시스템을 사용하게 됩 > 따라서 인터넷에서 자료를 다운로드하여 컴퓨터에 저장할 때, 사용자가 어떤 파일 시스템을 사용할지 선택할 필요는 없습
			- 즉, 컴퓨터의 주 하드 드라이브는 처음 컴퓨터를 설정할 때 NTFS로 포맷-설정 시 이후에 인터넷에서 어떤 파일을 다운로드하든, 그 파일은 자동으로 이 NTFS 파일 시스템을 사용하는 드라이브에 저장되고 있음
			- 
			- 컴퓨터나 다른 디지털 장치에서는 기본적으로 선택되어 설치되는 파일 시스템이 있고, **특정한 사용 상황**이나 요구에 따라 다른 파일 시스템으로 변경하여 사용할 수 있습
				- = 대부분의 경우, 운영체제 설치 시 기본 파일 시스템이 설정됩
			- 특정한 사용 상황? =>
				- 큰 파일을 저장해야 하거나, 특정 타입의 데이터 보호 기능이 필요한 경우, 보다 적합한 파일 시스템을 선택할 수 있습



##### - [[운영체제기능-이중모드-매커니즘\|운영체제기능-이중모드-매커니즘]]
- 2. **운영 체제** - 큰 개념
    - 운영 체제의 역할과 기능
	    - 시스템 호출
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==이중모드== | [[운영체제기능-이중모드-매커니즘\|운영체제기능-이중모드-매커니즘]]
	- <span style="background:#d3f8b6">CPU-커널-사용자모드-이미지</span>
		- 이미지 요약 =>
		- 복기 : `CPU 연산작업 = 명령어를 해석 > 실행 > 출력하는 것`
		- CPU의 이중모드는 '사용자 모드'와 '커널 모드'로 구분되며, 각 모드에서 CPU가 해석 > 실행할 수 있는 명령어와 자원 접근 권한이 다름
		- 
	- 복기 : [[운영체제-OS-메모리관리#- OS-메모리관리-메모리내부구조-메모리공간-이미지\|운영체제-OS-메모리관리#- OS-메모리관리-메모리내부구조-메모리공간-이미지]]
		- 컴퓨터 메모리는 크게 **커널 영역과 사용자 영역** 2가지로 구분 | [[커널영역-사용자영역\|커널영역-사용자영역]]
	- 메모리 상에 각 영역이 존재한다는 의미는 결국 각 영역에 존재하는 코드를 CPU가 해석하고 실행하는 두 가지 모드 존재한다는 것
		- = 메모리 영역의 구분과 비슷하게 CPU는 운영체제의 보안과 안정성을 유지하기 위해 서로 다른 수준의 접근 권한을 가지고 코드를 해석 > 실행함
		- 
		- 1. 사용자 영역 > 사용자 모드로 코드 해석 > 실행
			- 해당 모드에서는 제한된 권한으로 실행
			- = 자원 접근 불가
			- 커널 영역의 코드를 실행할 수 없는 모드
			- 
		- 2. 커널 영역 > 커널 모드로 코드 해석 > 실행
			- 운영체제의 서비스를 제공받을 수 있는 실행모드
			- 자원 접근을 비롯한 모든 명령어 실행 가능.
			- CPU가 모든 하드웨어 자원과 메모리에 접근할 수 있는 권한을 가짐 
			- 권한을 가짐 = 하드웨어 자원과 메모리 접근에 대한 코드를 해석 > 실행 가능
			- 
	- ==시스템콜과 CPU 이중모드 전환 과정 =>== | [[시스템콜-CPU이중모드-과정\|시스템콜-CPU이중모드-과정]]


##### - [[시스템콜-CPU이중모드-과정\|시스템콜-CPU이중모드-과정]]
- 2. **운영 체제** - 큰 개념
    - 운영 체제의 역할과 기능
	    - 시스템 호출
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==시스템콜과 CPU 이중모드 전환 과정 =>==
	- 상황예시1
		- <span style="background:#d3f8b6">시스템콜-이중모드-전환과정-이미지</span>
			- 이미지 설명 =>
			- 현재 이미지 상황이 바로 인터럽트! 상황
			- 따라서 사실상 운영체제 코드를 실행하고 복귀하고 이런 과정 = 인터럽트 과정이 매우 자주 발생하게 됨
			- 
		- 특정 응용 프로그램에서 생성된 데이터를 HDD에 저장하는 상황.
		- 응용 프로그램 <> HW-HDD 직접 상호작용을 통해 데이터가 저장 X
		- 운영체제와 먼저 상호작용 진행 > 운영체제와 HDD 상호작용을 통해 최종 데이터가 저장됨
		- EX) 운영체제에 존재하는 `HDD에 데이터를 저장해라!` 의미를 가진 명령코드 실행
		- 
	- `상황예시1` 상황에서 아래와 같은 과정이 있었던 것
		- 1. **시스템콜 사용**: 
			- 응용 프로그램이 시스템 자원에 접근하고자 할 때, 시스템콜을 통해 운영체제에 요청을 합
				- EX) `OS야 나 ~ 프로그램인데 ~ 데이터 HDD에 저장해야됨`> `HDD야 나 OS인데 ~ 프로그램이 ~데이터 저장해야된데 너 코드 해석>실행하는 모드 변경하고 데이터 저장해줘`
			- 이는 CPU-사용자 모드에서 실행 중인 프로그램이 하드디스크 드라이브(HDD)와 같은 하드웨어에 접근하고자 할 때 필요 (접근해야 해석 > 실행함)
			- 
			- 시스템 콜(system call) = 시스템 호출? =>
				- 사용자 프로그램이 운영체제의 커널 기능을 요청하기 위해 사용하는 인터페이스 및 명령코드
					- = 운영체제가 제공하는 서비스에 프로그램적으로 접근할 수 있도록 하는 명령코드
					- = 시스템콜은 응용 프로그램과 운영체제 사이의 명령 코드
					- = 응용 프로그램이 운영체제를 통해 하드웨어 자원을 안전하게 사용할 수 있도록 하는 인터페이스 역할 
				- 즉, 응용 프로그램이 운영체제의 자원을 안전하고 효율적으로 사용하도록 특정 **작업을 요청**하는 명령어나 코드로 이해
				- 
				- 주의 
					- 시스템콜은 응용 프로그램에서 사용하는 명령코드! 하지만 시스템 콜 자체는 운영체제의 일부(내부에 정의-존재)
					- "운영체제에서 사용하는 명령코드이다!"라는 표현 X
					- 
				- 작업요청? =>
					- 응용 프로그램은 HW-자원에 직접 접근하면 위험. 
					- 응용 프로그램이 하드웨어에 직접 접근하지 않고 운영 체제를 통해 필요한 작업을 수행하도록 요청하는 방식은 응용 프로그램이 시스템 자원(HW)을 효율적이고 안전하게 사용할 수 있도록 함
						- = 운영체제 기능 - `응용프로그램들이 자신을 통해서 HW 자원에 접근하도록 함`
						- 해당 기능은 메모리 관리, CPU 관리를 포함하여 운영체제의 여러 기능에 걸쳐 있음
				- 
				- 시스템 콜-명령어 종류
					- <span style="background:#d3f8b6">시스템 호출-명령어 종류-이미지</span>
						- 이미지 설명 =>
						- 운영체제의 다양한 기능들에 대한 명령코드가 정의되어 있고 > 해당 기능이 필요할 때 해당 코드가 실행되고 있던 것
						- 
						- 프로레스 관리 시스템 콜-명령어
						- 파일 관리 시스템 콜-명령어
							- **`open`**: 파일을 열고 파일에 대한 접근 권한을 획득
							- 파일의 내용을 읽을 때, 응용 프로그램은 `read` 시스템 콜을 통해 운영 체제에게 데이터를 요청 > 운영 체제는 CPU 모드 변경 > 따라서  파일에서 데이터를 읽어 프로세스의 메모리 공간으로 전송 가능해짐
						- 디렉토리 관리 시스템 콜-명령어
						- 파일 시스템 관리 시스템 콜-명령어
						- 
		- 2. **모드 전환**: 
			- 참고노트 : [[ALU-산술논리장치-플래그레지스터#- 다양한 플래그 값 표-이미지\|ALU-산술논리장치-플래그레지스터#- 다양한 플래그 값 표-이미지]] / 슈퍼바이저 플래그
			- 시스템콜-요청(예: 데이터 저장 요청)을 받으면 > 운영체제는CPU를-커널 모드로 전환합 > 커널 모드에서는 운영체제가 직접 하드웨어를 조작할 수 있는 권한을 가짐 
				- = ~한 코드를 해석 > 실행할 수 있음
				- 즉, 응용 프로그램이 시스템콜을 운영체제쪽으로 보내면 운영체제는 CPU 모드를 변경한다. 요청-코드를 해석 > 실행하기 위해
				- 
		- 3. **작업 수행 및 모드 복귀**: 
			- 요청된 작업(예: HDD에 데이터 저장)이 완료되면, 운영체제는 다시 사용자 모드로 전환하여 응용 프로그램에 제어권을 반환
			- 이렇게 함으로써 시스템의 보안과 안정성을 유지하면서도 필요한 작업을 효과적으로 수행



##### - [[메모리-주소체계-주소공간-작동원리\|메모리-주소체계-주소공간-작동원리]]
- 2. **운영 체제** - 큰 개념
    - 메모리 관리
	    - 가상 메모리
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 메모리 주소 공간 구분 = 주소 체계
	- 메모리 기본적인 작동원리
		- CPU나 실행 중인 프로그램은 스스로 메모리의 특정 주소에 무엇이 저장되어 있는지, 어떤 주소가 비어 있는지를 직접 알 수 없음
			- = 실행되는 프로그램은 가상 메모리 주소를 사용하여 자신이 실제 메모리의 어느 위치에 적재되었는지 모르는 상태로 실행
		- 이 정보/실제 주소는 운영 체제에 의해 관리되며, 운영 체제는 프로세스가 요청할 때 메모리를 할당하고 회수함 (운영체제 기능) 
		- 메모리에 저장되는 값들은 프로그램의 실행과 종료에 따라 계속 변함 
			- = 한 프로그램이 종료되면 그 프로그램이 사용했던 메모리 영역은 다른 프로그램이 사용할 수 있게 됨
			- = 같은 프로그램이라도 다른 시점에 실행될 때 메모리의 다른 위치에 적재될 수 있습
			- 
	- **물리 주소와 논리 주소(가상 주소)는 컴퓨팅 시스템 내에서 데이터에 접근하는 두 가지 다른 방식 존재.**
	- ==물리주소-논리주소? =>== | [[물리주소-논리주소-운영체제-MMU\|물리주소-논리주소-운영체제-MMU]]- 
		- 
	- Q. 두 가지 다른 방식이 존재하는 이유?
		- 메모리보호
		- = 이런 **메커니즘/개념**은 프로세스 간 메모리 격리를 보장하고, 시스템의 안정성과 보안을 향상
		- 이런 매커니즘/개념? =>
			- <span style="background:#d3f8b6">논리주소-물리주소-프로세스-이미지</span>
				- : CPU는 메모리 접근하기 전 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지를 항상 검사하고 있음
				- = 실행 중인 프로그램의 독립적인 실행 공간 확보 = 하나의 프로그램이 다른 프로그램을 침범하지 못하게 보호
				- 
	- 물리주소 <> 논리주소 없다면?
		- <span style="background:#d3f8b6">논리주소-물리주소-존재이유-이미지</span>
			- 
	- 이러한 두 가지 다른 방식의 주소가 존재할 때 영역을 침범하는 경우를 방지하기 위해, 메모리를 보호하기 위해 `한계 레지스터` 존재
	- **한계 레지스터(Limit Register)? =>**
		- <span style="background:#d3f8b6">베이스-한계레지스터-MMU-이미지</span>
			- 상황예시 =>
			- 논리주소 값 범위를 넘어서는 주소값 사용 X 
			- 논리 주소 범위를 벗어난 명령어/제어신호 발생한 상황
			- 현재 제어신호가 실행된다면 논리주소 200 + 베이스 값 100 = 300번지 값이 삭제됨
				- = 영역을 침범
				- = 삭제되면 안되는 값이 삭제됨
		- 역할/기능
			- 프로그램 영역을 침범할 수 있는 명령어 실행을 막음
		- 어떻게? =>
			- 베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한 것 처럼 한계 레지스터는 논리 주소의 **최대 크기**를 저장
				- = 메모리 세그먼트의 크기를 제한하는 데 사용
				- = 해당 세그먼트가 차지하는 메모리의 범위를 나타냅
			- 베이스 레지스터 값 + 한계 레지스터 값이 존재 > 실제 메모리에서 프로그램의 처음위치와 최대 위치/끝 위치 파악 가능
			- 이를 통해 프로그램이 할당된 메모리 범위를 넘어서는 접근을 시도할 때 오류를 발생시켜 보호 메커니즘을 제공



##### - [[물리주소-논리주소-운영체제-MMU\|물리주소-논리주소-운영체제-MMU]]
- 2. **운영 체제** - 큰 개념
    - 메모리 관리
	    - 가상 메모리
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==물리주소-논리주소? =>== 
	- <span style="background:rgba(205, 244, 105, 0.55)">논리주소-물리주소-존재이유-이미지</span> | [[메모리-주소체계-주소공간-작동원리#- 논리주소-물리주소-존재이유-이미지\|메모리-주소체계-주소공간-작동원리#- 논리주소-물리주소-존재이유-이미지]]
	- 
	- 1. 물리 주소 (Physical Address)
		- 이는 실제 메모리 칩 내에서 데이터가 저장되는 물리적 위치 > 따라서 0번지 위치는 오직 하나 뿐
			- = 실제 메모리 셀에 접근하는 데 사용되는 주소
		- 이 주소는 메모리 관리 하드웨어에 의해 직접 참조
		- 
	- 2. 논리 주소=가상 주소=추상화 주소 (Logical Address)
		- 논리 주소는 각 프로세스가 자신만의 가상의 독립된 메모리 공간을 가지는 것처럼 작동하게 해주는 추상화된 개념
			- = 각 프로세스는 마치 전체 시스템 메모리를 해당 프로그램/프로세스가 전체를 다 사용하고 있는 것처럼 느끼게 됨
			- = 각 프로세스는 자신만의 독립된 주소 공간을 가지며, 이 공간 내에서는 0번지부터 시작하는 주소 체계를 가집 
			- = 각각 공간에 0번지 존재 가능
		- 이는 CPU와 프로그램에 의해 사용되는 주소로, 운영 시스템에 의해 관리
		- 
		- 가상 주소이기 때문에 운영 체제는 프로세스가 사용하는 **논리 주소를 실제 물리 주소로 변환**하여 실제 메모리 접근을 가능하게 합
		- 논리 > 물리 주소변환(Address Translation)? =>
			- 운영 체제와 MMU 모두 관여. 즉, 두 컴포넌트는 협력하여 메모리 접근 및 관리를 가능하게 합
				- 운영 체제
					- 높은 수준의 메모리 관리 작업을 수행
						- =="높은 수준의 작업"과 "낮은 수준의 작업"이라는 표현== | [[높은수준작업-낮은수준작업-표현의미\|높은수준작업-낮은수준작업-표현의미]]
					- = 운영 체제는 가상 메모리 관리를 개념적으로 수행
					- = 프로세스에 가상 주소 공간을 할당하고, 해당 공간의 관리, 가상 주소와 물리 주소 간의 매핑 정보를 유지 관리하는 역할
					- = 프로세스가 메모리를 요구할 때 해당 주소 변환을 가능하게 하는 매핑 정보를 설정
						- 
				- MMU (Memory Management Unit) =메모리 관리 장치
					- 실제 하드웨어 장치
					- 구체적인 작업은  하드웨어 수준에서 MMU가 담당
						- = CPU에서 발생하는 메모리 접근 요청 시 운영 체제에 의해 설정된 페이지 테이블이나 다른 주소 매핑 구조를 사용 > 논리 주소를 물리 주소로 변환하는 구체적인 작업을 담당
					- 
					- <span style="background:#d3f8b6">베이스-한계레지스터-MMU-이미지</span> | [[메모리-주소체계-주소공간-작동원리#- 베이스-한계레지스터-MMU-이미지\|메모리-주소체계-주소공간-작동원리#- 베이스-한계레지스터-MMU-이미지]]
						- 내부과정 =>
							- CPU는 논리주소를 메모리에게 보낸다. > 사실 그 전에 MMU 장치 거친다 > MMU가 논리주소를 물리 주소로 변환 > 메모리는 최종적으로 물리주소를 받는다.
							- 논리주소 100번지 삭제 신호 > 논리주소 + 베이스 레지스터 값 > 물리주소 15100번지 삭제 신호 > 메모리 도착
							- 가상의 공간에서 논리주소 값 = 실제 메모리에서 첫 시작점으로부터 떨어진 거리/변위가 됨.
							- 
						- 논리주소 + 베이스 레지스터 값 더해 논리주소를 물리주소로 변환함
							- = 논리주소와 베이스 레지스터 값을 더하면 실제 메모리상에 존재하는 주소/위치 파악 가능
						- 복기 - `가상공간-논리주소는 0번부터 시작`
						- 복기 - `베이스 레지스터에는 프로그램의 시작점 주소 존재`
						- 
						- 주의
							- 복기 : `데이터는 CPU-논리주소 > MMU에 의해 변환된 물리 주소를 기반으로 메모리로 전송 > 도착`
							- 그 이후 메모리에서 CPU로 데이터가 전송될 때, 물리 주소가 다시 논리 주소로 변환될 필요는 없음
							- 왜? =>
								- 그 이유는 이미 CPU 내에서 실행 중인 프로세스가 논리 주소를 통해 데이터를 요청하고, MMU가 이를 물리 주소로 변환하여 메모리 접근을 수행. 
								- 즉, 메모리에서 데이터가 CPU로 돌아올 때, 이미 해당 데이터는 특정 논리 주소에 대한 응답으로 간주되어 논리 주소를 요청한 해당 지점에서/논리 주소를 통해 필요한 값을 받게 됨
								- 





##### - [[높은수준작업-낮은수준작업-표현의미\|높은수준작업-낮은수준작업-표현의미]]
- 1. **컴퓨터 구조** - 큰 개념
    - 메모리 계층구조
    - 
- 2. **운영 체제** - 큰 개념@
    - 메모리 관리
	    - 가상 메모리
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- =="높은 수준의 작업"과 "낮은 수준의 작업"이라는 표현== =>
	- 각각 추상적인 작업과 구체적인 하드웨어 작업을 구분하는 용어
	- 
	- 높은 수준의 작업 (High-Level Tasks)
		- 추상적인, 즉 직접적으로 눈에 보이지 않는 소프트웨어 관리 작업을 의미
			- = 사용자 에게 메모리 관리의 복잡성을 숨기고, 편리한 추상화를 제공
			- = 사용자 또는 프로그래머가 직접 관여하지 않는, 운영 체제가 제공하는 추상화된 서비스나 관리 기능을 의미
		- EX)
			- 운영 체제는 프로세스가 시작될 때 각 프로세스에 독립적인 가상 메모리 공간을 할당
			- 
	- 낮은 수준의 작업 (Low-Level Tasks)
		- 물리적인 장치나 하드웨어가 수행하는 물리적인, 기술적인 작업을 의미
			- = 컴퓨터의 물리적 구성 요소에 직접적으로 영향
		- EX)
			- MMU 같은 하드웨어가 실제 메모리 주소 변환, 데이터 전송, 접근 제어와 같은 작업을 수행하는 것



##### - [[프로그램실행원리-CLI-cmd-GUI\|프로그램실행원리-CLI-cmd-GUI]]
- 2. **운영 체제** - 큰 개념
	- CLI와 GUI는 운영 체제가 제공하는 기본 인터페이스
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 프로그램 실행 원리
	- 사용자가 다운받은 모든 것은 프로그램/코드덩어리/집합/기능임. > 사용하기 위해선 2가지 방식 중 1가지를 이용해 실행-사용
	- 1. CLI(Command Line Interface) 방식
		- "사용자가 텍스트 기반 명령어 입력 > 기능 사용" | [[cmd단위-명령코드\|cmd단위-명령코드]]
		- CLI를 지원하는 프로그램을 사용하기 위한 프로그램 존재
			- = 명령어를 입력 > 실행하는데 사용되는 텍스트 기반 인터페이스
			- 인터페이스? =>
				- "서로 다른 요소와 상호작용하기 위한 방법 제공하는데 사용되는 용어/개념"
			- CMD (Command Prompt) = 명령 프롬프트
				- 윈도우 운영체제에서 프로그램을 사용하기 위한 프로그램으로 표현 가능
				- 윈도우 운영체제 내에서 커맨드 라인 인터페이스를 제공하는 프로그램
				- 사용자는 이를 통해 텍스트 기반 명령어를 입력하여 운영 체제를 관리하고, 파일 시스템을 탐색하며, 다양한 프로그램을 실행
			- 윈도우 파워셸(Windows PowerShell)
			- 터미널 (Terminal)
			- 콘솔 (Console)
				- 콘솔은 입력과 출력을 다루는 장치나 가상 환경을 의미도 존재
					- 
	- 2. GUI(Graphical User Interface) 방식 
		- "사용자가 그래픽 요소(버튼-아이콘-메뉴 등)사용 > 기능 사용"
		- 상황예시
			- 크롬 브라우저 아이콘 클릭 = 윈도우 운영체제(에) 명령코드 작성


##### - [[윈도우-cmd-사용법\|윈도우-cmd-사용법]]
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 윈도우 cmd 사용법
	- 특정 폴더에서 바로 cmd 실행 가능
		- 해당 방법을 몰랐을 때 : 처음 위치부터 명령코드 이용 하나씩 접근
		- 1. 폴더 주소표시줄에서 cmd 입력
			- <span style="background:#d3f8b6">이미지</span>
		- 2. 폴더 빈 공간에 Shift + 마우스 오른쪽 클릭 > `여기서 명령 창 열기`
			- <span style="background:#d3f8b6">이미지</span>

##### - [[커널영역-사용자영역\|커널영역-사용자영역]]
- 2. **운영 체제** - 큰 개념
    - 운영 체제의 역할과 기능
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 커널 용어
	- 커널이라는 용어는 다음 두 가지 관점에서 이해 가능
	- 이 두 가지 의미는 서로 다른 관점을 제공하지만, 결국 커널은 운영체제와 메모리 양쪽 모두에서 핵심적인 기능을 담당
		- 1. 메모리 관점에서의 커널
			- 메모리에서 커널 영역은 운영체제의 핵심코드와 데이터가 저장되는 공간
		- 2. 운영체제 입장에서의 커널
			- <span style="background:#d3f8b6">운영체제-커널-이미지</span>
			- 운영 체제의 핵심 기능을 수행하는 기능 (코드와 서비스)
				- + 따라서 운영체제 안에 존재하지만 핵심기능이 아닌 기능들은 커널이라고 표현하지 X 
				- EX) 유저 인터페이스 기능 : 운영체제 핵심 기능(커널) X
			- 이는 시스템의 모든 관리 작업을 담당하며, 하드웨어 리소스의 관리, 프로세스와 메모리 관리, 입출력 관리 등의 중요한 역할을 수행
			- 
			- 
- 1. 커널영역(Kernel Space)
	- 메모리에서 운영 체제의 핵심 부분이 실행되는 곳
	- 운영체제는 하드웨어와 직접적으로 상호 작용
	- 일반적인 응용 프로그램이 직접 접근할 수 없는 보호된 영역
- 2. 사용자영역(User Space)
	- 일반 소프트웨어 애플리케이션이 실행되는 영역
		- = 사용자가 실행하는 **모든 프로그램** 포함
	- 프로그램? =>
		- 사용자 영역에서 각 프로그램은 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구성된 자신만의 독립적인 주소 공간을 가집
		- = 프로그램이 실행되기 위해서는 실제로 메모리 상에 주소 공간에 로드되어야 하며, 이 주소 공간 내에서 다양한 추상적인 구분(예: 코드 영역, 데이터 영역, 힙 영역, 스택 영역 등)이 존재
			- 코드 영역(Code Segment) : 프로그램의 실행 코드가 저장되는 곳
			- 데이터 영역(Data Segment): 전역 변수와 정적 변수가 저장되는 곳
			- 힙 영역(Heap Segment): 동적으로 할당된 메모리(예: C에서 malloc, C++에서 new)가 위치하는 곳
			- 스택 영역(Stack Segment): 함수의 매개변수, 지역 변수, 반환 주소 등이 저장되는 곳 + 함수 호출 시 할당되고, 함수가 반환될 때 해제
			- 
	- 사용자 영역의 프로그램은 커널 영역에 비해 제한된 접근 권한을 가지며, 시스템 리소스에 접근할 때는 커널을 통해야 함
		- = "사용자 영역의 프로그램이 시스템의 리소스나 서비스에 접근할 때는 커널, 즉 운영 체제의 중심적인 부분을 통해야 한다"
			- 위 문장은 운영 체제의 기능 중 하드웨어 자원 관리(보호)의 일환 = 사용자 프로그램이 하드웨어 자원에 직접적으로 접근하는 것이 아니라, 커널을 통해 이루어진다는 운영 체제의 중재 역할을 강조
			- EX)
				- 입출력(I/O) 관리
					- : 이는 사용자 영역의 프로그램이 입출력 장치를 사용하고자 할 때 커널을 통해 요청이 이루어지고, 커널이 이를 관리하고 조정
					- 
				- 저장 장치 관리
					- : 파일 시스템 접근이나 저장 장치 사용 역시 커널을 통해 이루어집 > 사용자 프로그램이 데이터를 저장하거나 읽고자 할 때, 이 작업들은 커널에 의해 중재되고 관리

##### - [[시스템자원-시스템리소스-resource-용어\|시스템자원-시스템리소스-resource-용어]]
- 컴퓨터 시스템
	- 1. **컴퓨터 구조** - 큰 개념
	- 2. **운영 체제** - 큰 개념
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 시스템 자원 = 시스템 리소스 = resource
	- 프로그램이 실행되기 위해 필요한 (실제 HW)요소들을 의미 > 따라서 주로 '시스템 리소스'라는 용어는 컴퓨터의 핵심 부품인 CPU, 메모리, 입출력 장치 등 의미
	- 
	- 주의
		- 시스템 자원이란 일반적으로 컴퓨터의 핵심 하드웨어 부품을 의미하지만, 보다 넓은 의미에서는 소프트웨어적인 요소도 포함
		- EX) 파일 시스템, 데이터베이스, 네트워크 대역폭, 시스템 포트 등도 시스템 자원에 포함
		- 
	- 시스템? =>
		- 상호관련(된) 요소(들의) 집합 > 이 요소들은 함께 작동하여 공통적인 목표를 수행
		- EX) 분산버전관리시스템
			- 여러 컴포넌트와 프로토콜들을 사용해 코드 버전관리를 처리하는 전체 구조 의미
			- 깃은 분산버전관리시스템/프로그램
		- 상황에 따라 시스템의 구성요소들은 달라짐.
			- 함수(Function):
				- 시스템 내의 요소들이 특정 기능을 수행할 때, 각 요소는 시스템 전체의 기능을 위해 특정 역할을 수행하는 '함수'로 해석 가능
			- 모듈(Module):
				- 프로그래밍 컨텍스트에서, 요소들은 시스템 내에서 독립적이거나 반독립적으로 기능하면서 특정 기능을 수행하는 '모듈'로 해석 가능 > 각각 함께 작동해 더 큰 시스템의 일부 구성
			- 프로그램(Program) :
				- 좀 더 확장된 소프트웨어 시스템에서는 각 요소가 개별적인 '프로그램'이 될 수 있으며, 이 프로그램들이 상호 작용하여 복잡한 작업을 수행
			- 실제 하드웨어 부품(HW-Component):
				- 하드웨어 시스템의 경우, 각 요소는 실제 물리적 부품이 될 수 있으며, 이들 부품이 서로 상호작용하여 전체 시스템이 기능


##### - [[파일경로-절대경로-상대경로-기호표현\|파일경로-절대경로-상대경로-기호표현]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 파일경로
	- 1. 절대경로
		- root 기준 = C드라이브 기준 > 위치설명 시작
		- ex) 
			- `C:\Program Files\Git`
		- 어느 곳에서든 경로에 접근할 수 있는 형태임
			- 왜? : C드라이브 즉, 루트지점을 기준으로 위치를 설명하고 있기 때문
		- 절대경로 사용상황/용도
			- ex_) "웹에 올려진 데이터를 사용할 때"
			- 
	- 2. 상대경로
		- "현재 작성하고 있는 코드파일 위치를 기준으로 연결하려는 파일 위치설명"
		- = 처음부터 위치 설명 x, 현재 위치 기준 설명 방법
		- ex)
			- `./src/compnents/Counter.js`
				- 현재 위치 > 앞으로 이동하는 느낌
			- `../../img/logo.jpg`
				- 현재 위치 > 뒤로 이동하는 느낌
		- 상대경로 사용상황/용도
			- "내 로컬 디렉토리 내부에서 파일 연결할 때"
	- 
	- 다양한 기호 표현 존재
		- <span style="background:#d3f8b6">예시코드1</span>
		- <span style="background:#d3f8b6">cmd-예시코드</span>
		- 
		- `/` - root 위치(경로) 선택(이동)됨
		- `./` - 현재 위치(경로) 선택됨
			- 생략가능
		- `../` - 상위 위치(경로) 선택됨



##### - [[FAT파일시스템-프로세스-이해\|FAT파일시스템-프로세스-이해]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==FAT 파일 시스템==
	- USB, SD카드 등 저용량 저장장치에서 많이 사용되는 방식
	- 불연속-연결 할당 방식 기반 + **단점을 보안**한 파일 시스템
		- <span style="background:#d3f8b6">기존 불연속-연결할당방식-이미지</span>
	- 단점? 보안? =>
		- 기존 : 블록 안에 다음 번지 블록 주소를 기억하는 방식 > 이런 방식으로 인한 단점이 존재했음
		- 각 블록에 포함된 다음 블록 주소를 한데 모아 **테이블**로 관리하면서 보안 가능
		- 테이블? =>
			- FAT = File Allocation Table
			- FAT12 / 16/ 32 등 존재
			- 뒤 숫자 의미 : 블록을 표현하는 비트수
			- 
	- <span style="background:#d3f8b6">FAT파일시스템-FAT영역테이블-이미지</span>
	- <span style="background:#d3f8b6">FAT시스템-파티션구조-이미지</span>
		- FAT12 방식을 사용 시 > 각 파이션 모습
		- 예약영역 / FAT 영역/ 루트 디렉토리 영역/ 데이터 영역 존재
	- <span style="background:#d3f8b6">FAT시스템-디렉토리엔트리-이미지</span>
		- 디렉토리 엔트리에는 어떠한 값?
		- 파일 이름 / 확장자 / 속성 / 예약영역 / 생성시간 / 마지막 접근시간 / 마지막 수정시간 / 시작블록 / 파일크기 
	- <span style="background:#d3f8b6">FAT파일시스템-과정이해-이미지</span>
		- FAT 파일 시스템 사용시 어떤 과정을 거쳐 `a.sh`파일위치에 접근하는지 확인 =>
		- FAT 영역에는 FAT 값 존재
		- 루트 디렉토리 영역에는 루트 디렉토리 값 존재
		- 데이터 영역에는 루트 디렉토리 이외 디렉토리 존재
		- 
		- 순서대로 읽으면 결국 `a.sh` 파일 시작점이 되는 블록 주소 확인가능
			- 루트 디렉토리 > home 디렉토리 첫 번째 주소 3
			- h 디렉토리 > minchul 디렉토리 첫 번째 주소 15
			- m 디렉토리 > 찾고자 하는 파일 첫 번째 주소 9 
			- 첫 번째 주소를 알았으니 FAT 영역에 존재하는 표 이용 하나의 데이터 완성! 접근 가능
			- 9 > 8 > 11> 13 > -1 


##### - [[유닉스파일시스템-프로세스-이해\|유닉스파일시스템-프로세스-이해]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==유닉스 파일 시스템==
	- 불연속-색인 할당 기반 파일 시스템
	- 색인 블록 = `i-node` = 인덱스 노드! 라고도 부름
	- i-node? =>
		- 파일 속성 정보와 **15개의 블록 주소 저장** 가능
		- 즉, i노드만 읽어도 파일의 속성값들과 어디에 저장되어 있는지 확인 가능
		- 즉, 유닉스 파일 시스템에서는 i노드가 핵심값
	- 
	- <span style="background:#d3f8b6">디렉토리 엔트리-테이블-이미지</span>
		- i노드 번호와 파일 이름값만 저장
	- <span style="background:#d3f8b6">유닉스 파일시스템-과정이해-동작원리이해-이미지1</span>
		- 1. =>
		- `i-node`값은 유닉스 파일 시스템 사용 시 한 파티션에 모여 저장됨 = i-node 파티션-영역 존재
		- 
		- 파일 시스템 동작원리-과정-예시
			- `a.sh` 파일을 접근해 나가는 과정 가정
			- 유닉스파일시스템 파티션 구조 확인 가능
				- 예약영역 / i-node 영역 / 데이터 영역
			- i노드 영역 > i노트 2번 확인 가능 = 루트 i노드 > 루트 디렉토리 접근하기 위한 데이터 주소 저장된 상황 따라서 가장 먼저 접근 
			- 루트 디렉토리 값 1번 블록 저장 확인 > 접근
			- home 디렉토리 i노드번호 3번 확인 가능 > i노드 3번에 접근 > 210 주소 확인 가능 > 해당 주소로 이동
			- minchul 디렉토리 i 노드번호 8번 확인 가능 > i노드 8번에 접근 > 121번 주소 확인 가능 > 해당 주소로 이동
			- 최종 원하는 파일 a.sh의 i노드 번호 9 확인 가능 > 9번 i노드에 접근 > 해당 데이터들이 98, 12, 13에 각각각 저장 확인
			- 
	- **Q.** 그렇다면 15개의 블록을 넘는 더 큰 파일이 저장되는 경우엔 어떻게 동작? = 1개 i노드만으로 부족한 경우
		- <span style="background:#d3f8b6">유닉스 파일시스템-과정이해-동작원리이해-이미지2</span>
		- 1. 1번 i노드 > 블록 주소 중 12개에는 직접 해당 데이터-블록 주소를 저장
		- 2. 1개의 노드로 충분하지 않다면 13번째 주소부터는 `단일 간접 블록` 주소를 저장
			- 파일 데이터를 저장한 블록 주소들이 저장된 블록 
				- = 즉 마치 다른 i-node 주소를 저장
		- 3. 이마저도 충분하지 않다면 14번째 주소에 `이중 간접 블록` 주소를 저장
			- 마치 다른 i-node를 추가적으로 연결
			- 다른 i-node에는 데이터를 저장한 주소가 저장된 상태
			- `단일 간접 블록`들의 주소를 저장한 블록
		- 4. 이마저도 충분하지 않다면 15번째 주소에 `삼중 간접 블록` 주소 저장
			- 이중 간접 블록들의 주소를 저장한 블록


##### - [[파티셔닝-파티션-포매팅-포맷\|파티셔닝-파티션-포매팅-포맷]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==파티셔닝, 포매팅==
	- **파티셔닝 작업-과정**
		- 메모리 주소공간을 구분하는 내용과 헷갈림 주의
			- 참고노트 : [[메모리-주소체계-주소공간-작동원리\|메모리-주소체계-주소공간-작동원리]]
			- 상황예시
				- **논리주소와 물리주소의 예시:** 
				- 프로그램이 메모리 주소 0x00123456에 데이터를 저장하려고 할 때, 이 주소는 논리 주소
				- 운영체제와 MMU는 이 논리 주소를 실제 물리 메모리 주소로 변환하여 데이터가 실제 메모리 셀에 저장
				- 
		- <span style="background:#d3f8b6">파티셔닝작업-그림이해-이미지</span>
		- 파티셔닝은 실제 하드웨어 장치의 저장 공간을 **논리적**으로 분할하는 작업을 의미
		- 논리적으로 분할? =>
			- 물리적으로 하드 드라이브를 분할하는 것이 아니라, 하드 드라이브 내의 데이터 저장 영역을 여러 개의 독립적인 파티션으로 나누는 것을 의미
		- 이 논리적 분할을 통해 사용자는 각 **파티션**이 마치 별도의 드라이브처럼 사용될 수 있도록 함 > 다양한 운영 시스템을 설치하거나, 데이터를 효율적으로 관리하거나, 백업을 용이하게 할 수 있습
		- 상황예시
			- 하드 드라이브가 1TB 용량을 가지고 있을 때, 이를 500GB와 500GB로 나누어 각각 Windows 시스템과 Linux 시스템을 위한 별도의 파티션으로 구성할 수 있습
			- = 각 파티션은 독립적으로 운영될 수 있음 > 따라서 다른 파일 시스템을 적용할 수 있습
				- 
		- 하나의 HDD에 어떻게 파티셔닝, 영역이 구획되어 있는지 직접 확인 가능
			- <span style="background:#d3f8b6">윈도우-디스크관리-파티션-이미지</span>
			- 과정 =>
			- 윈도우 운영체제 검색 :  하드 디스크 파티션 만들기 및 포맷 
			- 디스크 관리 메뉴
			- C /1 / 4 / 5 / 6 파티션 존재 확인 가능
			- 어떠한 파일 시스템 사용 확인 가능
			- 
	- **포매팅 작업-과정**
		- "포맷하다"와 "포매팅하다"는 같은 의미
		- 정의/의미/기능
			- 컴퓨터의 저장 매체를 사용할 수 있는 상태로 만들기 위해 데이터 저장 구조를 초기화하는 과정
				- = 드라이브 내에 파일 시스템을 생성하여 파일들이 저장되고 관리될 수 있도록 준비하는 작업을 의미
				- = 어떤 방식으로 파일을 저장-관리할지 결정 후 새로운 데이터를 쓸 준비를 하는 작업
			- 즉, 포매팅하다! = 데이터 저장 구조 초기화, 파일 시스템을 설정, 호환성 확인하다! 의미
			- 
		- 상황예시
			- 새로운 외장 하드 드라이브를 구매했다고 가정
			- 이 드라이브를 처음 사용하기 전에는 일반적으로 포맷하는 과정을 거침
				- + 새 드라이브는 공장에서 포맷되어 나오기는 하지만, 때로는 기본 설정된 파일 시스템이 사용자의 운영체제나 특정 요구와 맞지 않을 수 있습
			- 이 과정에서 사용자는 NTFS, FAT32, exFAT 등 원하는 파일 시스템을 선택하여 포맷할 수 있습
			- 포맷하거나 포매팅하라는 명령을 실행하면, 선택한 파일 시스템에 맞게 드라이브의 저장 구조가 설정


##### - [[파일시스템-파일단위-이해\|파일시스템-파일단위-이해]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==파일==
	- 파일을 이루는 정보 존재 =>
	- `마우스 우클릭 > 속성` 통해 직접 확인 가능
	- 1. 실제로 파일에 저장된 정보 + 
	- 2. 파일을 실행하거나 접근하는 데 필요한 **메타데이터** + 
		- 메타데이터?=>
		- 파일에 대한 데이터로, 파일을 설명하거나 분류하는 데 사용되는 데이터
		- 파일의 생성 날짜, 수정 날짜, 파일 크기, 파일 타입 등과 같은 정보 > 이러한 정보들은 파일 시스템에 의해 관리
	- 3. 부가 정보 = 파일의 속성
		- 속성? =>
		- 파일의 메타데이터를 구체적으로 설명하는 항목일 수 있으며, 파일의 보안 설정, 읽기/쓰기 권한, 숨김 상태 등의 정보
		- 파일의 접근 권한, 타임스탬프, 파일 크기와 같은 속성 정보
		- 
	- 주의 : 두 용어 사이에는 약간의 차이가 있을 뿐, `파일의 메타데이터`와 `파일 속성`은 서로 밀접하게 연관되어 있으며, 종종 같은 의미로 사용
	- EX) `파일 속성 ` = `파일 메타데이터` 안에 `파일 크기` 존재
		- <span style="background:#d3f8b6">파일의 속성-확장자-이미지</span>
			- 이미지 요약 =>
			- 유형 / 크기 / 보호 / 생성날짜 / 마지막 접근 날짜 / 마지막 수정 날짜 / 생성자 / 소유자 / 위치
			- `유형` = `파일 확장자` = `파일 종류`
				- 운영체제에게 해당 파일을 확인하기 위해선 어떠한 프로그램이 필요한지 or 어떠한 프로그램으로부터 생성된 파일인지 알려줌
				- EX) 
					- 실행파일
					- 목적파일
					- 코드파일
					- 워드프로세서 파일
					- 텍스트 파일
					- 라이브러리 파일
					- 멀티미디어 파일 = 이미지 파일, 동영상 파일
					- 백업 및 보관 파일


##### - [[파일시스템-폴더-디렉토리구조-이해\|파일시스템-폴더-디렉토리구조-이해]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==폴더(또는 디렉토리)==
	- 용어
		- 최상위 디렉토리 = 루트 디렉토리 
		- 서브 디렉토리
		- 
	- 이러한 파일들을 효율적으로 관리하고 **구조화**하기 위해 사용하는 단위
	- **구조화**하다! = **계층적**으로 관리하다!
	- 구조화? 계층적? =>
		- 단일 계층이 아닌 여러 계층으로 파일 및 폴더를 관리한다면 > `트리 구조 디렉토리` 표현 사용
		-  <span style="background:#d3f8b6">트리구조 디렉토리-이미지</span>
			- 같은 내용-구조-개념을 가지고 있지만 운영체제에 따라서 표기법 다름
			- 리눅스 운영체제 =>
			- `/` 2가지 의미 가짐
				- 1. 루트 디렉토리 위치
				- 2. 디렉토리 간 구분자
					- 
		- <span style="background:#d3f8b6">예시코드1</span>
	- 
	- 디렉토리 엔트리 표현 이해
		- 복기: `폴더는 파일들을 효과적으로 관리하기 위해 사용되는 논리적인 단위`
		- 사용자의 관점에서 보면, 폴더는 파일이 아닌, 파일을 담는 컨테이너로 생각할 수 있습
		- 하지만 운영 체제 관점에서는 디렉토리(폴더)도 파일의 한 형태로 간주합 > 이는 디렉토리가 파일의 메타데이터, 위치, 권한 정보 등을 저장하는 특별한 형태의 파일이기 때문
		- 요약 => 
			- `디렉토리`는 `특별한 정보를 포함한 파일`로 표현 = 구분짓지 않는다
			- 파일 내부에는 `파일과 관련된 정보` 존재
			- 디렉토리 내부에는 `해당 디렉토리에 담겨 있는 파일-대상과 관련된 정보` 존재
			- 
		- 디렉토리 내부 정보는 **테이블 형태 = 표 형태**로 구성
		- 테이블 형태 = 표 형태? =>
			- 즉 디렉토리 테이블-데이터가 존재하기 때문에 구조=계층=위치를 파악 가능 > 접근이 가능해지고 있던 것
			- <span style="background:#d3f8b6">디렉토리테이블-이미지</span>
				- 이미지 설명 =>
				- 각 엔트리(행)에 담기는 정보 존재 = 디렉토리 테이블 존재
					- 대상의 이름 존재
					- 보조기억장치 내 저장된 위치 정보 존재
				- 그림이해
					- home 디렉토리 테이블이 존재 
					- 따라서 minchul 디렉토리 위치 확인 가능 = 접근가능
					- minchul 디렉토리 테이블 존재
					- .... 



---------------

# ㅡ 3. **네트워킹 기초** - 큰 개념

##### - [[HTTP주소-프로토콜-용어\|HTTP주소-프로토콜-용어]]
- 3. **네트워킹 기초** - 큰 개념
    - 네트워킹 모델 및 프로토콜
    - 네트워크 통신 및 보안
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
	- HTTP주소 <> HTTPS주소 의미-차이점
	- 보안수준/정도
	- ㅡㅡㅡㅡ
	- 프로토콜 용어 => - '데이터 교환 규칙'
	- 데이터 통신 규칙 제공 - '데이터 어떻게 포맷? 전송? 처리?'
		- 일관된 처리 > 안정적인 교환 가능
	- 표준화된 절차 제공
		- 다양한 네트워크 장비 <> 기술 서로 호환
		- 
	- HTTP (HyperText Transfer Protocol) =>
	- 웹 사이트 주소 - `http://`
	- 웹 서버 <> 클라이언트(웹 브라우저) 간 통신 프로토콜
		- 클라이언트-데이터 요청
		- 서버-데이터 응답
		- 
	- HTTPS (HyperText Transfer Protocol Secure) =>
	- 웹 사이트 주소 - `https://`
	- 보안기능 추가 = 
		- SSL(Secure Sockets Layer) / TLS(Transport Layer Security) 프로토콜 
		- 데이터 교환 시 암호화
		- 데이터 기밀성/무결성/안전성 보장



---
# ㅡ 4. **웹 기술** - 큰 개념

### ㅡ 3. **웹 백엔드**

##### [[서버유형-호스팅-배포용어\|서버유형-호스팅-배포용어]]
- **4. 웹 기술** - 큰 개념
	- 3. **웹 백엔드 기술**
	    - 웹 서버와 웹 어플리케이션 서버
	        - 애플리케이션 서버의 역할과 종류
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
	- 서버
		- 1. 하드웨어적 의미
		- 2. 소프트웨어적 의미
		- 소규모인 경우 한 대의 서버가 모든 역할 소화 가능
		- 대규모인 경우 여러 대 서버를 두고 각각 역할 세분화
	- 서버 유형
		- 웹 서버와 애플리케이션 서버 서로 다른 수준의 요청받은 로직을 처리하는 복잡도를 가질 뿐 결국 사용자의 요청에 따른 적절한 데이터를 제공하는 공통된 기능을 수행
		- 
		- 1. 웹서버
			- 정적 파일 서핑, 간단한 서버 사이드 스크립트 처리
			- 웹 서버는 HTTP를 통해 웹 페이지나 파일을 클라이언트에 제공
			- ex) 
				- 사용자가 웹 브라우저를 통해 특정 웹 페이지를 요청할 때, 웹 서버는 해당 HTML 파일, CSS 스타일시트, JavaScript 파일 등을 찾아 사용자에게 전송
				- 
		- 2. 애플리케이션 서버
			- 웹 서버보다 복잡한 비즈니스 로직 처리 = 클라이언트의 요청에 따라 동적인 콘텐츠를 생성하고 제공
			- ex)
				- 온라인 쇼핑몰에서 사용자가 주문을 하면, 애플리케이션 서버는 사용자의 주문 정보를 처리하고, 재고를 확인하고, 결제를 처리하고, 주문 상태를 업데이트하는 등 여러 단계의 처리 작업을 수행
				- 
		- 3. 데이터베이스 서버
			- 데이터의 저장, 검색, 수정 등을 관리하며, 클라이언트 또는 다른 서버의 데이터 요청에 응답
			- 
	- 호스팅 용어
		- 로컬환경에 있는 것을 온라인(웹 서버)에 공개 > 외부 사용자들이 접근할 수 있도록 하는 서비스/기능 의미
		- 해당 서비스를 이용 시 웹 서버는 저장된 데이터(콘텐츠, 코드파일-프로그램)를 관리 + 요청에 따른 응답
	- 배포 용어
		- 완성된 프로그램을 호스팅 서비스를 이용해 외부 사용자가 접근 가능하게 하는 과정 자체를 의미.



----
# ㅡ 5. **데이터베이스 시스템** - 큰 개념


##### - [[데이터분류-구조-형식-규모\|데이터분류-구조-형식-규모]]
- 5. **데이터베이스 시스템** - 큰 개념
	- 데이터의 기본 개념
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==데이터 분류==
	- **구조와 형식에 따라 분류 가능 (가장 주된 분류 방식)**
		- 1. 정형 데이터 (Structured Date) = 조화된 데이터
			- 분석에 사용할 수 있는 형태로 잘 정리된/가공된 데이터를 의미
			- = 정해진 규칙에 따라 데이터가 저장된 형태
			- = **테이블 형태**로 저장된 데이터 = 엑셀 형태
			- 테이블 형태? =>
				- 레코드(행) / 필드(열) / 필드명 (머릿글)
				- 정형 데이터만 데이터베이스 시스템 관리 가능
					- 
		- 2. 비정형 데이터  (Un Structured Date)
			- 동영상, 이미지, 음성파일, 쇼셜미디어텍스트, 이메일 등 데이터 형식이 잘 정리되지 않은 데이터 의미
			- = 정해진 구조가 없는 데이터
			- = 정해진 규칙/구조가 없어 값의 의미를 파악하기 힘든 데이터
				- > 특징 추출해 반정형 or 정형 데이터로 변환하는 과정 필요
			- 
		- 3. 반정형 데이터 - Semi structured Data
			- 데이터베이스 정형적인 구조를 따르지 않지만, 태그나 마커가 포함되어 있어 존재하는 규칙에 따라 분석에 활용할 수 있는 데이터 
			- ex) html, xml, json
				- 
	- **분석 규모(양)에 따라 분류**
		- 1. 빅데이터 - Big Date
			- 정형 - 비정형 - 반정형 데이터세트의 집합 의미
			- 방대한 데이터 규모 자체를 의미
		- 2. 스몰데이터 - Smaill Data
			- 양이 적다는 의미 보다는 (개인의 취향, 생활방식 등 사소한 행동에서 나오는) 개인화된 데이터들을 의미
				- 빅데이터 : 특정 집단의 공통 특징을 구분하기 위해 사용
				- 스몰 : 개인의 차별화된 특성을 파악하기 위해 사용
				- 
	- **기타 관계에 따라 분류**
		- 1. 메타 데이터 - Meta Data
			- 파일에 저장된 정보를 찾고 관리하기 위한 부가 정보 의미
				- ex) 데이터 저장 위치, 저장 날짜 등등
			- 데이터에 대한 데이터
		- 2. 원시 데이터 - Raw Date - 참조 데이터
			- 데이터가 생성된 최초 상태 = 가공되지 않은 원본 상태
			- 수집된 데이터가 분석에 바로 사용 가능하든, 추가적인 처리 과정을 요구하든, 그 초기 상태의 데이터는 모두 원시 데이터 표현 가능
