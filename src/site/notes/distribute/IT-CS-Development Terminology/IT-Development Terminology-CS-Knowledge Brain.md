---
{"dg-publish":true,"permalink":"/distribute/it-cs-development-terminology/it-development-terminology-cs-knowledge-brain/","tags":["개발용어_CS지식","목차"],"noteIcon":""}
---

### 날짜 2023-11-06 15:18



----
# <디지털 환경-세계 인프라 아키텍처>


##### - [[디지털인프라-개발직군-직무-역량 이해\|디지털인프라-개발직군-직무-역량 이해]]
- 디지털 인프라
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:#d3f8b6">디지털 인프라 아키텍처 기반 다양한 개발직군 이해-이미지</span>
	- 웹 기술/개발 관련 직군
		- 제품/서비스(만) 기획 직무
		- UI/UX 제품-서비스 기획 직무
			- 웹 디자인 직무
			- 웹 퍼블리셔 직무
				- 실제 개발을 담당하는 직무들 =>
				- 프론트엔드 개발 - 화면에 보이는 로직구현
				- 백엔드 개발 - 안 보이는 서버쪽 로직구현
				- DBA - 데이터베이스 개발
					- 
	- 기획자/디지털 마케터 : 
		- 하나의 서비스를 성공적으로 진행되게 하기 위한 기능명세서/기획안 작성
		- 예시 =>
			- 네이버에서 특정한 서비스/기능을 사용자들에게 제공 
			- 화면을 사용자친화적 >  어떻게 디자인? 어떤 색? 어떻게 배치? 어떤 내용? 
		- 
	- 클라이언트 측:
	    - 운영체제 개발자: 운영체제의 설계와 개발을 담당
	    - 소프트웨어 개발자: 클라이언트 응용 프로그램을 개발
	    - 프론트엔드 개발자: 웹이나 모바일 애플리케이션의 사용자 인터페이스 개발
	    - 
	- 서버 측:
	    - 백엔드 개발자: 서버 사이드 로직, 데이터베이스 관리, 서버와 클라이언트 간의 통신을 담당
		- DBA(Database Administrator) : 데이터베이스의 설계, 구현, 유지보수, 보안 강화 등을 담당하며, 이를 통해 데이터의 안정성과 접근성을 확보
		- 
	- 네트워크 영역:
	    - 시스템 엔지니어/데브옵스: 클라이언트와 서버 간의 원활한 통신과 상호작용을 보장하며, 인프라의 배포, 관리, 운영을 담당
- <span style="background:#d3f8b6">디지털 인프라 기반 다양한 개발역량-이미지</span>
	- app 개발을 위한 UX/UI 이해 = 분석-설계-기획
	- app 개발을 위한 언어 이해
		- app 개발을 위한 프레임워크/라이브러리 이해
	- 개발한 app 유저와 커뮤니케이션 영역 프론트 이해
	- 개발한 app을 서비스화 하기 위한 서버 이해
		- 서버영역에서 비즈니스 흐름 처리/로직 백엔드 이해
	- 데이터를 수집-저장-관리를 위한 데이터베이스 이해
	- 형상관리-빌드-배포자동화-테스트자동화 이해
	- app 개발을 위한 물리/가상 환경/장비 이해



---
----


# <컴퓨터 시스템>



##### - [[시스템-프로그램-용어이해\|시스템-프로그램-용어이해]]
- 컴퓨터 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- "시스템" 용어
	- 다양한 문맥에서 사용
	- 개별적인 구성 요소들이 서로 상호작용하여 특정한 목표나 기능을 달성하기 위해 함께 작동하는 집합체 의미
	- 따라서 각각의 프로그램, 모듈, 컴포넌트 상호작용을 한다면 시스템! 용어 사용 가능
		- 프로그램 = 코드(파일)덩어리 
			- 모듈 <=> 컴포넌트 용어
				- : '각 컴포넌트는 인터페이스를 통해 상호작용'
				- 특정 기능 담당 독립적인 코드단위/수행 단위
				- 프로그램 일부 
	- ex)
		- DB 시스템(Database System)
			- 데이터베이스 관리 시스템(DBMS)과 데이터베이스로 구성
			- 데이터의 저장, 검색, 관리 등을 효율적으로 수행하기 위해 상호작용
		- 컴퓨터 (시스템) (Computer System)
			- 하드웨어(프로세서, 메모리, 입출력 장치 등)와 소프트웨어(운영 체제, 응용 프로그램 등)가 결합 > 각 하드웨어 구성요소와 소프트웨어가 상호작용하여 컴퓨터가 원활하게 동작
		- 파일 시스템(File System)
			- 파일과 데이터를 효율적으로 저장, 검색, 관리하기 위해 운영 체제에 의해 사용되는 시스템
			- 디스크 내의 데이터를 조직화하고, 파일에 대한 접근 및 관리를 가능하게 하는 여러 구성요소로 이루어져 있습


# ㅡ 1. **컴퓨터 구조** - 큰 개념

##### - [[비트(bit)용어\|비트(bit)용어]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 비트 용어 이해
	- 비트 정의
		- 비트(bit)는 'binary digit'의 줄임말
		- 컴퓨터는 모든 데이터/정보를 이진 형태로 처리하기 때문에, 비트는 컴퓨터가 데이터를 처리하는 기본 단위로 사용
		- 1비트는 **데이터의 크기 단위**이며, 컴퓨터나 기타 디지털 시스템에서 정보를 저장하고 처리하는 가장 작은 단위 > 따라서 "1비트를 처리한다"는 것은 실제로 '데이터 포인트 한 개를 처리한다'는 것과 동일한 의미를 가지며, 이 데이터 포인트는 0 또는 1의 값 중 하나를 가질 수 있음
	- 비트와 데이터 표현 
		- <span style="background:#d3f8b6">비트-스위치-이해-이미지</span>
			- 이미지 설명 =>
			- 4비트 상황 = 스위치가 4개인 상황
			- 스위치/비트 1개 당 표현할 수 있는 경우의 수 2가지.
			- 따라서 현재 4비트인 상황에서 표현할 수 있는 경우의 수/종류는 16개!
			- 
		- 1비트는 두 가지 상태(0 또는 1)를 나타낼 수 있습
		- 이는 하나의 비트가 표현 가능한 데이터의 '개수' 또는 '가능성'을 의미. 
		- 즉, 1비트에 의해 표현될 수 있는 값의 경우의 수/종류는 두 가지.
		- 
	- 메모리와 비트
		- 메모리에서 1비트의 용량은 그 메모리가 저장할 수 있는 정보의 최소 단위를 나타냅
			- 주의 : 1비트는 두 가지 가능한 정보 값을 저장할 수 있는 최소 단위로, 크기가 '2'를 의미하지는 않습
		- 1비트는 0 또는 1, 즉 두 가지의 다른 상태를 나타낼 수 있으므로, 메모리에서 1비트는 두 가지 가능한 상태를 저장할 수 있는 공간을 의미
		- = 1비트는 두 가지 상태를 표현할 수 있는 **용량**을 가진다고 이해
		- 
	- 요약 : 비트는 데이터 최소/기본 크기 단위 (데이터 포인트 1개..) 이지만, 이는 동시에 그 비트로 표현할 수 있는 데이터 값의 '경우의 수' 또한 나타냅. + 메모리 입장에선 1비트는 2가지 값 상태를 표현할 수 있는 용량을 가지고 있음을 의미
	- 
	- <span style="background:#d3f8b6">비트-진법-손풀이-이미지</span>
		- 이미지 설명 =>
		- 10진수로 표현된 512 숫자 존재
		- 특정한 진법으로 표현되어 있는 숫자는 `각 자리 숫자 x 해당 진법의 자리값` 끼리 더하면 해당 값이 나온다.
		- 
		- 이미지 설명 =>
		- 2진수로 표현된 1001 숫자 존재
		- `각 자리 숫자 x 해당 진법의 자리값` 끼리 더하면 1001 이진수 값에 대한 십진수 값을 파악 가능



##### - [[CPU-메모리저장된값-이용과정\|CPU-메모리저장된값-이용과정]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
    - 메모리 계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>



##### - [[저장장치-캐시계층-구조\|저장장치-캐시계층-구조]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- **캐시 메모리** 계층 존재
	- ==캐시 메모리? =>== | [[캐시메모리-성능-작동원리\|캐시메모리-성능-작동원리]]
	- 
	- 현재 대부분의 마이크로프로세서는 여러 레벨의 캐시(L1, L2, 때로는 L3까지)를 내장하고 있음
	- L1, L2, L3 캐시는 각기 독립적인 레벨의 캐시 메모리로 존재
	- 주의
		- 캐시 메모리는 L1, L2, L3과 같은 여러 레벨로 나눌 수 있지만, 반드시 모든 시스템이 이 세 가지 레벨을 모두 갖추고 있는 것은 아닙
		- 오래된 컴퓨터 시스템에서는 L1과 L2 캐시만을 사용할 수도 있고, 고성능 시스템에서는 L1, L2, L3 캐시를 모두 활용하여 데이터 처리 효율을 높일 수 있습
		- 
	- L1 캐시
		- 거의 모든 현대 프로세서에 존재하며, CPU 코어에 매우 가까워서 가장 빠른 액세스 속도를 제공
	- L2 캐시
		- L1보다는 느리고 크지만, 여전히 빠른 데이터 접근을 제공하여 CPU의 성능을 향상
	- L3 캐시
		- 주로 멀티코어 프로세서에서 볼 수 있으며, 여러 코어 사이에 데이터를 공유하는 데 도움을 줍
		- 
	- 
	- 다양한 형태-구조 캐시 메모리 존재 = 캐시 메모리 위치
		- CPU 내부에도 존재할 수 있고, 과거에는 CPU와 RAM 사이에 위치하는 외부 캐시로 구현
		- 현대의 컴퓨터 아키텍처에서는 주로 내부 캐시를 말합
		- 과거 컴퓨터 아키텍처에서는 CPU 외부에 별도의 캐시 메모리를 두는 경우가 더 흔했음 > 하지만 기술의 발전으로, 특히 반도체 제조 공정이 미세화되면서, 캐시 메모리를 CPU 칩 내부에 통합할 수 있게 되었습 > 내부 통합 캐시는 더 짧은 지연 시간과 빠른 접근 속도를 제공하며, CPU의 성능을 대폭 향상
		- 
		- <span style="background:#d3f8b6">계층적 캐시 메모리-이미지</span>
			- 
		- <span style="background:#d3f8b6">멀티코어 프로세서 캐시 메모리-이미지</span>
			- L3코어가 공유되는 형태
			- L1, L2 각각 코어에 존재
		- <span style="background:#d3f8b6">분리형 캐시 메모리-이미지</span>
			- 멀티코어 구조와 비슷하지만, L1 캐시 메모리가 분리된 구조



##### - [[플래시메모리-기반보조기억장치\|플래시메모리-기반보조기억장치]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 1. ==플래시 메모리(Flash Memory) 기반 보조기억장치==
	- ex) SSD(Solid State Drive), USB(Universal Serial Bus)
		- 
	- 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치 > 따라서 비플래시 메모리 즉, hdd와 모양이 많이 다름
		- 
	- 플래시 메모리(Flash Memory)
		- 플래시 메모리는 실제로 존재하는 물리적인 하드웨어 요소(물리적인 저장 매체) 이면서 동시에 그 하드웨어가 데이터를 저장하고 관리하는 '기술' 의미도 포함
		- 플래시 메모리의 핵심 기능은 데이터를 저장하는 것이며, 이러한 저장 기능은 다양한 형태와 용도로 전자 기기에서 구현
			- = 보조기억장치에만 한정되지 않는다는 점을 이해 = 범용성이 높다
			- ex) 휴대폰, 태블릿, USB 드라이브 등에서도 널리 사용
			- 
		- ==플래시 메모리를 이루고 있는 저장 단위/용어== => [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
		- 
	- 특징
		- 플래시 메모리에서는 비플래시-하드디스크와 달리 데이터를 직접 수정하거나 덮어쓰는 것이 불가능
			- = 수정된 새로운 데이터는 항상 새로운 공간에 저장
		- ~ 특징으로 인한 플래시 메모리에서 데이터를 업데이트할 때의 기본적인 동작 프로세스 - 상황예시
			- <span style="background:#d3f8b6">플래시메모리-가비지 컬렉션 과정-이미지</span>
			- 이미지 설명 =>
				- 한 칸 = 한 페이지 가정
				- 새로운 데이터 c 를 저장 = 블록 x 3번 페이지에 저장
				- 1번 페이지에 존재하던 A데이터를 수정을 진행. A > A' 
				- 따라서 1번 페이지에 존재하던 A데이터는 필요없는 값이 되어버림 = Invalid 상태
				- 가비지 컬렉션 진행
					- 1. 기존 x블록에 존재하는 유요한 페이지들만을 새로운 블록으로 복사
					- 2. 기존 x 블록 삭제
				- 
		- 이 과정을 통해 유효하지 않은 페이지는 지워지고, 해당 공간은 새로운 데이터 저장을 위해 다시 사용 가능해집 > 이러한 프로세스-과정은 메모리의 수명을 연장하고, 데이터의 무결성과 안정성을 보장
		- 시스템은 정기적으로 또는 필요할 때 'Invalid' 상태의 페이지를 정리하는 **가비지 컬렉션**을 수행
		- 가비지 컬렉션? =>
			- 유요한 페이지들만 새로운 블록으로 복사한 후 기본 블록을 삭제해 공간을 정리하는 기능/과정
			- 상황예시
				- 워드 문서를 편집하고 저장할 때를 생각
				- 처음 문서를 저장하면 해당 데이터는 플래시 메모리의 특정 페이지에 기록
				- 이후 같은 문서를 수정하고 다시 저장하면, 수정된 새로운 데이터는 새로운 페이지에 저장되고, 원래 페이지에 있던 데이터는 'Invalid' 상태가 됩
				- 즉, 원본 데이터는 여전히 메모리에 남아 있지만, 시스템은 그 데이터를 더 이상 유효한 정보로 인식하지 않습 이렇게 유효하지 않게 된 데이터는 나중에 가비지 컬렉션 과정에서 지워지게 됩
					- 
	- 플래시 메모리 종류
		- 1. NAND (넨드) 플래시 메모리
			- 대용량 저장 장치로 주로 사용 > 따라서 특별한 언급이 없다면 플래시 메모리는 넨드! 를 의미
		- 2. NOR 플래시 메모리


##### - [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==플래시 메모리를 이루고 있는 저장 단위/용어== 
	- <span style="background:#d3f8b6">플래시메모리-저장단위-용어-이미지</span>
	- 셀 (cell)
		- 플래시 메모리에서 데이터를 저장하는 가장 작은 단위
		- 예시를 통한 이해
			- 셀! : 데이터를 저장할 수 있는 공간/집
			- 비트! : 0과 1을 표현할 수 있는 사람 한 명
		- 셀들이 모여 MB, GB, TB 저장 장치가 됨
		- 하나의 셀에 몇 비트를 저장할 수 있는지에 따라서 **종류**가 달라짐 | [[비트(bit)용어\|비트(bit)용어]]
			- ==종류==? | [[플래시메모리-셀-종류-비트\|플래시메모리-셀-종류-비트]]
			- 
	- 데이터 저장단위/크기 단위
		- 1. 셀들이 모여 페이지(page)
			- 다양한 페이지 상태 표현 존재
				- 1. Free 상태
					- 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태
				- 2. Valid 상태
					- 이미 유요한 데이터를 저장하고 있는 상태
				- 3. Invalid 상태
					- 유효하지 않은 데이터(쓰레기 값)을 저장하고 있는 상태
		- 2. 페이지들이 모여 블록(block)
		- 3. 블록들이 모여 플레인(plane)
		- 4. 플레인들이 모여 다이(di)
		- 
	- 플래시 메모리 내부적인 특징
		- 데이터 읽기/쓰기 시 사용하는 기본 단위와 데이터 삭제 시 사용되는 기본 단위가 다르다
		- 읽기/쓰기는 페이지 단위로 이루어짐
		- 삭제는 블록 단위로 이루어짐 = 삭제 시 읽기/쓰기 보다 더 큰 단위로 삭제됨





##### - [[플래시메모리-셀-종류-비트\|플래시메모리-셀-종류-비트]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==종류==
	- 1. 한 셀에 1비트 저장 플래시 메모리 = SLC 타입 = 싱글 레벨 셀
		- 특징/장점
			- 하나의 셀에 1비트-정보 저장 가능 
				- = 하나의 셀로 두 개의 정보 표현 가능
				- EX) 1과 0 표현 가능
			- 1비트 저장으로 인한 빠른 입출력
				- 이해예시 :  하나의 공간/집에 1명만 살고 있으면 빠르게 밖으로 나갈 수 있음.
			- 긴 수명
			- 용량 대비 고가격
				- 이해예시 : 한 집에 혼자서 살고 있음. 따라서 혼자서 월세 내야함
				- 
	- 2. 한 셀에 2비트 저장 플래시 메모리 = MLC 타입 = 멀티 레벨 셀
		- 특징/장점
			- <span style="background:#d3f8b6">MLC타입-비트-이미지</span>
			- 하나의 셀에 2비트-정보 
				- = 하나의 셀로 4가지 정보 표현 가능
			- SLC보다 느린 입출력
				- 이해예시 : 하나의 공간/집에 2명이 살고 있으니 1명이 존재했을 때보다 느리게 나갈 수 있음
			- SLC보다 짧은 수명
				- 이해예시 : 입구에서 충돌이 발생하니까....
			- SLC보다 저렴
			- SLC보다 시중에서 많이 사용
				- SLC보다 저렴 + 더 많이 저장-표현이 가능하기 떄문
					- 
	- 3. 한 셀에 3비트 저장 플래시 메모리 = TLC 타입 = 트리플 레벨 셀
		- 특징/장점
			- 하나의 셀에 4비트-정보
				- = 하나의 셀로 8가지 정보 표현 가능
			- MLC보다 느린 입출력
			- MLC보다 짧은 수명
			- MLC보다 시중에서 많이 사용
				- 
	- 4. 한 셀에 4비트 저장 플래시 메모리 = QLC 타입 = 쿼드 레벨 셀
		- 
	- 종류에 따라서 메모리 **성능**, **가격**, **수명**이 달라짐.
		- <span style="background:#d3f8b6">다양한종류-셀-특징표-이미지</span>
	- 성능? =>
		- 셀 당 비트 수가 증가할수록 즉, SLC에서 QLC로 갈수록, 셀 내에서 데이터를 읽고 쓰는 **과정이 복잡**해집
		- 과정이 복잡? =>
			- 메모리의 읽기 및 쓰기 속도에 직접적인 영향을 미치며, 비트 수가 많을수록 처리 속도가 느려질 수 있습
	- 수명? =>
		- 셀의 수명은 주로 쓰기 **사이클**(데이터를 쓰고 지우는 횟수)에 의해 결정
			- = 셀이 견딜 수 있는 쓰기/삭제 작업의 횟수에 의해 결정되며, 이 횟수가 소진되면 메모리 셀이 더 이상 정상적으로 기능하지 못하게 됩
			- 사이클 횟수가 많다 = 셀이 한번에 처리/저장하는 양이 적다 = 셀이 받는 부하가 적다 = 수명이 길다 = 마모가 적다
			- 
			- "높은 데이터 쓰기 사이클을 지원한다"는 문장 존재
				- = 데이터를 저장하고 삭제하는 과정을 더 많이 견딜 수 있음을 의미
				- = 더 높은 내구성을 가진다는 것을 의미
				- = 메모리 수명이 더 길다는 것을 의미
			- 
		- SLC 메모리가 한 셀에 데이터를 한 비트만 저장 > 그 셀이 받는 부하가 적어 다른 유형의 메모리보다 더 많은 쓰기/삭제 작업을 견딜 수 있음
		- QLC 메모리는 한 셀에 더 많은 데이터를 저장 = 한 셀에 4비트를 저장
			- = 비트 수가 증가 > 표현할 수 있는, 한번에 처리할 수 있는 경우의 수 증가 > 메모리의 셀은 더 높은 수준의 전기적 스트레스와 복잡한 데이터 관리를 경험
			- = 셀 당 처리하는 정보량이 많기 때문에 더 민감하게 반응하여 더 빠른 성능 저하를 가져오고, 따라서 쓰기 사이클이 감소
		- 즉, QLC는 더 많은 데이터를 저장할 수 있지만, 이는 셀이 더 빨리 마모되는 원인이 되어 전체적인 메모리 수명을 단축
		- 
	- 가격? =>
		- 셀 당 비트 수가 증가하면 해당 메모리 셀이 더 많은 데이터를 저장할 수 있으므로, 이론적으로는 저장 용량이 늘어남 > 그렇다면 더 많은 데이터를 저장하면 더 비싸겠군! > X
		- 저장할 수 있는 데이터의 양이 메모리의 단가를 결정하는 유일한 요소는 X
		- 가격 결정에는 여러 요소가 작용
		- EX) 성능측면과 내구성 측면
			- QLC 메모리는 한 셀에 4비트를 저장할 수 있어 용량 대비 비용이 낮지만, 이는 성능과 내구성의 저하를 수반 > 수명이 짧음
			- SLC는 더 빠른 데이터 액세스와 높은 쓰기/지우기 사이클을 제공하기 때문에, 고성능을 요구하는 응용 프로그램에서 선호


##### ㅡ [[캐시메모리-성능-작동원리\|캐시메모리-성능-작동원리]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
			- 캐시
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==캐시 메모리? =>==
	- CPU 내부에 존재하는 레지스터보다 용량이 크고, 메모리보다 용량이 작지만 속도는 빠른 SRAM 기반 저장 장치
		- = 따라서 RAM에 존재하는 모든 내용을 미리 저장할 순 없다.
	- 캐시 메모리는 CPU가 실행 후 생성된 결과물 중 자주 사용되는 데이터를 **임시 저장**
	- 임시 저장? =>
		- CPU가 미래에 다시 접근할 가능성이 높은 데이터를 **예측**해 **미리 저장** 후 > 빠르게 제공하여 처리 속도를 향상시키고, 메인 메모리와의 데이터 전송 횟수를 줄이는 역할
		- 예측 > 미리저장? =>
			- 예측이 성공하면 캐시히트(Cache Hit 용어) 발생! 표현 사용
				- <span style="background:#d3f8b6">캐시히트-이미지</span>
					- 이미지 설명 =>
					- 예측이 성공한 상황 > 따라서 메모리까지 접근하지 x 
					- 상황예시
						- 자주 사용하는 값을 클라이언트가 서버에 데이터 요청 > 서버는 매번 응답 = 비효율
						- 웹 서버 자주 사용하는 데이터 클라이언트 측-캐시 저장 후 재요청 시 직접 반환 = 효율적
							- = 빈번하게 접근하는 데이터는 L1 캐시에 저장되어 빠르게 액세스할 수 있으며, 덜 접근하는 데이터는 L2 또는 L3 캐시에 저장됩
						- 자주 사용하는 값? =>
							- 정적 데이터/정적 자원
								- 웹 페이지 이미지
								- 스타일시트, 스크립트 
								- 
			- 예측이 실패하면 캐시 미스(Cache Miss 용어) 발생! 표현 사용
				- <span style="background:#d3f8b6">캐시미스-이미지</span>
			- 이러한 상황에서 사용하는 공식 존재 = 캐시 적중률!
				- 캐시 히트 횟수 / (히트 횟수 + 캐시 미스 횟수)
				- Long Tail 법칙 그래프 존재
				- 
			- 성능을 높인다! = CPU가 사용할 법한 데이터를 잘 예측한다
			- 참조 지역성의 원리 : CPU가 메모리에 접근할 때 주된 **경향성/패턴/규칙**을 바탕으로 만들어진 원리
			- 경향성 존재? =>
				- 1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
				- 2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다 = 공간 지역성
				- 
	- <span style="background:#d3f8b6">캐시메모리 존재이유-이미지</span>
	- CPU가 메모리에 접근하는 시간은 CPU 연산 속도보다 느리다.
	- CPU와 메인 메모리 사이의 데이터 전송 속도 차이/메모리 접근 시간/데이터 처리 속도를 완화하기 위한 방법 중 하나 = 중간에 캐시 메모리를 배치
		- = 이는 **프로세서의 성능**을 결정하는 중요한 요소 중 하나
		- ==프로세서(Processor) 성능? =>== | [[프로세서(Processor)-CPU-성능\|프로세서(Processor)-CPU-성능]]


##### ㅡ [[프로세서(Processor)-CPU-성능\|프로세서(Processor)-CPU-성능]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==프로세서(Processor) 성능? =>==
	- 프로세서는 그 프로그램을 실행하는 하드웨어 장치를 의미 
	- = CPU(Central Processing Unit)를 가리키는 용어로 사용
	- 
	- 각 용어는 프로세서 성능 향상의 다양한 이점을 나타내며, 비록 서로 연결되어 있기는 하지만, 각각이 강조하는 부분은 다릅
	- 1. **응답시간 단축:** 
		- 프로세서의 향상된 성능은 컴퓨터가 사용자가 입력한 명령어을 더 빠르게 처리하게 해, 사용자와 시스템 간의 상호작용이 빨라지게 합
		- 
	- 2. **로딩속도 향상:** 
		- 향상된 프로세서는 사용자가 입력한 명령어를 pc가 해석한 이후 작업인 = 메모리와의 데이터 교환을 더욱 빠르게 할 수 있어, 필요한 데이터나 애플리케이션의 로딩 시간이 단축
			- = 메모리와 데이터 교환 속도 = 데이터 처리 속도= 액세스 속도
			- = 사용자가 프로그램이나 파일을 더 빠르게 열 수 있게 합
		- 
	- 3. **서버 부하 감소:** 
		- 서버측 pc 성능 향상 이점.
		- 서버 내 프로그램을 동시에 처리할 수 있는 작업량이 증가
		- = 서버가 더 많은 사용자 요청을 처리할 수 있게 하고, 서비스의 가용성과 신뢰성을 높입


##### ㅡ [[컴퓨터구조-이미지\|컴퓨터구조-이미지]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 이미지
	- 전체구조도
	- 시스템버스
	- 시스템버스-cpu-작동예시
	- 메인보드-마더보드(mother board)-시스템보드(system board)
	- 중앙처리장치CPU-이미지
	- 주기억장치-RAM-메인메모리
	- <span style="background:#d3f8b6">보조기억장치-HDD-SSD</span>
	- 아두이노-라즈베리파이-이미지
	- 
- SSD (Solid State Drive)
	- <span style="background:#d3f8b6">SSD내부-이미지</span>
	- 전통적인 하드 드라이브보다 빠른 데이터 액세스 속도를 제공하는 저장 장치로, 여러 핵심 구성 요소를 포함
	- SSD 컨트롤러
		- SSD의 작동을 제어하며, 데이터 읽기/쓰기, 에러 수정, 웨어 레벨링 등의 작업을 관리
	- DRAM (Dynamic Random-Access Memory)
		- 데이터를 일시적으로 저장하여 SSD 컨트롤러가 빠르게 접근할 수 있도록 하는 버퍼 역할
	- 낸드 플래시 메모리 (NAND Flash Memory)
		- SSD에서 데이터를 영구적으로 저장하는 주요 구성 요소

##### ㅡ [[CPU-레지스터-작동과정예시\|CPU-레지스터-작동과정예시]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 1~4번 레지스터 작동과정 예시
	- <span style="background:#d3f8b6">1~4번 레지스터 작동과정-이미지</span>
	- 
	- 실행할 프로그램(명령어와 데이터들)이 메모리에서 1000번 ~ 1500번에 저장되어 있음
	- `프로그램 카운터`에 실행될 메모리 처음 위치가 저장됨
		- = 즉 1000번지에 존재하는 값이 필요함
	- (접근해야 하니까...)프로그램 카운터에 있던 주소 값이 `메모리 주소 레지스터`에 해당값이 복사된다 
	- 메모리 주소 레지스터에 저장된 주소위치는 `주소버스`를 통해 메모리로 전달 + 동시에 제어장치에서 생성된 제어신호는 `제어버스`통해 메모리로 전달
	- 메모리가 주소값+명령-제어신호를 받은 후 명령어대로 1000번지에 저장된 값을 CPU쪽으로 `데이터버스`를 통해 보내준다. = `메모리 버퍼 레지스터`에 보내준다. 
	- 위 작업/메모리에서 보내진 값이 `메모리 버퍼 레지스터`에 저장이 되면 동시에 다음작업 수행을 위해 `프로그램 카운터`에 있던 값을 증가시킨다. (순차적인 실행 흐름위해)
	- 메모리 에서 받은 값이 `명령어 레지스터`에 할당된다. 즉 1000번지에 존재하던 값이 해당 레지스터에 할당된다.
	- 순차적인 실행 흐름? =>
		- 순차적인 실행 흐름이 끊기는 경우 존재
			- 1. 인터럽트(Interrupt) 발생 시
				- 인터럽트 용어
					- 1. **인터럽트 과정**: 
						- 이는 CPU가 현재 실행 중인 프로세스나 작업을 일시적으로 중단하고, 더 높은 우선순위를 가진 작업을 처리하고 이 작업이 완료되면, CPU는 원래 수행 중이던 작업으로 돌아가 계속 수행 과정/매커니즘을 의미
						- 이 과정은 시스템의 효율성과 반응성을 향상
							- = 특정한 신호나 사건에 반응하여 시스템의 응답성과 효율성을 높이는 추상화된 용어
							- =  하드웨어 또는 소프트웨어에 의해 발생하는 이벤트에 대응하는 CPU의 작동 방식을 지칭하는 용어
							- =  CPU가 다양한 태스크와 요청 사이에서 멀티태스킹을 수행하는 과정을 묘사하는 용어
							- 
					- 2. **인터럽트 신호**: 
						- 인터럽트는 또한 CPU에게 현재 작업을 중단하라고 알리는 전기적인 신호로도  이해 가능
						- 이 신호는 하드웨어 장치나 소프트웨어 프로그램에서 발생
				- 
			- 2. (일반적인 상황) 프로그램 내 실행 흐름 변경:
				- 이는 프로그래머가 프로그램의 논리에 따라 의도적으로 실행 순서를 변경하는 경우
				- EX) 프로그래밍 언어(고급언어)로 조건문 작성을 통해 실행 순서 변경하는 상황
				- 위 예시 내부과정 이해 =>
					- <span style="background:#d3f8b6">파이썬 예시코드</span>
						- 파이썬 코드는 실행될 때, 파이썬 인터프리터에 의해 내부적으로 CPU가 이해할 수 있는 명령어로 변환되고 있음
						- `a > b`가 참일 경우: (CONDITIONAL JUMP) 저수준 명령어 실행되어 > "a is greater"를 출력하는 코드의 위치로 점프
						- 즉, 내부적으로 이러한 점프가 있기에 프로그램의 실행 흐름을 적절하게 제어가 되고 있던 것
					- 파이썬과 같은 고급 언어로 조건문을 작성할 때 내부적으로는직접 저수준 명령 코드를 작성하지 않지만, 컴파일러나 인터프리터는 그러한 조건문을 저수준의 명령어로 변환
					- 저수준 명령어? =>
						- JUMP, CONDITIONAL JUMP 등이 포함
						- 일반적인 사용자나 개발자는 파이썬과 같은 고급 프로그래밍 언어를 사용할 때, 그 언어의 문법과 코드 표현식을 이해하고 사용할 줄 알면 충분 =  사용자가 저수준의 명령어를 직접 다루지 않아도 됨. 이 모든 저수준 작업은 파이썬 인터프리터에 의해 추상화되어 처리됩
					- 왜? 
						- 파이썬과 같은 고급 프로그래밍 언어로 작성된 코드는 컴퓨터에서 직접 실행될 수 있는 형태가 아님
					- 주의
						- 이 과정에서 실제 메모리 주소가 변경되는 것은 아니고, `프로그램 카운터`가 가리키는 명령어의 위치가 변경되는 것
							- = 조건문 실행 시 이 프로그램 카운터의 값이 변경되어 다음에 실행할 명령어의 위치를 결정


##### ㅡ [[다양한종류-레지스터\|다양한종류-레지스터]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==다양한종류-레지스터==
	- : 각각 다른 역할/기능 수행 = 각각 다른 종류 데이터 저장
	- ==1~4번 레지스터 작동과정 예시== | [[CPU-레지스터-작동과정예시\|CPU-레지스터-작동과정예시]]
	- 
	- 1. 프로그램 카운터(Program Counter, PC)
		- CPU가 다음에(미리..) 실행할 명령어/메모리에서 가져올 명령어 주소 저장
			- = 현재 실행 중인 명령어의 주소를 가리키며, 프로그램의 실행 흐름을 관리하는 데 사용
	- 2. 명령어 레지스터(Instruction Register, IR)
		- 현재 실행 중인 명령어를 저장
		- 메모리에 존재하는 명령어들의 주소를 저장 = 제어장치가 해석할 명령어 저장
	- 3. 메모리 주소 레지스터(Memory Address Register, MAR)
		- CPU가 데이터를 저장 OR 사용하던 특정 메모리 위치에 접근할 필요가 있을 때, 그 위치의 주소 정보를 MAR에 저장
		- 메모리 컨트롤러는 이 주소를 사용하여 해당 메모리 위치와 데이터를 교환
		- MAR은 메모리와 CPU 사이의 데이터 통신을 원활하게 하기 위해 필수적인 레지스터
	- 4. 메모리 버퍼 레지스터(Memory Buffer Register, MBR) 또는 메모리 데이터 레지스터(Memory Data Register, MDR
		- 메모리에서 읽은/가져온 데이터나 메모리에 쓸 데이터를 임시로 저장하는 역할
		- 예시상황
			- CPU입장에서 데이터를 보낸다 = 데이터를 쓴다 = 메모리입장에선 데이터를 받는다
				- 반대로, CPU가 데이터를 메모리에 쓸 때, 그 데이터는 먼저 MBR/MDR에 저장된 후, 해당 메모리 주소로 전송됩
			- CPU입장에서 데이터를 받는다 = 데이터를 읽는다 = 메모리입장에서 데이터를 보낸다.
				- CPU가 메모리에서 데이터를 읽을 때, 해당 데이터는 먼저 MBR/MDR에 저장되고, 이후 CPU로 전송됩
	- 5. 상태 레지스터(Status Register) 또는 플래그 레지스터(Flag Register): 
		- 기존기록 확인
	- 6. 범용 레지스터(General Purpose Registers)
		- 프로그램 내에서 다양한 용도로 사용 = 범용 레지스터는 그 활용도가 훨씬 넓고 유연 = 다른 레지스터 기능들 범용적 수행
		- 다양한 용도? =>
			- 데이터 저장, 중간 계산 결과의 보관, 주소 계산, 루프 카운팅 등 
			- 다양한 데이터와 메모리에서 가져올 명령어 주소 값을 임시로 저장 사용
	- 7. 스택 포인터(Stack Pointer, SP)
		- 기존노트 확인 : [[자료구조-용어\|자료구조-용어]]
	- 8. 베이스 레지스터
		- ==유효한 메모리 주소에 접근하기 위한 두 가지 방식== | [[유효한메모리주소-접근방식\|유효한메모리주소-접근방식]]


##### ㅡ [[RAM메모리-작동원리-성능\|RAM메모리-작동원리-성능]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==RAM의 기본적인 작동 원리==
	- 데이터 상호작용 순서 =>
	- 1. CPU(연산처리 진행) <> 2. RAM (실행할 대상/프로그램 존재) <> 3. 보조기억장치 (보관할 대상/프로그램 존재)
	- 상황예시
		- 사용자가 컴퓨터에서 'a'라는 프로그램을 실행
		- 운영 체제는 보조기억장치에서 'a' 프로그램을 찾는다
		- 프로그램 'a'는 보조기억장치에서 RAM으로 복사 = 프로그램의 코드와 필요한 데이터가 메모리로 옮겨집 > (프로그램을 종료하면 RAM의 해당 작업 공간은 비워진다)
		- CPU는 RAM에서 'a' 프로그램을 읽어서 명령어를 처리하기 시작
		- 즉,  보조기억장치에 있는 프로그램을 실행할 때, 그 프로그램은 **RAM으로 복사됨** > 이는 실행 중인 프로그램이 빠르게 데이터에 접근하고 처리할 수 있게 해 주며, 보조기억장치에서는 해당 프로그램이 사라지지 않고 그대로 유지
		- RAM으로 복사됨? =>
			- <span style="background:#d3f8b6">RAM용량-성능-이미지</span>
				- : 보조기억 장치는 3개의 프로그램을 가지고 있는 상태. 하지만 RAM은 용량이 작아 1개만 가지고 있을 수 있는 상태 > RAM 용량-사이즈가 커지면 한번에 많은 프로그램을 가지고 있을 수 있는 상태
				- 
			- 따라서 한 번에 여러 프로그램을 실행하거나 무거운 프로그램을 실행하려면 **RAM 용량**이 높아야 한다. (한 번에 여러 프로그램 = 많은 공간)
			- 실행하고 있는 프로그램(명령어+데이터)가 RAM 위에 저장/할당/복사 된 상태
			- RAM 용량? =>
				- RAM의 용량이 크다 = 성능이 좋다


##### ㅡ [[RAM-종류\|RAM-종류]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==RAM 램의 종류==
	- 크게 4가지 존재.
	- 
	- 1. DRAM(Dynamic RAM) = 디램
		- 특징/장점/단점
			- 디램이 가진 장점으로 인해 일반적으로 메모리에 많이 사용됨
			- 메모리 셀에 데이터를 저장하기 위해 커패시터와 트랜지스터를 사용
			- 커패시터는 전하를 저장하는 방식. > 시간이 지남에 따라 **누설**되어 그 전하를 잃게 되는 특징 존재 (저장된 데이터가 동적으로 사라짐) > 이 때문에 DRAM은 저장된 정보를 유지하기 위해 주기적으로 새로 고쳐줘야 하는데, 이 과정을 "**리프레시(refresh)**"라고 함
			- 새로 고쳐준다? =>
				- DRAM의 각 셀에는 1비트의 데이터를 저장하기 위해 한 개의 커패시터와 한 개의 트랜지스터가 사용
				- 데이터는 커패시터에 전하의 형태로 저장되며, 전하의 유무로 1과 0을 표현
				- "정보를 고쳐준다"는 말은 커패시터에 전하를 다시 충전하여 데이터를 원래의 상태로 유지시키는 행위를 의미
			- 전하 누설? =>
				- DRAM 특성 상 사용하는 커패시터는 지속적으로 전하를 잃는다. 즉, 전원이 켜져 있는 동안에도 커패시터의 전하 누설로 인해 데이터가 점차 사라지기 때문에, 전원 공급 중이더라도 주기적으로 리프레시(재활성화)가 필요
				- = SRAM과 차이점 : 구조적 차이로 인해 전원 공급 중 데이터가 안정적으로 유지
				- 
	- 2. SRAM(Satic RAM) = 에스램
		- 특징
			- 전원이 공급되는 한 저장된 데이터가 사라지지 않는 RAM
			- DRAM보다 일반적으로 빠른 속도 > DRAM보다 가격이 높다
			- 주로 캐시 메모리에서 사용
			- 
	- Q. DRAM <> SRAM 어떤 것을 사용?
		- <span style="background:rgba(205, 244, 105, 0.55)">D-S-RAM표-이미지</span>
		- DRAM과 SRAM은 각각의 요구상황과 해당 RAM이 가진 특성을 고려하여 선택
		- 1. 비용 효율성 차이
			- DRAM은 SRAM보다 훨씬 비용 효율적
			- = "소비전력이 낮다"는 장기적으로 "비용적으로 효율적이다"같은 의미
			- 왜?
				- SRAM을 구성하는 데는 더 많은 트랜지스터가 필요하며, 이로 인해 SRAM은 같은 양의 데이터를 저장하기 위해 DRAM보다 더 많은 공간을 차지하고 더 비쌉 
				- = 대량의 메모리가 필요한 시스템에서는 DRAM이 훨씬 경제적
				- 
		- 2. 밀도의 차이
			- "밀도가 높다"는 표현은 물리적 공간 대비 데이터를 저장할 수 있는 용량이 크다는 것을 의미하며, "집적도가 높다"는 같은 양의 공간에서 더 많은 데이터를 저장할 수 있다는 것을 의미. 따라서 같은 맥락에서 사용
			- DRAM은 SRAM에 비해 더 높은 데이터 밀도를 제공. > 이는 DRAM이 더 적은 공간을 사용하여 더 많은 데이터를 저장할 수 있음을 의미
				- = 대용량 메모리를 필요로 하는 응용 프로그램에서 DRAM이 선호
				- 
		- 3. 용도의 차이 
			- SRAM은 그의 빠른 접근 속도 덕분에 캐시 메모리 같이 빠른 데이터 접근이 필수적인 상황에 주로 사용 
			- DRAM은 시스템의 주 메모리와 같이 큰 용량이 요구되지만 접근 속도가 SRAM만큼 민감하지 않은 경우에 사용
			- 
	- 3. SDRAM (Synchronous DRAM) - 에스디 
		- = SDR(Single Date Rate) SDRAM 표현 가능
		- 발전된 형태의 DRAM
		- = 클럭 신호화 동기화된 DRAM 표현 가능
		- 
	- 4. DDR SDRAM (Double Data Rate SDRAM)
		- <span style="background:rgba(205, 244, 105, 0.55)">SDR과 DDR 차이점-이미지</span>
		- 의미/특징
			- 최근 가장 대중적으로 사용되는 RAM 종류 중 하나
			- 발전된 형태의 SDRAM = **대역폭**을 넓혀 속도를 빠르게 만든 SDRAM
			- 대역폭이란? =>
				- 데이터를 이동 시 주고 받는 길의 너비  > 너비가 클수록 한번에 주고받을 수 있는 데이터 양이 많다진다 =  속도가 빨라진다
		- DDR2 SDRAM도 존재
			- <span style="background:rgba(205, 244, 105, 0.55)">SDR-DDR2-차이점-이미지</span>
			- DDR SDRAM 의미 생각 > 2의 제곱승으로 성능이 좋아짐
			- EX) 2 > 4 > 8 > 16 ....


##### ㅡ [[HDD구성요소\|HDD구성요소]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==HDD-구성요소== => 
- <span style="background:#d3f8b6">HDD구성요소-이미지</span>
	- 플래터(platter)
		- 비 자성체인 비금속 원판 표면에 자성체인 산화 금속 막을 양면에 도장한 것
		- 산화 금속의 막을 논리적으로 나눈(partitioning)뒤 위치를 지정(formatting)하면 정보를 저장할 수 있게 됩
		- 플래터 양면 모두 사용
		- 
		- 플래터에 존재하는 저장 단위 =>
			- 하나의 플래터는 `트랙`과 `섹터`-저장단위를 나눌 수 있음
			- 여러 플래터가 모여 + 같은 트랙들이 모이면 `실린더`! 저장단위로로 나눌 수 있음
			- 
			- <span style="background:#d3f8b6">섹터-트랙-실린더-이미지</span>
			- 트랙, 섹터 (Track, Sector)
				- 하드디스크 기록 단위의 하나로 자기 매체에 늘어선 동심원으로 구획된 하나하나를 트랙이라 부르고 그 트랙들은 다시 섹터로 나뉘게 됩
				- 섹터(sector)와 트랙(track) 단위로 데이터를 저장
				- 섹터의 크기 : 512 바이트 ~ 4096 바이트
				- 하나 이상의 섹터를 묶어 블록(block)이라고 표현하기도 함
			- 실린더(cylinder)
				- 여러 겹의 플래터 상에서 같은 트랙이 위치 한 곳을 모아 연결한 논리적 저장 단위
				- 연속된 정보는 한 실린더에 기록된다.
				- 왜?
					- 복기 - `헤드는 같이 움직인다`
					- 하나의 실린더에 연속된 데이터를 저장하면 헤드를 움직이지 않고 바로 데이터를 읽/쓸 수 있음
					- 
	- 스핀들(Spindle)
		- 플래터가 회전할 수 있도록 모터와 직접 연결된 축
		- 플래터를 일정한 속도로 회전시키는 장치인 모터가 존재 하고, HDD용 모터는 스핀들에 직접 연결이 되어 있음 = "스핀들 모터"
		- RPM 용어 : 분당 회전수
		- 플래터를 축에 단단히 고정을 시킵
		- 스핀들에 여러장의 플래터를 설치할 경우에는 플래터 사이에 지름이 1.25" 두께 1/8" 의 스페이서(Spacer)를 넣어서 함께 고정
		- 
	- 헤드(Head)
		- 플래터 표면에 정보를 저장 또는 삭제를 하는 장치 또한 저장된 정보를 읽는 역할
		- 일반적으로 해더의 수는 플래터의 수의 2배
		- 왜?
			- 플래터는 양면이기 때문에 한장의 플래터는 2개의 면으로 되어 있기 때문에 각면에 하나씩 해서 헤드가 2개가 필요. 즉, 3장의 플래터로 구성된 하드디스크는 6개의 헤드가 필요
			- 
	- 헤드 구동 장치(Actuator)
		- 주의 
			- 헤드 구동 장치(actuator)는 디스크암을 포함하는 더 큰 시스템.
			- 즉, 디스크암은 헤드 구동 장치의 중요한 부분 중 하나이지만, 전체 헤드 구동 장치 시스템을 단순히 '디스크암'이라고 부르는 것은 그 기능과 구성을 완전히 설명하지 않음
			- 헤드 구동 장치는 디스크암을 움직여서 HDD 내부의 읽기/쓰기 헤드가 디스크 표면 위에서 정확한 위치로 이동할 수 있도록 합
			- 
		- 액츄에이터 라고 불리는 장치는 헤드를 움직이는 장치
		- HDD 회로 기판으로 부터 제어신호를 받으면 actuator용 구동장치는 헤드가 부착된 암을 지정한 위치 까지 이동 시킵


##### ㅡ [[HDD작동원리-데이터접근과정\|HDD작동원리-데이터접근과정]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==HDD작동원리-데이터접근과정==
	- 하드 디스크의 작동원리
		- 하드디스크의 자성 물질로 덮인 플래터를 회전 시키고, 그 위에 헤드를 접근시켜 플래터 표면 자기 배열을 변경하는 방식으로 데이터를 읽거나 쓴다.
		- = 전자기 기술을 사용해 데이터를 저장
		- 
		- 플래터의 중심에는 플래터를 회전 시키기 위해서 `스핀들 모터`가 있고, 스핀들 모터의 회선속도(RPM)가 높을 수록 더욱 빠르게 데이터를 읽고 쓸 수가 있다. 허나 소음과 진동이 발생하는 단점 발생
		- `헤드`는 실제로 플래터와 접촉을 하고 있는 것이 아니고 표면에 살짝 더있는 상태로 데이터를 읽거나 쓴다. 따라서 하드 디스크가 동작하는 도중에 외부에서 충격이 가해지거나 갑자기 전원이 차단되면 헤드가 플래터의 표면을 긁어서 고장 나기도 합
		- 
	- HDD-데이터 접근 과정
		- 하드 디스크에 저장된 데이터를 읽거나, 저장할 때 보통 **3개의 시간**이 소요됨
			- = 하드 디스크가 저장된 데이터에 접근하는 시간
		- 3개의 시간? =>
			- 1. 탐색시간(seek time)
				- <span style="background:#d3f8b6">탐색시간-이미지</span>
				- 필요한/접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
				- ex) 0번 트랙 존재하던 헤드 > 1번 트랙으로 이동
				- 
			- 2. 회전지연(rotational latency)
				- <span style="background:#d3f8b6">회전지연-이미지</span>
				- 헤드가 있는 곳으로 플래터-섹터를 회전시키는 시간
				- 
			- 3. 전송시간(transfer time)
				- <span style="background:#d3f8b6">전송시간-이미지</span>
				- 헤드와 해당 데이터가 저장된 섹터가 만난 이후 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간
				- 
		- <span style="background:#d3f8b6">Jeff-시스템성능-접근시간표-이미지</span>
			- 이미지 설명 =>
			- Jeff Dean - numbers every programmer should know (모든 프로그래머가 알아야 하는 기본적인 숫자들)
			- ns(나노초) 단위 존재
			- 패킷 : 네트워크 기본 전송 단위
			- 해당 표에 나와있는 시간 단위/HDD 데이터 접근 과정시 발생하는 시간 작아 보이더라도 전체적인 관점/컴퓨터 시스템에서 발생하게 되는 시간들에 비해서 굉장히 큰 시간이라고 표현 가능
			- 
			- CPU와 가까울 수록 빠름
				- = 내부 메모리 접근 시간이 네트워크를 통한 접근 시간보다 훨씬 빠르다
				- = Jeff Dean의 숫자에 따르면 메모리에 데이터를 읽는 데는 일반적으로 몇 십 나노초가 걸리지만, 네트워크를 통해 데이터를 보내는 데는 수십 밀리초가 소요될 수 있음
				- 
			- 상황예시
				- 웹 어플리케이션을 개발할 때 데이터베이스 응답 시간을 최적화하고자 할 때, 이러한 숫자들을 참고하여 로컬 메모리 접근이 네트워크 요청보다 월등히 빠르다는 것을 확인하고  설계-캐싱 전략을 구현
				- 즉,  웹 애플리케이션에서 자주 요청되는 데이터를 로컬 메모리에 캐싱하는 것은 네트워크를 통해 서버로부터 매번 데이터를 가져오는 것보다 훨씬 빠르고 효율적 = 서버의 부하를 줄이고 응답 시간을 단축시켜 사용자 경험을 향상
		- Jeff Dean이 제안한 컴퓨터 시스템의 성능 측정을 위한 기준 숫자 존재 > 소프트웨어를 설계하거나 문제를 해결할 때 참고해야 할 중요한 시스템 연산과 네트워크 지연 시간에 대한 기준점를 제공함
			- = 데이터를 어디에 저장하고 접근하는 것이 효율적인지를 판단하는 데 도움



##### ㅡ [[유효한메모리주소-접근방식\|유효한메모리주소-접근방식]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
	    - 레지스터, 캐시
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==유효한 메모리 주소에 접근하기 위한 두 가지 방식== | [[유효한메모리주소-접근방식\|유효한메모리주소-접근방식]]
	- 메모리 주소 접근하는 방식이 존재하는 이유?
		- 메모리에 연속적으로 저장된 데이터에 대해 유연하고 동적으로 접근할 수 있게 하는 것 > 이 방식을 통해 프로그램은 실행 시점에 데이터 구조 내의 특정 요소에 효율적으로-유연하게 접근 가능
			- = 메모리에 접근하는 유연성을 향상시키는 방식
		-  이 방식은 프로그램의 시작점 또는 기준이 되는 주소에 변위(오프셋) 값을 더하거나 빼서 원하는 메모리 위치에 접근. 즉, 레지스터에는 기준이 되는 주소 1개만 저장 > 변위값을 이용해 각각에 접근
		- 모든 주소를 고정하여 저장하는 것보다 메모리를 더 효율적으로 사용
			- = 프로그램을 더 동적으로 만들며, 재사용성과 유지 보수성을 개선
		- 모든 주소를 있는 그대로 저장하는 방식 사용? =>
			- 여러 가지 제약사항과 단점이 발생
			- 모든 주소값을 사전에 알고 있어야 하며, 프로그램이 런타임에 데이터 구조의 크기나 위치가 변경되었을 경우 이를 적절히 처리할 수 없습
				- = 동적으로 접근 X 
				- = 유연성 X 
			- 프로그램이 특정 메모리 주소에 고정되어 있기 때문에, 코드의 재사용성이 떨어지고 유지 보수가 어려워집
			- 프로그램이나 데이터 구조의 확장이 필요할 때, 모든 관련된 주소 참조를 업데이트해야 하는 번거로움
			- 상황예시
				- 배열이나 리스트와 같은 연속된 메모리 구조에서 시작 주소만 알고 있으면, 그 시작 주소에 인덱스와 데이터 타입의 크기를 곱한 값을 더해 각 원소에 접근 가능
				- 이렇게 하면, 데이터 구조의 크기가 변경되거나 다른 메모리 위치로 이동해도 동일한 접근 방식을 유지할 수 있습
				- 
	- <span style="background:#d3f8b6">메모리주소-접근방식-이미지</span>
		- : 어떤 방식을 사용하는지에 따라 어떤 레지스터가 사용될지 달라짐
		- 
	- : 두 방식은 모두 메모리 주소를 동적으로 계산하는 방법이지만, 사용되는 기준점이 다릅
	- 변위 주소 지정은 특정 베이스 주소로부터의 오프셋을 이용하는 반면, 상대 주소 지정은 현재 코드의 위치나 명령어의 위치를 기준으로 한 오프셋을 사용
	- 
	- 1. 변위 주소 지정 방식(Displacement-Addressing)
		- <span style="background:rgba(205, 244, 105, 0.55)">베이스레지스터-동작과정-이미지</span>
			- ex) 50일 경우 > 기준/처음 위치에서 얼만큼 떨어져서...
		- 베이스 주소(또는 시작 주소)에 변위(또는 오프셋) 값을 더해 최종 주소를 계산
		- 상황예시
			- 배열이나 구조체에서 특정 요소에 접근할 때, 배열의 시작 주소가 베이스 주소가 되고, 배열 내에서의 요소 위치가 변위 값이 됩
			- 
		- 베이스 레지스터는 프로그램 실행 중 사용되는 데이터나 명령어의 주소를 기준으로 삼아 다른 메모리 접근을 용이하게 하는 데 사용
			- = 베이스 레지스터에 저장된 주소를 기반으로 하여, 인덱스 레지스터의 값(배열의 인덱스 등)과 변위값을 더해 최종적인 유효한 메모리 주소를 계산
			- = 현재 코드의 위치를 기준으로 다른 코드 또는 데이터의 위치를 찾는 방식
			- = 베이스 레지스터 값은 기준 역할 수행 (실제 메모리에서 프로그램 시작점/기준점 물리주소 존재)
			- 변위? =>
				- 주어진 기준점(베이스 레지스터의 값)으로부터 얼마나 떨어진 위치인지를 나타내는 값
				- 
	- 2. 상대 주소 지정 방식(Relative Addressing)
		- <span style="background:rgba(205, 244, 105, 0.55)">
		상대주소 지정방식-이미지</span>
			- 
		- 상대 주소 지정 방식에서는 현재 주소나 실행 중인 명령어의 주소를 기준으로 하여 메모리 주소를 계산
		- 상황예시
			- `프로그램 카운터(PC)`가 현재 실행 중인 명령어의 주소를 가리킬 때, 상대 주소는 이 PC 값을 기준으로 하여 다음에 실행할 명령어의 위치를 결정
			- 프로그램 카운터 레지스터 기존기록 복기!


##### ㅡ [[CPU-근첩순서-메모리계층-접근속도\|CPU-근첩순서-메모리계층-접근속도]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
    - 메모리 계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:rgba(205, 244, 105, 0.55)">메모리계층-이미지</span>
	- 1. 레지스터 (Registers)
	- 2. 캐시 메모리 (Cache Memory)
		- L1 캐시: CPU 내부, 가장 빠른 접근.
		- L2 캐시: CPU에 가까움, L1보다 느린 접근.
		- L3 캐시: CPU에 가까우나 L1, L2보다 느리고 더 큰 용량.
	- 3. 메인 메모리 (Main Memory or RAM)
	- 4. 보조 메모리 (Secondary Storage)


##### ㅡ [[제어장치-제어신호\|제어장치-제어신호]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==제어장치== 
	- <span style="background:#d3f8b6">제어장치-신호발생-이미지</span>
	- : 제어신호 발생 > 각 부품들에게 전기적인 제어신호를 보내는 기능 + 명령어를 해석하는 기능
	- 
	- 컴퓨터 부품들을 동작시키기 위해선 크게 2가지 신호를 생성.
		- 1. ~ 위해 ~ 데이터가 필요하니 메모리 "읽기 신호" 보낸다!
			- 데이터 필요하다 = 접근하다 = 읽는다 = 사용하다
		- 2. ~위해 ~ 데이터가 저장되어 있어야 하니 메모리에 "쓰기 신호"를 보낸다!
			- 데이터를 저장하다 = 메모리에 쓴다 = 적재한다 = 위에 올린다 = 할당한다
			- 
	- 컴퓨터 부품들을 동작시키기 위해 크게 2가지 방향으로 신호를 보낸다.
		- 1. CPU 내부쪽으로 전달되는 제어신호
			- 1. 레지스터 전달
			- 2. ALU 전달
		- 2. CPU 외부쪽으로 전달되는 제어신호
			- 1. 메모리 전달
			- 2. 입출력장치 전달
				- 동작을 지시하는 제어 신호
				- 
	- 신호를 받는다.
		- 1. 명령어 레지스터에서 해석할 명령어를 받아들임
			- 명령어를 받아들이고 해석해야 기능수행/연산에 필요한 값들에 대한 제어신호를 발생 > 보낼 수 있음
		- 2. 플래그 레지스터에서 플래그 값을 받아들임
		- 3. 제어신호를 받아들임
			- 제어장치가 주로 제어 신호를 발생시키는 주체지만, 다른 구성 요소들도 특정 상황에서는 제어 신호/상태 신호를 발생시킬 수 있음.
			- 상황예시
				- 메모리가 데이터 읽기/쓰기 작업을 완료했을 때 완료 신호를 CPU에 보내거나, I/O 장치가 데이터 전송 준비가 되었음을 알리는 신호를 보낼 수 있음
		- 4. 클럭 신호 존재 
			- 클럭신호? =>
			- <span style="background:#d3f8b6">클럭-이미지</span>
			- 이해를 위한 상황예시
				- 클럭 신호를 학교의 종소리에 비유
				- 학교에서 종이 울리면, 모든 학생과 선생님이 무엇을 해야 하는지 알게 됩 > 수업 시작이다! 공부시작 , 쉬는 시간이다! 공부 마무리! 
				- 즉, 종소리는 '지금 이 시간에 해야 할 일'을 모두에게 알려주는 신호
				- 
			- 클럭 신호는 CPU 내부의 모든 부품에 '지금 이 순간 무엇을 시작하거나 끝내야 하는지'를 알려줍 > 즉 클럭 신호는 컴퓨터 내의 각 부품이 작업을 언제 시작하고 마무리해야 하는지를 알려주는 타이밍 신호
			- EX)
				- 클럭 신호가 한 번 발생할 때마다 CPU 내의 부품들은 다음 단계의 작업을 시작! OR 현재 단계의 작업 마무리!
				- 
			- 클럭 신호 존재 이유
				- 클럭 신호가 존재해야 각 부품이 동기화되어 함께 작동하면서 컴퓨터는 명령을 처리하고, 프로그램을 실행됨.
				- CPU 내의 모든 구성 요소들이 정확히 동기화되어 함께 작동해야 컴퓨터는 효율적으로 데이터를 처리하고 명령을 실행 가능
					- = 클럭 신호 없이는 컴퓨터의 다양한 부품들이 서로 조화롭게 작동하기 어려움. 즉, 작업을 시작하는 타이밍이 모두 일치해야 효율적





##### ㅡ [[ALU-산술논리장치-플래그레지스터\|ALU-산술논리장치-플래그레지스터]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==ALU-산술 논리 장치==
	- : 계산기와 같은 연산 기능 수행
	- 
	- <span style="background:#d3f8b6">ALU 받아들이는 정보-이미지</span>
	- 레지스터로부터 피연산자 값을 받아들이고 제어장치로부터 제어신호를 받아들임
	- 상황예시
		- 연산을 수행하기 위해선 연산자!와 피연산자! 값 필요 (데이터와 명령어 필요)
		- 1 + 2 연산 수행 상황
			- 1 피연산자, 2 피연산자, + 연산자
		- 
	- ALU 내보내는 정보
		- ALU는 연산의 결과를 내보낼 때, 그 결과에 대한 추가적인 정보를 제공하는 플래그 값을 플래그 레지스터에 전달
		- 플래크 (flag)? =>
			- 연산결과에 대한 부가정보/연산결과의 특정 특성을 나타내는 비트로 구성
			- 컴퓨터가 다음 연산을 어떻게 처리할지 결정하는 데 중요한 정보
				- = 플래그 레지스터의 정보가 CPU 결과 값의 해석에 핵심적인 역할을 하며, 특히 부호 플래그는 결과가 양수인지 음수인지를 나타냅
			- 중요한 정보, 핵심적인 역할? =>
				- <span style="background:#d3f8b6">플래그 레지스터 내부-이미지</span>
					- EX) 플래그 레지스터 내부-부호플로그에 1이 존재 > 해당 값은 음수!
				- 컴퓨터는 모든 데이터를 이진수 형태로 처리 함. 하지만 이진수 형태의 데이터만으로는 값의 부호를 직접적으로 알 수 X =  이진수 자체는 부호 정보를 내포하고 있지 X 
					- EX) 0101(2) 해당 이진수 값은 +5? -5?
				- 예를 들어, 연산 결과의 부호(양수 또는 음수), 제로(결과가 0인지 여부), 오버플로우(연산 결과가 처리 가능 범위를 초과했는지 여부) 등을 나타냅
			- 플래그(값) 종류 다양
				- <span style="background:#d3f8b6">다양한 플래그 값 표-이미지</span>
					- 부호 플래그
					- 제로 플래그
					- 캐리 플래그
					- 오버플로우 플래그
					- 인터럽트 플래그
					- 슈퍼바이저 플래그


##### ㅡ [[자료구조-용어\|자료구조-용어]]
- 1. **컴퓨터 구조** - 큰 개념
    - 메모리 계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 자료구조(Data Structure) 용어
	- : 데이터를 메모리에 어떻게 효율적으로 저장하고 접근할지를 방법을 정의한 개념 > 따라서 프로그래밍 시 적절한 자료구조를 활용해 메모리 내 데이터를 최적화해서 저장-관리해야함
		- = 프로그래밍 시 데이터를 관리하는 방식을 결정
	- 주의
		- 메모리 내 특정 '영역'이 사전에 자료구조 유형별로 지정되어 있는게 X 
			- = 미리 메모리 내 스택영역, 큐 영역, 배열 영역 등등 존재하는 상태가 X 
		- 프로그램 내에서 데이터를 저장하기 위해 특정 자료구조를 사용할 결정을 하면, 그 자료구조는 실행 시 메모리 내에 생성되고, 필요에 따라 확장
			- = 자료구조를 사용하겠다는 코드가 작성되고 실행될 때, 그때 해당 자료구조에 대한 메모리 공간이 동적으로 할당되는 것
			- = 자료구조는 실행 시간에 메모리에 할당
		- 예시
			- 자바에서 `Stack<Integer> stack = new Stack<>();` 코드를 사용하여 스택을 생성하면, 이 코드가 실행될 때 메모리 내에서 스택을 위한 공간이 할당됨
			- 자바에서 `List<Integer> list = new ArrayList<>();`를 실행하면, 리스트를 위한 초기 메모리 할당이 이루어짐
			- 
	- 스택(Stack) 자료구조
		- <span style="background:#d3f8b6">메모리-스택자료구조-이미지</span>
		- 스택 주소 지정 방식=스택 자료구조 방식
		- 특징/의미
			- 후입선출(Last In, First Out; LIFO) 방식으로 데이터를 관리 = 이는 마지막에 들어온 데이터가 가장 먼저 나가는 방식
			- '스택'은 데이터를 저장하는 추상적인 개념이자 방법론/규칙이며, 이 개념은 실제 물리적 메모리 내에 구현됨. 
				- = 실제 메모리 내에는 이 규칙에 따라 데이터가 저장되고 관리되는 구체적인 영역이 존재
				- = 스택은 메모리 내에서 연속적인 공간을 차지
		- 스택 자료구조는 스택 포인터 (레지스터 )(Stack Pointer) 필요
			- <span style="background:#d3f8b6">스택포인터-동작원리-이미지</span>
		- 상황예시
			- 함수 호출, 괄호 매칭 등 다양한 프로그래밍 상황에서 활용
				- 이는 스택의 최상단을 가리키는 레지스터로, 현재 스택의 꼭대기를 나타냅. 즉, 스택에서 가장 최근에 저장된 데이터의 메모리 주소를 가리킵
				- 상황예시
					- 어떤 함수가 호출되면, 해당 함수의 실행에 필요한 매개변수, 반환 주소, 지역 변수 등이 스택에 저장
						- 1. 함수의 매개변수 저장
							- 함수를 호출할 때 전달되는 매개변수 값이 스택 메모리에 저장
						- 2. 반환 주소 저장
							- : 현재 함수가 끝나고 제어가 반환될 위치, 즉 호출한 함수로 돌아가기 위한 주소가 스택에 저장
						- 3. 지역 변수
							- : 함수 내에서 선언된 지역 변수들이 스택 메모리에 할당
					- 이 모든 정보들은 함수가 호출될 때 스택의 상단에 순차적으로 쌓이며, 함수가 종료될 때 이들은 스택에서 제거되어 메모리가 반환
					- 이때 스택 포인터는 스택의 최상단을 가리키게 되며, 데이터가 스택에 추가될 때마다 위로 이동하고, 데이터가 제거될 때마다 아래로 이동합
					- 
	- 큐(Queue) 자료구조 
		- 선입선출(First In, First Out; FIFO) 방식으로 데이터를 관리 = 첫 번째로 들어온 데이터가 가장 먼저 나가는 방식
		- 버퍼, 대기열 관리 등에 사용
	- 배열(Array)
	- 리스트(List)
	- 해시테이블(Hash Table)