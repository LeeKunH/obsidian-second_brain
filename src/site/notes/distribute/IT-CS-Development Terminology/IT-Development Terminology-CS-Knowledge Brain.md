---
{"dg-publish":true,"permalink":"/distribute/it-cs-development-terminology/it-development-terminology-cs-knowledge-brain/","tags":["개발용어_CS지식","목차"],"noteIcon":""}
---

### 날짜 2024-03-14 15:18


---
# 참고/연관된 기록 =>
위에서 작성한 내용과 연관성이 있는 기록-노트를 연결.
" [[]] "



----
# <디지털 환경-세계 인프라 아키텍처>


##### ㅡ 
- # 디지털 리터러시 
- **역량 필요성**  
	- 24시간 내내 디지털 기술과 기기를 사용하며 생활하고 있습
	- 이러한 환경에서 디지털 기술을 이해 시 해당 기술을 보다 더 효율적으로 사용 가능 = 생산성과 효율을 크게 향상
	- 이러한 디지털 기기-기술을 언제-어떠한 상황에서, 어떻게 사용해야 하는지 아는 것이 중요 > 이를 위해서는 디지털 기술에 대한 기본적인 지식과 상식이 필요
	- EX) 
		- `어떠한 기술들이 존재? > ~ 기술은 어떻게 사용? > ~ 기술은 어떻게 작동하고 우리의 일상과 업무에 어떻게 통합되고 있을까? ``
	- 
- 3. 미디어 리터러시
	- 여러 형태 메세지 존재 > 메세지 분석 - 평가 - 의사소통 할 줄 아는 능력
	- 
- ### 2. IT 리터러시
{ #a2defd}

- **역량 필요성**
	- 비유를 통한 이해 =>
	- 현실 세계에서 영어의 중요성 = 디지털 세계에서 IT리터러시-언어의 중요성
		- 현실 세계에서 대부분의 주요 정보는 영어로 제공됨 > 영어를 이해할 수 있다면, 세계를 바라보는 시야가 넓어지며, 더 많은 정보에 접근할 수 있음
		- 마찬가지로, 디지털 세계에서는 많은 정보와 기술이 프로그래밍 언어로 작성되어 있습 > 프로그래밍 언어를 이해하는 것은 디지털 세상에서 보다 넓은 시야를 갖게 하며, 더 많은 정보에 접근할 수 있음
		- 
- 키워드
	- [[알고리즘-문제해결절차-CT-컴퓨터사고\|알고리즘-문제해결절차-CT-컴퓨터사고]] 
	- 다양한 디지털 인프라 <> 다양한 개발직무 <> 다양한 개발언어
		- 프론트엔드 / 백엔드
		- 자바 / 파이썬 ...
		- 프로그래밍 언어=>
			- 프로그램을 작성하기 위한 수단
			- 다양한 프로그래밍 언어 존재
			- C 언어
				- 초창기 사용된 언어
				- 기계와 친한 컴파일 언어 = 임베디드 개발 언어
				- 비트 조작 등 세밀한 기술도 가능해 운영체제나 언어 처리기 등 시스템 기술에 적합한 언어
			- C++ 언어
				- C언어에서 파생된 언어 > C 문법 + 기능 모두 사용가능
				- 게임 개발에 주로 사용
			- C# 언어
				- C++과 JAVA의 영향으로 만들어진 언어
			- JAVA 언어
				- 객체지향 언어인 C++ 장점은 살리고 약점 보완한 언어
				- 국내 가장 많이 사용되는 객체지향 개발 언어
				- 네트워크 분산 처리 환경에서 사용되도록 개발된 언어 > 보안 강함
				- 인터넷-네트워크 환경에 존재하는 다양한 컴퓨터-기기-하드웨어-플랫폼에서 동일한 소스 코드를 사용할 수 있는 이식성이 강한 언어
			- PYTHON 언어
				- C언어에서 파생된 언어
				- 문법이 쉽고 코드표현식/표현구조가 인간의 사고 방식과 비슷해 초기에 배우기 용이
				- 웹 개발 / 데이터 분석/ 머신러닝 등 분야에서 사용
				- 소스코드를 한 단계씩 해석 > 실행하는 인터프리터식 언어
				- 
			- 다양한 특징에 따른 언어 분류 가능 =>
				- 소스 코드를 해석하고 실행하는 프로그램의 유형에 따른 분류
					- 연관노트 : [[실행환경-런타임환경-컴파일러-인터프리터-이해\|실행환경-런타임환경-컴파일러-인터프리터-이해]]
						- **컴파일러 언어**
						- **인터프리터 언어**
				- **클라이언트 측 언어**
					- JavaScript(JS)는 클라이언트 측에서 동작하는 대표적인 프로그래밍 언어
						- = 웹 브라우저에서 실행되어 사용자 인터페이스와 상호작용을 처리
					- 주의
						- JS는 클라이언트 측에선 브라우저에서 실행 <> 서버측에서는 특정한 가상환경에서 실행 (Node.js)
				- **서버 측 언어**:
					- 서버 측에서 동작하는 프로그래밍 언어
						- = 이 언어들은 이름 그대로 서버 측 로직을 처리
						- = 클라이언트(사용자의 브라우저)와 독립적으로 서버에서 해석 > 실행
						- EX) 데이터 처리, 데이터베이스 관리, 서버 로직, API 개발 등
					- EX) 자바(Java), 파이썬(Python), 루비(Ruby), PHP, Node.js(JavaScript) 등
				- **스크립트 언어**:
					- 주의
						- "스크립트 언어"라는 표현은 서버 측 언어뿐만 아니라 클라이언트 측 언어에도 적용될 수 있습
						- 교집합은 존재하지만, 서버 측에서 동작하는 언어와 스크립트 언어는 엄밀히 말하면 구분
							- + 
							- 서버 측 언어는 그 용도가 **서버 작업**에 특화
							- 스크립트 언어는 그 해석과 **실행의 방식**을 나타내는 용어
					- 스크립트 언어는 일반적으로 소스 코드가 실행 시간에 해석되어 실행되는 언어
						- 컴파일 과정 X?
							- 스크립트 언어는 일반적으로 인터프리터 언어의 특징을 가지고 있습 > 따라서 스크립트 언어는 대체로 인터프리터 언어라고도 표현할 수 있습
							- 스크립트 언어의 대부분은 인터프리터 방식을 사용하여 실행 시간에 코드를 해석하고 실행
						- ㅡㅡㅡㅡ본문내용
						- = 소스 코드가 별도의 **컴파일 과정 없이** 실행 시간에 직접 해석되어 실행되는 프로그래밍 언어
						- EX ) JavaScript, Python, PHP 같은 언어
						- 
					- 스크립팅 역량
						- 채용 공고에서 언급된 '스크립팅 능력'은 일반적으로 컴퓨터 프로그래밍 언어(스크립트 언어)를 사용하여 시스템 관리, 작업 자동화, 간단한 로직 처리 등에 사용
						- 스크립팅 언어는 일반적으로 간단한 코드를 작성하여 반복적인 작업을 빠르게 처리할 수 있도록 도움
						- 상황예시
							- 스크립트는 데이터 처리, 시스템 관리, 파일 조작, 네트워크 작업 등 다양한 분야에서 활용
							- 배치 작업, 서버 모니터링, 데이터 백업 자동화 등을 위한 스크립트를 작성하는 데 필요
						- 이러한 스크립팅 기술은 반복적인 작업을 효율적으로 처리하고, 오류 가능성을 줄이며, 전반적인 작업 속도를 높이는 데 도움을 줄 수 있습
							- > 스크립트 역량은 시스템을 보다 효과적으로 관리하고 운영하는 데 크게 기여할 수 있음
							- > 스크립팅 능력을 갖추는 것은 데이터 센터 운영에 있어 매우 중요한 역량 중 하나
							- > 효율적인 시스템 관리와 운영을 위한 스크립팅 능력이 모두 요구
							- 
						- 스크립팅 작업 시 필요한 언어 존재 =>
							- **Bash, Python, Perl**: 이들은 가장 일반적인 스크립팅 언어 중 일부
							- Bash는 리눅스 및 유닉스 기반 시스템에서 널리 사용되며, 시스템 관리 작업과 간단한 작업 자동화에 주로 쓰입
							- Python과 Perl은 더 강력하고 다양한 용도로 사용될 수 있는 스크립팅 언어로, 데이터 분석, 웹 개발, 시스템 스크립팅 등에 적합
						- 예시 상황 =>
							- 데이터 센터에서 근무하며 서버의 로그 파일을 주기적으로 검사하고 분석하는 작업을 담당한다고 가정
							- 이 경우 Python 스크립트를 작성하여 로그 파일에서 특정 이벤트를 자동으로 검출하고 보고서를 생성하는 프로세스를 자동화할 수 있습
				- **웹 언어**
					- 웹 페이지 구성? =>
						-  [[웹페이지-이해-이미지\|웹페이지-이해-이미지]]
							- 1. 브라우저를 통해 사람이 보면 화면
							- 2. 컴퓨터가 보는 화면
						- 일반적으로 **웹 페이지**를 **구성**하는 데 사용되는 HTML, CSS, JS를 모두 포함
						- 
						- 정적 웹 페이지와 동적 웹 페이지의 구분
							- **정적 웹 페이지** 
							    - HTML과 CSS만을 사용하여 구성된 웹 페이지
							    - 이런 페이지들은 서버에서 클라이언트(브라우저)로 전송될 때 이미 모든 내용이 완성된 상태이며, 사용자의 상호작용에 따라 내용이 변하지 X
						    - **동적 웹 페이지**
							    - JavaScript를 포함하여 만들어진 웹 페이지
							    - JavaScript는 사용자의 상호작용에 반응하여 페이지의 콘텐츠를 실시간으로 변경할 수 있게 해주며, 이로 인해 페이지에 동적인 요소가 추가됩
							    - 
						- HTML(HyperText Markup Language) = 마크업 언어
							- 웹 페이지의 기본적인 뼈대를 구성 = 구조 정의
							- 웹 페이지 콘텐츠 정의
						- CSS  = 스타일 시트 언어
							- 웹 스타일/디자인 정의
							- 페이지의 **시각적 구조** 정의
								- 시각적 구조 =>
								- HTML로 작성된 구조-뼈대 위에 CSS가 시각적 형태와 배치/위치를 제어 가능 > 시각적으로 구조를 정의 가능
									- = HTML로 만들어진 기본 구조 위에 추가적인 '구조적 레이어'를 제공
								- EX) Flexbox나 Grid와 같은 레이아웃 시스템
						- JS = 스크립트 언어 = 동적인 언어 = 프로그래밍 언어
							- 웹 동작 정의
							- EX) 드롭다운 메뉴 선택, 아이디 비밀번호 입력 > 로그인 페이지 이동
							- 
			- [[디지털환경-인프라아키텍처-디지털리터러시#- 코딩-프로그래밍-코더-프로그래머-이미지\|디지털환경-인프라아키텍처-디지털리터러시#- 코딩-프로그래밍-코더-프로그래머-이미지]]
				- 이미지 설명 =>
				- 코딩하다! <> 프로그래밍하다! 비슷하지만 **의미/범위 차이** 존재
				- 의미/범위 차이? =>
					- 코딩 coding = 코드를 작성하다
						- 사람이 원하는 작업/명령을 컴퓨터가 이해할 수 있는 형태로 작성하는 것
						- 사람 <> 컴퓨터 의사소통
					- 프로그래밍(programming)
						- 코드를 작성하는 행위 + 해당 프로그램이 제대로 동작하기 위한 다양한 유형의 경우를 다루는 작업
						- ex) 
							- 디버깅
							- 코드분석, 코드최적화, 효율적인 논리 (코드 패턴-디자인)구성, 적절한 알고리즘 사용 
							- 파일 구조화-설계'
							- 
		- 로우코드(low code)/ 노코드(no code) 플랫폼 =>
			- 디지털리터러시의 필요성이 증대되면서 개발경험이 거의 없는 ‘시민개발자(citizen developer)’를 위한 개발 플랫폼서비스
			- PaaS(Platform as a Service) 클라우드환경에서 구축됨
			- 시각적 프로그래밍 인터페이스를 활용해 기존보다 더 쉽고 빠르게 비즈니스 문제를 해결하는데도움을준다.
			- 
	- 자동화 (automation) : 사람의 개입 없이 컴퓨터가 문제를 혼자 수행하게 한다
		- 장점
			- “Human Error-휴먼에러-실수”를 미연에 방지할 수 있다
			- 업무 생산성이 높아지고, 신속하고 일관성있는 업무적용으로 결과물의 품질이 좋아짐
			- 단순 반복업무를 벗어나 부가가치 높은 본연의 업무에 집중
			- 
		- 무인자동화
			- 단순판매, 노무(주로 육체노동을 하는 직무) 등 자동화
			- EX) 늘어나는  키오스크와 무인매장
		- 기계를 활용한 업무자동화, RPA
			- = 로봇프로세스자동화(RPA, Robotic Process Automation)
			- 
			- 기업의재무, 회계, 제조, 구매, 고객관리 등에서 데이터수집, 입력, 비교 등과 같이 논리적으로 정형화 할 수 있는 단순 반복업무를 자동화하여 빠르고 정밀하게 수행하는것.
			- 비즈니스과정 중 반복적이고 단순한 업무프로세스에 소프트웨어-IT기술를 적용해 자동화하는 기술
			- 단순 반복 작업, 위험한 업무를 대체하는 로봇자동화
			- 
		- 패턴분석 (pattern recognition) : 데이터에 반복적으로 나타나는 방식을 파악함으로써 반복 작업을 자동화 가능해진다
		- 
	- DB = 데이터베이스 시스템 = 데이터베이스 프로그램
		- <span style="background:#d3f8b6">데이터베이스-과정이해-이미지</span>
			- 쿼리(query) 용어
				- DBMS 프로그램으로 DB에 존재하는 데이터를 제어하는 작업/명령문 의미
				- SQL(Standard Query Language) 언어로 명령문 작성
		- **요약** : `DB = 데이터베이스 관리 시스템 = DBMS = DataBase`
			- `DB`은 데이터를 저장하고 관리하는 방법론 및 개념, **실질적인 프로그램** 모두를 포괄하는 더 넓은 맥락을 의미
			- = 데이터를 효율적으로 저장, 검색, 업데이트하고 관리하는 전체 시스템을 의미
			- = 데이터베이스(프로그램) 자체뿐만 아니라 데이터를 관리하고 접근하는 데 필요한 모든 요소(하드웨어, 소프트웨어, 프로시저 등)가 포함
		- 실질적인 프로그램 =>
			- 실질적으로 데이터를 저장-관리 시 사용하는 프로그램은 DBMS(DataBase Management System) 표현.
			- DB는 (정형) 데이터들의 집합 의미 > 이러한 데이터들을 관리하기 위한 프로그램
			- 데이터베이스 (프로그램)은 데이터를 테이블 형태로 저장
			- CRUD 작업/기능 지원하는 프로그램
				- 데이터 생성
				- 데이터 읽고/검색
				- 데이터 수정
				- 데이터 삭제
			- 다양한 DBMS 프로그램 존재
				- 오라클 / MySQL/ PostgreSQL/MongoDB
		- **특징** <> `파일시스템` **차이점**
			- 여러 사람이 데이터를 공유하고 사용할 목적으로 통합 관리하는 표준 데이터 집합
			- 데이터 양이 방대, 구조적, 여러 사용자가 동시에 데이터에 접근-사용해야 할 때 효과적인 방법/시스템
			- 
		- ==실습 =>== [[DB-데이터베이스시스템-이해\|DB-데이터베이스시스템-이해]]
			- 엑셀프로그램 이용 > 현재 가지고 있는 파일시스템-파일데이터를 DB 시스템화 가능
			- 






- ### 1. 데이터 리터러시
- 키워드
	- ==데이터 분류== | [[데이터분류-구조-형식-규모\|데이터분류-구조-형식-규모]]
	- 데이터 라벨링 / 데이터 댐
	- 업무 자동화 / RPA
	- 인공지능 / 머신러닝 / 딥러닝
- 의미
	- 데이터 리터러시는 데이터를 이해하고, 해석하며, 적절하게 **활용할 수 있는 능력**
	- 활용할 수 있는 능력? =>
		- 데이터 리터러시를 위한 데이터 활용 과정
			- <> `인공지능-기계 학습을 위한 데이터 준비 과정`! 조금 다름 | [[인공지능-지식브레인\|인공지능-지식브레인]]
			- 
			- 1. 데이터 인식 및 수집(Data Recognition and Collection)
				- 데이터의 필요성을 인식하고, 관련 데이터를 다양한 출처에서 수집
			- 2. 데이터 이해 및 정제(Data Understanding and Cleaning)
				- 수집된 데이터를 검토하고 이해
			- 3. 데이터 분석(Data Analysis)
				- 정제된 데이터를 활용하여 통계적 분석, 경향성 파악, 예측 등을 수행
				- 이 과정에서 데이터의 패턴을 파악하고 의미 있는 정보를 도출
			- 4. 데이터 해석 및 표현(Data Interpretation and Presentation)
				- 분석 결과를 해석하고, 이를 적절한 형태(표, 그래프, 보고서 등)로 표현하여 이해하기 쉽게 전달




##### ㅡ 
- # 디지털 환경-세계 인프라 아키텍처
- 디지털 인프라 : 
	- <span style="background:#d3f8b6">디지털 인프라 아키텍처-이미지</span> | [[디지털환경-인프라아키텍처-디지털리터러시\|디지털환경-인프라아키텍처-디지털리터러시]], [[인프라-컴퓨팅서비스-클라우드서비스-용어이해\|인프라-컴퓨팅서비스-클라우드서비스-용어이해]]
		- <span style="background:#d3f8b6">디지털 인프라 아키텍처 기반 CS전공지식 이해-이미지</span>
		- ==디지털 인프라 아키텍처 기반 다양한 개발직군 이해== | [[디지털인프라-개발직군-직무-역량 이해\|디지털인프라-개발직군-직무-역량 이해]]
		- 
	- 우리는 24시간 내내 다양한 IT 기술과 기기를 사용하며 살아가고 있습
	- 이러한 IT 기술과 기기를 통해 형성된 세상을 '디지털 환경'이라고 부를 수 있습
	- 이 디지털 환경-시스템이 원활하게 작동하기 위해서는 여러 구성요소들이 상호작용함
	- 이 구성요소들은 크게 네 가지로 구분 가능
		- 1. **로컬 PC 영역**: 사용자의 컴퓨터나 클라이언트 PC가 이에 해당
		- 2. **서버 컴퓨터 영역**: 데이터 처리와 저장이 이루어지는 서버들
		- 3. **네트워크 영역**: 이들 기기와 서버들을 연결하는 통신망
		- 4. **클라우드 가상 PC 영역**: 클라우드 서비스를 통해 제공되는 가상 컴퓨팅 리소스 존재-제공
			- + 디지털 인프라 아키텍처에서 클라우드 가상 PC 영역과 서버 컴퓨터 영역이 **상호 보완적인 관계**
			- 아래 클라우드 섹션 확인
	- 이러한 구성요소들의 체계적인 구성을 '디지털 인프라 **아키텍처**'
		- + 아키텍처?
		- `아키텍처`를 통해 디지털 환경의 다양한 구성요소들이 어떻게 조합되어 있는지, 각 구성요소의 역할과 관계를 한눈에 알아볼 수 있는 설계도 이해


##### ㅡ 
- # 1. 내 컴퓨터 = 로컬PC = 클라이언트 PC 영역 =>
- 컴퓨터는 다양한 하드웨어들의 조합으로 이루어짐, 각각의 구성 요소들 서로 상호작용하며 컴퓨터가 동작한다. 따라서 컴퓨터는 하나의 **시스템**이라고 표현 가능.
- 
- **컴퓨터 구조**/**내부-동작원리**를 **알아야 하는 이유**
	- 1. 코드 작성 시 문제 해결 능력
		- 예시상황
			- 똑같은 코드를 작성하더라도 어떤 컴퓨터에선 될 떄가 있고 안 될 떄가 있다. > 이러한 상황에서는 코드에 문제가 있을 수도 있지만 코드가 실행되는 실행환경/개발환경에 문제가 있는 경우가 많다.
				- + **실행환경** = **개발환경**
			- 이런 실행환경/개발환경을 잘 파악하기 위해선 컴퓨터 구조/동작원리/운영체제를 알면 도움이 된다
	- 2. (CPU)성능 - (메모리)용량 - 비용을 고려한 코드작성 가능
	- 
- `컴퓨터 구조 배운다!` **표현 의미**
	- 1. `컴퓨터가 이해하는 정보!` 배운다. **=>**
		- 명령! = 명렁어(명령코드) OR 제어신호(전기신호) 2가지 의미 존재
			- 사람 <> 컴퓨터 사이 명령
				- 사용자가 컴퓨터에 명령을 내릴 때, 이는 보통 고수준 언어로 작성된 명령어/코드 형태
				- 사용자의 명령은 소프트웨어 애플리케이션(코드 편집기 프로그램, 터미널 프로그램 등등)을 통해 입력되고, 필요에 따라 그 명령을 운영체제나 다른 프로그램을 통해 해석 및 실행됨
			- 컴퓨터 내부 명령 
				- CPU가 시스템 내의 다른 하드웨어 구성 요소에 명령을 내릴 때는 `제어신호`를 사용
				- 이러한 제어 신호는 물리적인 `전기신호` 형태로 전달되며, 각종 하드웨어 장치의 동작을 제어
			- 상황예시
				- 사용자가 컴퓨터쪽으로 문서를 저장하는 명령(명령어)을 실행하면, 해당 명령은 우선 소프트웨어 레벨에서 처리되고, 최종적으로는 CPU(하드웨어 레벨)가 스토리지 장치에 데이터를 쓰라는 명령을 `하드 드라이브 컨트롤러`에 제어 신호 형태로 전달
				- > 이러한  과정이 사용자의 고수준 명령(명령어)가 실제 하드웨어 동작-제어신호로 변환되어 실행되고 있는 것
				- 
	- 2. `컴퓨터/메모리에 저장되는 데이터 형태` 배운다. **=>**
		- 이진 숫자 형태? =>
			- 컴퓨터가 이해할 수 있는 정보의 기본 형태
		- 연관 노트 : [[인코딩-디코딩-유니코드\|인코딩-디코딩-유니코드]]
			- 문자는 특정 `인코딩`에 따라 이진 숫자로 변환되어 저장되고, 이미지는 픽셀 값으로 변환되어 각각 `이진 데이터`로 표현되어 메모리에 저장
			- 반대로 저장된 이미지를 화면에 출력할 때, 저장된 바이트 값을 다시 픽셀 값으로 변환(디코딩) > 이러한 변환을 통해 저장된 이미지 데이터는 화면에서 시각적으로 인식 가능한 형태로 표시됩
		- ㅡㅡㅡㅡ본문내용
		- 컴퓨터 `메모리`에 저장되는 모든 정보, 그것이 `명령어(코드)`이든 `데이터`이든, 최종적으로는 0과 1로 구성된 **이진 숫자 형태**로 저장됩
			- +
			- CPU는 메모리에서 데이터를 읽을 때, 그 데이터는 이진 형태
			- CPU 내부에서 데이터를 처리할 때 이진 형태로 명령을 인식하고 실행합
			- **기계어-명령어**도 이진 코드의 형태로 되어 있으며, CPU는 이 명령어를 해석하고 실행
			- 사람이 작성한 고급언어-명령코드는 최종적으로 기계어 형태로 CPU에서 해석 > 실행 > 출력
			- 
		- 데이터가 메모리에 저장될 때, 그것은 이미 **바이트 단위**로 묶여-구성되어 있습
		- 각 바이트는 이진 숫자의 형태(0과 1의 조합)로 구성
		- 바이트는 정보의 기본 단위이며, 이진 코드는 바이트를 구성하는 실제 데이터입
		- 
		- 컴퓨터/메모리에 저장되는 데이터 2가지 유형/종류
			- 데이터? =>
				- 프로그램을 만들기 위해 필요한 숫자, 문자, 이미지, 동영상 같은 정적인 정보들 =  명령어에 의해 처리되는 정보
					- EX) 텍스트, 이미지, 소리 등 
				- 컴퓨터와 주고받는, 내부에 저장된 정보들을 모두 데이터로 표현하기도 함
			- 명령어? =>
				- 컴퓨터는 결국 사람이 내린 명령어(코드)를 해석 > 실행 > 처리하는 기계
				- 명령어는 컴퓨터가 수행할 작업을 정의하며, 데이터를 조작하고 처리하는 데 필요한 지시사항을 포함 = PC 움직이게 하는 정보
				- 데이터는 명령어를 위한 일정의 정보
			- ㅡㅡㅡㅡ본문내용
			- [[디지털환경-인프라아키텍처-디지털리터러시#- 컴퓨터메모리-저장데이터-종류-이미지\|디지털환경-인프라아키텍처-디지털리터러시#- 컴퓨터메모리-저장데이터-종류-이미지]]
			- 명령어와 데이터/정보 = 프로그램 저장 = 코드덩어리 저장
			- 컴퓨터 안에 존재하는 모든 프로그램은 **명령어(코드)** 와 **데이터_정보** 2가지로 이루어져 있다고 표현 가능
			- 
	- ==3. `컴퓨터를 이루는 4가지 핵심 부품!` 배운다.==


##### ㅡ 
- 내 컴퓨터 = 로컬PC = 클라이언트 PC 영역
- ### 1. 하드웨어-HW-Hardware :
- ##### 대략적인 하드웨어 위에서 프로그램의 작동방식/원리/흐름
	- 문서 프로그램을 실행하는 걸 생각 > 어떻게 하드디스크로부터 CPU까지 연결이 될까?
		- 1. 소프트웨어를 쓰려면 일단 `하드디스크`에 저장되었는지 보고, 디스크에 있는 데이터를 불러옵
		- 2. `램/메모리`에 소프트웨어를 올리고 동작을 할 준비
		- 3. 필요한 만큼 `CPU`에서 연산을 하며 소프트웨어를 동작
		- 
- ##### 저장장치 계층구조 존재 = 메모리 계층 존재 = memory hierarchy
	- <span style="background:#d3f8b6">메모리계층구조-이미지</span>
		- ![[Pasted image 20240405160947.png\|Pasted image 20240405160947.png]]
		- ![[Pasted image 20231231140816.png\|Pasted image 20231231140816.png]]
		- 이미지 설명 =>
			- 1. 레지스터 (Registers)
			- 2. 캐시 메모리 (Cache Memory)
				- ==캐시 메모리 계층 존재== | [[저장장치-캐시계층-구조\|저장장치-캐시계층-구조]]
				- L1 캐시: CPU 내부, 가장 빠른 접근.
				- L2 캐시: CPU에 가까움, L1보다 느린 접근.
				- L3 캐시: CPU에 가까우나 L1, L2보다 느리고 더 큰 용량.
			- 3. 메인 메모리 (Main Memory or RAM)
			- 4. 보조 메모리 (Secondary Storage)
	- 주의
		- 보통 `메모리` 용어는 `RAM` 의미함. 따라서 `메모리 계층 구조` 라는 표현 시 `RAM` 메모리 계층구조! 라고 잘 못 이해할 수 있음 > 따라서 `저장장치 계층 구조` 표현 사용
	- 저장장치 계층구조는 레지스터, 캐시 메모리, 메인 메모리, 그리고 보조기억장치 등을 포함하는 포괄적인 개념
		- = 단순히 메인 메모리나 보조기억장치에 국한되는 주제가 X
	- 저장 장치들은 `CPU에 얼마나 가까운가!`를 기준으로 계층적으로 나타낼 수 있음
	- 2가지 중요한 명제 존재.
		- 1. CPU와 가까운 저장 장치는 접근속도 빠르고 멀리 있는 장치는 느리다.
		- 2. 대신 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다
		- 따라서 낮은 가격대 저장 장치 원한다면 느린 속도 감수, 빠른 속도 저장 장치 원한다면 작은 용량과 비싼 가격 감수
		- 
- ##### 컴퓨터를 이루는 4가지 핵심 부품-구성요소 존재
	- + 4가지 핵심 구성 요소들이 모두 포함되어 있다면 컴퓨터-시스템이라고 정의 가능 > 따라서, 비록 외형적으로 작은 칩과 같은 형태를 가지고 있더라도, `아두이노`나 `라즈베리파이`와 같은 장치들도 이 네 가지 핵심 구성 요소를 갖추고 있기 때문에 컴퓨터로 분류될 수 있음
		- [[컴퓨터구조-이미지#- 아두이노-라즈베리파이-이미지\|컴퓨터구조-이미지#- 아두이노-라즈베리파이-이미지]]
		- 
	- <span style="background:#d3f8b6">이미지</span> | [[컴퓨터구조-이미지#전체구조도\|컴퓨터구조-이미지#전체구조도]]
	- [[운영체제-메모리-프로세스-파일관리-이미지#- OS-메모리관리-메모리내부구조-메모리공간-이미지\|운영체제-메모리-프로세스-파일관리-이미지#- OS-메모리관리-메모리내부구조-메모리공간-이미지]]
		- 명령어와 데이터를 각각 저장
		- 어떤 값을 어디에 저장? > 메모리 위치를 파악할 수 있는 주소가 존재
		- 주소가 있어야 다른 곳에서 접근/참조/사용 가능
		- 
		- 하나의 프로그램(코드집합)에는 다양한 기능들이 존재
		- 각각 기능들도 사실 모두 코드집합
		- 따라서 이미지처럼 메모리 위에는 하나의 프로그램 공간이 할당-존재하고 그 공간 내부에 또 각각 공간이 존재하는 느낌으로 이해 가능
		- 
	- **메인보드 = 마더보드 (mother board) = 시스템보드 (system board)** =>
		- 버스? =>
			- 버스/회로선들은 CPU, 메모리, 입출력 장치 등을 연결하여 정보, 제어신호가 이들 구성 요소 사이에서 효율적으로 이동할 수 있도록 돕는 통로
			- 버스는 물리적인 부품이라기보다는 메인보드 위의 전기적 신호를 전달하는 경로나 회로의 집합을 의미
				- + **버스 = 회로선 = 경로**
				- 
			- **다양한 종류 버스 존재**
				- <span style="background:#d3f8b6">이미지</span> | [[컴퓨터구조-이미지#시스템버스\|컴퓨터구조-이미지#시스템버스]]
				- 1. 주소 버스
					- : 주소를 주고받는 토로
				- 2. 데이터 버스
					- : 프로그램을 위한-명령어와 데이터를 주고받는 통로
				- 3. 제어 버스
					- : 제어 신호를 주고받는 토로
					- 
				- 컴퓨터 핵심 부품을 연결하는 버스
				- 데이터, 주소, 제어 신호 등이 이동하는 경로를 제공
				- ex) 시스템버스-CPU 작동예시
					- <span style="background:#d3f8b6">이미지</span> | [[컴퓨터구조-이미지#시스템버스-cpu-작동예시\|컴퓨터구조-이미지#시스템버스-cpu-작동예시]]
					- 요약 :
						- 하나의 명령어 출발 = 제어신호 출발 > 후 각각 종류에 따라 다른 버스를 타고 이동함
						- CPU가 메모리로부터 데이터를 읽어야 할 때, 이 데이터는 시스템 버스를 통해 CPU로 전송
						- CPU에서 메모리로 데이터를 쓸 때도, 해당 데이터는 시스템 버스를 통해 전송
					- 1. 메모리에 저장된 값을 사용할 때 
						- + **접근하다 = 사용하다 = 참조하다 = 읽는다**
						- `CPU`가 `메모리` 속 명령어를 읽어 들이기 위해 `제어장치`에서 ‘메모리 읽기’라는 신호를 내보낸다 
							- + 사실 CPU가 메모리를 읽을 땐 제어 신호만 내보내지 않고 신호와 주소 동시에 내보낸다.
						- **①** `제어 버스`로 ‘메모리 읽기’ 제어 신호를 내보내고, **②** `주소 버스`로 읽고자 하는 주소를 내보냅
						- **③** 그러면 `메모리`는 `데이터 버스`로 CPU가 요청한 주소에 있는 내용을 보냅
					- 2. 메모리에 값을 저장할 때
						- + **저장한다 = 쓴다** 
						- **①** CPU는  `데이터 버스`를 통해 메모리에 저장할 값(CPU에서 연산이 끝난 값)을, 
						- **②** 주소 버스를 통해 저장할 주소를, 
						- **③** 제어 버스를 통해 ‘메모리 쓰기’ 제어 신호를 내보냅
						- 
		- ㅡㅡㅡㅡ본문내용
		- <span style="background:#d3f8b6">이미지</span> | [[컴퓨터구조-이미지#- 메인보드-마더보드(mother board)-시스템보드(system board)\|컴퓨터구조-이미지#- 메인보드-마더보드(mother board)-시스템보드(system board)]]
		- 컴퓨터의 여러 하드웨어 장치를 연결하는 기판 
		- 메인보드에 연결된 부품들은 '**버스**'를 통해 정보를 주고 받음
		- 
	- **1. 중앙처리장치-CPU-Central Processing Unit** :
		- <span style="background:#d3f8b6">이미지</span> | [[컴퓨터구조-이미지#- 중앙처리장치CPU-이미지\|컴퓨터구조-이미지#- 중앙처리장치CPU-이미지]]
		- 컴퓨터 두뇌에 해당하는 장치로서 데이터를 연산기능 수행
		- 연산 시 필요한 데이터를 RAM에서 읽어 들이고 > 해석하고  > 실행 > 계산결과 RAM 저장하는 장치
		- 
		- **CPU 구성요소**
			- 1. ==ALU-산술 논리 장치== | [[ALU-산술논리장치-플래그레지스터\|ALU-산술논리장치-플래그레지스터]]
			- 2. 레지스터
				- 실행 중인 데이터?
					- 명령어의 해석과 직접적인 실행에 필요한 정보
					- 즉 연산의 중간 결과, CPU의 상태, 특정 주소 등
				- 임시저장? 
					- 구조 생각 > 레지스터가 메모리보다 CPU와 가깝다 = 접근속도 빠르다.
					- 1. 메모리에서 가져온 CPU 연산 시 필요한 값 임시저장
					- 2. CPU에서 생성된 값 임시저장 > 메모리 저장
				- ㅡㅡㅡㅡ본문내용
				- CPU 내부에 존재하는 작은 저장장치
					- = CPU가 해석하고 **실행 중인 데이터**를 저장 > 빠르게 접근할 수 있도록 **임시저장**하는 공간
				- 캐시메모리에 비해 매우 제한된 수의 데이터 저장
				- 모든 레지스터는 CPU 내부에 존재
				- CPU는 다양한 설계와 목적에 따라 여러 종류가 있으며, 각기 다른 CPU 아키텍처는 레지스터의 개수와 종류가 다를 수 있음 그러나, 대부분의 CPU에는 몇 가지 공통적으로 존재하는 중요한 레지스터들이 존재 
					- = 대부분의 CPU 아키텍처에서 공통적으로 존재하는 레지스터 존재
					- = 다양한 레지스터 존재
					- ==다양한종류-레지스터== | [[다양한종류-레지스터\|다양한종류-레지스터]]
					- 
			- 3. 캐시 메모리
			- 4. ==제어장치== | [[제어장치-제어신호\|제어장치-제어신호]]
			- 
		- **CPU기능-메모리와 상호작용 과정**-이해예시
			- 메모리에 저장된 값을 이용해 최종적으로 220을 출력하는 하는 상황 가정 시 발생하는 내부과정
			- <span style="background:#d3f8b6">이미지</span> | [[CPU기능-메모리-상호작용-과정이해\|CPU기능-메모리-상호작용-과정이해]]
				- CPU가 1번지에 존재하는 명령어 실행하기 위해 제어장치가 메모리에 **신호를 보낸다**
				- (~값이 필요하다 전달받았으니 )메모리는 1번지에 존재하는 값을 CPU-레지스터로 보낸다 > 레지스터로 들어온 값(명령어)을 제어장치가 해석한다. > 해석 후 필요한 데이터를 파악해 다시 메모리쪽으로 CPU쪽에 필요한 데이터를 읽기 위한 제어신호를 보낸다
				- (~값이 필요하다 전달받았으니 )메모리는 해당 값들을 CPU쪽으로 보낸다 > CPU-ALU는 레지스터에 들어있는 값을 이용해 연산을 수행 후 해당 결과를 레지스터에 저장한다
				- 해당 결과를 메모리에 저장해야됨 > 따라서 2번지에 존재하는 명령어가 필요 > 따라서 제어장치에서 2번지에 존재하는 명령어값을 읽어들이기 위해 읽기 제어신호를 메모리에게 보낸다
				- (~값이 필요하다 전달받았으니 )메모리는 해당 명령어를 CPU쪽으로 보낸다. >  제어장치는 해석한다.  > 해석한 결과를 토대로 레지스터에 저장된 220이라는 값을 메모리에 저장하기 위해 쓰기 제어신호를 보낸다.
				- 이러한 과정을 거쳐 CPU에서 명령어와 데이터가 해석 > 실행되고 최종 결과가 메모리 특정 지점에 저장이 된다. 
	- **2. 주 기억장치 = RAM = 메인 메모리** : 
		- <span style="background:#d3f8b6">이미지</span> | [[컴퓨터구조-이미지#- 주기억장치-RAM-메인메모리\|컴퓨터구조-이미지#- 주기억장치-RAM-메인메모리]]
		- 컴퓨터가 켜진 동안에만 작동하는 일종의 작업 공간
		- 특징
			- RAM에 담긴 데이터는 컴퓨터를 끄면 모두 날아가는 휘발성 메모리
				- = 단기 기억 장치 = 계산결과를 잠시 기억함 = 휘발성 저장 장치
			- (같은 크기라 하더라도 보조기억장치에 비해) 비싸다
		- ==RAM메모리 주소 공간의 구분-주소체계== | [[메모리-주소체계-주소공간-작동원리\|메모리-주소체계-주소공간-작동원리]]
			- 논리주소와 물리주소는 프로그램의 실행과 메모리 접근을 위해 운영체제가 사용하는 추상화된 주소 체계
		- ==RAM의 기본적인 작동 원리== | [[RAM메모리-작동원리-성능\|RAM메모리-작동원리-성능]]
		- ==RAM(램) 종류== | [[D-S-RAM-종류\|D-S-RAM-종류]]
		- 
	- **3. 보조 메모리 = 보조 기억장치 (HDD, SSD) = 장기 기억장치** :
		- <span style="background:#d3f8b6">이미지</span> | [[컴퓨터구조-이미지#- 보조기억장치-HDD-SSD\|컴퓨터구조-이미지#- 보조기억장치-HDD-SSD]] , [[컴퓨터구조-이미지#- SSD내부-이미지\|컴퓨터구조-이미지#- SSD내부-이미지]]
		- 특징
			- RMA에 비해 느리지만 컴퓨터 전원을 꺼도 데이터가 보존되며 대용량 자료를 저장할 수 있음 
				- = 비휘발성 저장 장치
				- = 전원이 꺼져도 데이터를 유지
				- = 실행되지 X 프로그램 저장 
				- 
		- 보조기억장치 분류
			- 분류하는 주된 기준은 데이터 저장에 사용되는 기술-방식의 차이 =>
			- 1. ==플래시 메모리(Flash Memory) 기반 보조기억장치== | [[플래시메모리-기반보조기억장치\|플래시메모리-기반보조기억장치]]
				- ex) SSD(Solid State Drive), USB(Universal Serial Bus)
			- 
			- 2. 비플래시 메모리(Non-Flash Memory) 기반 보조기억장치
				- EX) 
					- CD(Compact Disc) : 광학 기술을 사용해 데이터를 저장하며, 레이저를 이용해 데이터를 읽고 씁
					- HDD(Hard Disk Drive)=하드디스크
						- ==HDD-구성요소== => [[HDD구성요소\|HDD구성요소]]
						- ==HDD작동원리-데이터접근과정== => [[HDD작동원리-데이터접근과정\|HDD작동원리-데이터접근과정]]
					- 
		- 중요 :  보조기억장치에는 수명이 존재한다
			- 플래시 메모리 기반 보조기억장치: SSD(Solid State Drive)
				- 플래시 메모리 수명 / 셀 > 연관된 노트 확인
					- 요약 =>
					- 셀로 구성 > 각 셀에 데이터를 전기적으로 저장
					- 셀에는 수명이 존재 
			- 비 플래시 메모리 기반 보조기억장치: 하드디스크 드라이브(HDD) 
				- 전통적인 비 플래시 기반 저장장치는 자기적 방식으로 데이터를 저장 > 물리적인 움직임이 포함되는 구조로 인해 마모가 발생할 수 있으며, 결과적으로 이들 또한 수명이 존재
				- 
		- 데이터의 신뢰성과 성능을 향상시키기 위해 여러 디스크 드라이브를 사용하는 기술 존재
			- ==RAID의 정의와 종류== => [[RAID레이드-기술-종류-레벨\|RAID레이드-기술-종류-레벨]]
	- **4. 입출력장치**
		- 정의
			- 컴퓨터 외부에서 **연결**되어 **컴퓨터 내부**에 존재하는 것들과 정보를 교환할 수 있는 장치 의미
				- + 연결 방식 : 물리적 연결(케이블, 포트)과 무선 연결(블루투스, Wi-Fi 등)이 있습
				- + 컴퓨터 내부 : CPU <> 입출력장치 간 정보 상호작용
		- 종류
			- 매우 다양하다
				- EX)  키보드 / 마우스 / 프린터 / 마이크 /  모니터/ 핸드폰 / 이어폰  /네트워크 장치 등등
				- `보조기억장치` : 정의를 기반 > 보조기억장치 역시 입출력장치 표현 가능
		- 장치가 다양하면 > 각 장치마다 CPU와 상호작용 속도, 데이터 전송 형식-방식, 요구사항 및 통신 프로토콜 다름 > 규격화 하기 어려움
		- 내용요약 : `**전송률(상호작용 속도)** 의 차이가 존재`
			- 연관노트 : [[장치컨트롤러-역할-기능-내부구조#- 입출력장치-버퍼링과정-이미지\|장치컨트롤러-역할-기능-내부구조#- 입출력장치-버퍼링과정-이미지]]
				- 일반적으로 CPU와 메모리는 높은 데이터 전송률을 지원하지만, 입출력 장치는 상대적으로 낮은 데이터 전송률을 가짐
				- 애초에 각 부품의 역할/기능에 따라 적절한 데이터 전송률을 갖도록 설계됨.
				- CPU는 매우 복잡한 계산과 빠른 데이터 처리 기능을 수행 > 따라서 빠름
				- 입출력장치는 주로 사용자의 입력을 받거나 결과를 출력하는 역할 > 따라서 CPU보다 상대적으로 느림
		- ==장치 컨트롤러 = 입출력 제어기(I/O controller) = 입출력 모듈(I/O modure)== => 
			- [[장치컨트롤러-역할-기능-내부구조\|장치컨트롤러-역할-기능-내부구조]]
			- [[입출력장치-CPU-입출력방식-데이터통신과정\|입출력장치-CPU-입출력방식-데이터통신과정]]
		- ==장치 드라이버== =>
			- [[장치드라이버-기능-과정이해\|장치드라이버-기능-과정이해]]









##### ㅡ 
- 내 컴퓨터 = 로컬PC = 클라이언트 PC 영역
- ### 2. 운영체제 (프로그램) - OS - Operation System
- 운영체제 사용된는 용어
	- 작업 프로세스 (Process)
		- 프로그램 실행된다 = 메모리 위에 올라간다 =  메모리에 해당 프로그램의 공간 생성 = 프로세스 생성 = RAM에 불려온 실행 중인/생성된 프로그램
		- 
- **다양한 종류 운영체제 존재**
	- [[운영체제-메모리-프로세스-파일관리-이미지#- 운영체제-이미지\|운영체제-메모리-프로세스-파일관리-이미지#- 운영체제-이미지]]
	- 이미지 설명 =>
		- 운영체제 (프로그램) 위에서 다양한 소프트웨어들이 동작
		- 개인용 pc 사용 운영체제 (클라이언트 측 운영체제)
			- 윈도우/ 맥OS
		- 서버 (pc 사용) 운영체제 
			- 유닉스 존재
			- 리눅스 존재
		- 모바일 사용 운영체제
			- 애플 - iOS - 아이폰
			- 구글 - 안드로이드 - 갤럭시
			- 
- **OS 존재 이유**
	- 참고기록 : `디지털 인프라 아키텍처-이미지` 확인.
	- 복기 : `운영체제도 결국엔 프로그램임` , `운영체제는 HW 자원을 관리함 = 운영체제 <> 하드웨어 상호작용`
		- 프로그램이기 때문에 사용자와 상호작용 가능 | [[프로그램실행원리-CLI-cmd-GUI\|프로그램실행원리-CLI-cmd-GUI]]
		- 따라서 하드웨어에서 문제를 진단할 때 우리는 HW와 직접 상호작용 하는 것이 아니라 운영체제를 통해 하드웨어 문제점을 진단
		- 
	- 요약 : `OS는 SW가 HW위에서 효율적으로 동작하기 위한 기반이 되는/효율적으로 상호작용을 위한/인터페이스 역할을 하는 프로그램`
		- 자원? =>
			- [[시스템자원-시스템리소스-resource-용어\|시스템자원-시스템리소스-resource-용어]]
		- 하드웨어 조작 코드? =>
			- 운영체제 내부에서 직접 하드웨어와 상호 작용하는 저수준 코드로 운영체제가 하드웨어를 직접 제어할 때 사용
			- 따라서 os가 없다면 운영체제 핵심 기능들을 직접 코드로 작성해야 됨.
			- ex) 프로그램을 메모리에 적재하는 코드 / CPU로 하여금 1과 2를 더하게 하는 코드 / 모니터에 계산 결과를 출력하는 코드
			- 
		- 비유 : 사용자를 위한 프로그램 x > sw-**프로그램을 위한 프로그램**
			- = 실행할 프로그램에 필요한 **자원**을 할당-연결하고 올바르게 실행되도록 돕는 프로그램
			- = 컴퓨터에서 동작되는 모든 응용 프로그램은 운영체제의 도움을 받아 실행됨
			- ex) a라는 프로그램이 실행되기 위해서 HW-b와 c가 필요하네 > b와 c 실행! + a프로그램과 연결! 
			- 
		- 소프트웨어는 하드웨어 위에서 동작,
		- 이론적으로는 운영체제 없이도 소프트웨어를 하드웨어에서 실행시킬 수 있습 > 그러나, 운영체제의 부재는 개발의 복잡성을 매우 높이며, 효율성을 크게 저하
			- = 운영체제가 없다면 간단한 프로그램이라도 **하드웨어를 조작하는 코드** 역시 직접 작성해야 함
		- 따라서 운영체제가 존재해야 효율적으로 하드웨어 자원을 관리하고, 소프트웨어 개발을 훨씬 쉽고 범용적인 소프트웨어 개발 가능
		- 
- 프로그램을 위한 프로그램? > 그렇다면 일반 프로그램이 어떻게 운영체제로부터 **어떤 도움**을 받으면서 실행되고 있을까?
	- = **운영체제의 핵심적인 기능-보안 메커니즘** 
	- ==이중모드== | [[운영체제기능-이중모드-매커니즘\|운영체제기능-이중모드-매커니즘]]
	- 
- **운영체제 이해**
	- 운영체제의 다양한 기능? =>
		- 다양한 기능 표현 = 다양한 서브시스템(Subsystems) 표현 = 작은 프로그램 표현
		- 모듈 형태로 존재 = 모듈 형태란 결국 독립적으로 실행 가능한 코드덩어리(집합)
		- 커널 영역에 위치
		- 
	- 운영체제는 하나의 컴퓨터 (시스템)을 관리하고 조정하는 매우 복잡하고 중요한 대규모 프로그램이며, **다양한 기능**들을 내부적으로 포함
	- EX) 다양한 서브시스템-기능 예시
		- 메모리 관리 서브시스템
		- 프로세스 관리 서브시스템
		- 파일 시스템 관리
		- 네트워킹 시스템
		- 입출력 관리 시스템 
		- 
- **OS 핵심기능**
	- 시스템자원 관리 = 하드웨어 자원 관리
	- 관리하다! 표현 = 운영체제가 자원에 접근한다! 표현
	- 운영 체제는 CPU, 입출력 장치, 저장 장치 등의 하드웨어 자원을 효율적으로 분배하고 조정
	- 
	- 1. **메모리 관리** (실행중인 프로그램 관리) = `메모리 관리 서브시스템`
		- 헷갈림 주의
			- 메모리 관리 <> 프로세스 관리 다름.
				- 메모리 관리는 '메모리 할당 및 회수'의 기능
				- 프로세스 관리는 'CPU 사용 시간 및 실행 순서의 관리'의 기능
			- 메모리 관리 <> 저장 장치 관리 다름.
				- 메모리 관리 : RAM(랜덤 액세스 메모리)와 관련된 관리 작업
				- 저장 장치 관리 : 하드 드라이브, SSD와 같은 영구 저장 매체의 관리 담당
				- 
		- 운영 체제는 실행 중인 프로그램들(프로세스)가 한정된 메모리를 효율적으로 사용할 수 있도록 관리 
			- = 물리적 메모리 내에서 적절한 위치에 프로그램이 사용할 공간을 할당하고, 더 이상 필요하지 않을 때 해당 공간을 회수하는 기능
		- 이는 프로그램이 필요로 하는 메모리 자원을 효율적으로 관리하여 시스템의 안정성과 성능을 유지하는 데 필수적
		- 
		- 메모리 관리 시 사용되는 주요 기법/방법들 존재
			- 1, 메모리 페이징(paging)
				- 가상 메모리를 일정 크기의 블록(페이지)으로 분할하여 물리 메모리에 매핑하는 방식
			- 2. 메모리 스와핑(swapping)
				- 가용 메모리가 부족할 때 > 메모리의 사용률을 최적화하기 위해 디스크와 RAM 사이에 데이터를 교환하는 프로세스
				- 메모리가 부족할 때 추가적인 공간을 제공
				- 
		- 참고노트 :  [[메모리-주소체계-주소공간-작동원리\|메모리-주소체계-주소공간-작동원리]]
			- 운영 체제가 논리주소와 물리주소를 관리하는 것은 프로그램이 메모리를 효율적으로 사용하고 접근할 수 있도록 하는 중요한 부분 = 메모리 주소 공간의 구분과 주소 체계는 메모리 관리에 해당하는 운영체제의 기능
			- 
		- [[운영체제-메모리-프로세스-파일관리-이미지#- OS-메모리관리-메모리내부구조-메모리공간-이미지\|운영체제-메모리-프로세스-파일관리-이미지#- OS-메모리관리-메모리내부구조-메모리공간-이미지]]
			- 컴퓨터 메모리는 크게 **커널 영역과 사용자 영역** 2가지로 구분
			- 커널 영역과 사용자 영역? =>
				- [[커널영역-사용자영역\|커널영역-사용자영역]]
			- 왜? > 시스템의 안정성과 보안을 유지하기 위함
			- 복기  `컴퓨터에서 실행되는 모든 프로그램은 실제로 메모리에 할당되어 실행
			- 
	- 2. **CPU 관리** (**프로세스 관리**의 일부)
		- 키워드 : 작업관리자 프로그램 / 프로세스와 스레드 / 프로세스 동기화 / 교착상태 해결 등등
		- [[운영체제-메모리-프로세스-파일관리-이미지#OS-프로세스관리-이미지\|운영체제-메모리-프로세스-파일관리-이미지#OS-프로세스관리-이미지]]
		- 
		- 프로세스 관리 = `프로세스 관리 서브시스템`
		- 여러 프로그램이나 프로세스가 동시에 실행 시 CPU가 자원을 공정하게 사용할 수 있도록 관리! 의미
			- = 해당 관리/과정은 시스템의 효율성을 최적화하고, 사용자 및 다양한 애플리케이션 간의 작업을 조율
			- = 동시다발적으로 생성/실행/삭제되는 다양한 프로세스를 관리
		- 어떤 프로세스에게 CPU 시간을 얼마나 할당할지, 어떤 순서로 프로세스를 실행할지 결정하는 **스케줄링**과 같은 작업을 포함
		- 
		- CPU 스케줄링? =>
			- 운영체제는 크게 3가지 방식으로 CPU에 자원을 할당.
				- 1. 먼저 도작한 작업 
				- 2. 간단한 작업
				- 3. 도착한 순서대로 처리하되 제한시간 존재
				- 
			- 여러 개의 프로그램이 동시에 실행되어야 할 때, 각 프로그램은 CPU 시간을 필요 > 운영체제는 실행되는 프로그램들의 우선순위를 고려해 CPU시간을 할당한다.
				- = 사용자가 여러 작업을 동시에 수행하더라도 각 작업이 원활하게 실행될 수 있도록 보장하는 역할 수행
			- 동시에 실행! 표현 = 빠르게 번갈아 가면서 실행!
			- EX) 
				- 워드 프로세서로 문서 작업을 하고, 동시에 이메일을 확인한다 > 운영 체제는 CPU 시간을 이 세 프로그램 사이에서 효율적으로 분배하여, 모든 프로그램이 마치 동시에 실행되는 것처럼 보이게 함
				- 
	- 3. **저장 장치 관리**
	    - 3.1. 디스크 스케줄링
	    - 3.2. 파티션 관리
	    - 3.3. RAID 구성
	    - 3.4. **파일 시스템 관리**
			- 연관노트 : [[시스템콜-CPU이중모드-과정\|시스템콜-CPU이중모드-과정]]
				- 파일을 저장-관리하기 위한 시스템 호출-명령어 존재
					- EX) 1. 파일 생성 / 2. ~ 삭제 /3. ~ 열기 /4. ~ 닫기 / 5. ~ 읽기 / 6. ~ 쓰기
				- 디렉토리 저장-관리하기 위한 시스템 호출-명령어 존재
					- EX) 1. 디렉토리 생성 / 2. ~ 삭제 / 3. ~ 열기 / 4. ~ 닫기 / 5. ~ 읽기
		   - 1. 파일 생성 및 삭제
		   - 2. 파일 조회 및 수정
		   - 3. 디렉토리 생성 및 삭제
		   - 4. 공간 할당
		   - 5. 메타데이터 관리
		   - 
		- 복기 - `운영체제는 파일 시스템을 가지고 있음`  > 따라서 파일과 데이터를 하드 드라이브, SSD 등 다양한 저장 장치에 저장 및 관리가 가능
		- ==파일 시스템(file system)== =>
			- [[운영체제-메모리-프로세스-파일관리-이미지#- OS-파일시스템-이미지\|운영체제-메모리-프로세스-파일관리-이미지#- OS-파일시스템-이미지]]
			- 정의
				- 데이터를 하나의 집합으로(파일단위) 관리하고 사용하기 위한 방법/시스템/규칙/체계/프로그램
			- 기능/이해
				- 운영체제 내부에는 데이터를 파일과 폴더 형태로 저장하고 관리하는 기능 존재 = 파일 시스템(프로그램) 존재
				- 이 프로그램-기능 덕분에 보조기억장치에 데이터(파일, 폴더)가 저장될 수 있음 + 필요할 때 마다 읽기-접근-사용 가능
			- 운영체제 파일 시스템 관리 기능을 이해하기 위한 내용 존재
				- = 저장매체 관리 + 저장매체에 데이터 저장 + 저장매체 데이터 관리-접근-검색
				- ==파티셔닝, 포매팅== | [[파티셔닝-파티션-포매팅-포맷\|파티셔닝-파티션-포매팅-포맷]]
					- 막 공장에서 생산되어 한 번도 사용된 적 없는 새 하드 디스크 or SSD는 **파티셔닝, 포매팅** 하기 전까지는 사용할 수 X 
					- 파티션 설정은 드라이브를 사용하기 전에 필수적인 단계
						- = 파티셔닝과 포매팅 작업 이후에 파일과 디렉토리 생성 가능
						- 
			- **파일 시스템 구조 이해** 
				- 경로? =>
					- 연관노트 : [[파일경로-절대경로-상대경로-기호표현\|파일경로-절대경로-상대경로-기호표현]]
					- 
				- 복기 : `데이터를 파일과 폴더 형태로 저장하고 관리`
				- 파일 시스템은 데이터를 파일과 폴더 형태로 저장하여 **물리적인 위치**에 기반한 접근을 제공 
				- **이 구조**를 통해 사용자는 파일을 쉽게 찾고, 접근하고, 관리할 수 있습
				- `파일-폴더-트리구조-계층` 이러한 구조에서 특정한 위치에 존재하는 파일에 접근하기 위해선 **경로** 필요 = 물리적인 위치에 기반한 접근
				- 구현 방식이나 특정 기능에서 차이가 있을 수 있을 뿐,  다른 운영체제에서도 기본적으로 파일과 디렉토리 형태를 사용
				- 
				- ==파일== | [[파일시스템-파일단위-이해\|파일시스템-파일단위-이해]]
					- 데이터를 메모리에 저장하고 관리하기 위한 기본 단위
					- 
					- 파일단위 저장 = 파일유형 = 확장자 = 파일 종류 = 연관된 응용 프로그램
					- 따라서 파일단위로 데이터를 저장하면 응용 프로그램간 의존관계가 깊다! 표현 가능
						- = 독립성 
						- = 각 응용 프로그램 간 서로 다른 방식으로 파일 정의/생성 > 데이터 공유 어려움
						- = 해당 파일을 작업하기 위해선 특정 프로그램이 반드시 필요 (단점)
						- = 다른 공간에 있다면 여러 사본 복사 가능 > 중복된 데이터 불일치 발생 가능성 존재
						- = 다수 사용자 동시 접근 x 
					- 이러한 단점을 해결하기 위한 방법으로 **DB 시스템/프로그램** 등장
						- DB => [[IT-개발용어-CS-지식브레인#^a2defd\|IT-개발용어-CS-지식브레인#^a2defd]]
						- 
				- ==폴더(또는 디렉토리)== | [[파일시스템-폴더-디렉토리구조-이해\|파일시스템-폴더-디렉토리구조-이해]]
				- 
			- 위와 같은 구조 + 파일 시스템 기능 이해 > 그렇다면 내부적으로 **어떻게 보조기억장치에 파일 및 디렉토리 데이터가 저장?**
				- = ==파일 할당 방법== | [[운영체제-파일데이터-저장-할당방법\|운영체제-파일데이터-저장-할당방법]]
				- 
				- 운영체제는 파일/디렉토리를 **블록 단위**로 읽고 쓴다 = 블록 단위로 관리! 
				- 연관노트 : [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
				- 주의 : 
					- 플래시 메모리와 운영체제가 데이터를 저장하는 단위에 차이 존재
					- 운영체제 : 대부분의 파일 시스템은 '**블록**' 단위로 데이터를 저장
					- 블록? =>
						- 운영체제의 블록은 일반적으로 하드 드라이브 또는 SSD 상의 연속된 데이터 덩어리로, 파일이나 데이터의 논리적 조각을 추상화한 것
						- ex) 파일 크기 작다 = 적은 수의 블록 차지하면서 저장
			- **다양한 파일 시스템 존재**
				- **파일 시스템 종류** 
					- ==FAT 파일 시스템== | [[FAT파일시스템-프로세스-이해\|FAT파일시스템-프로세스-이해]]
					- ==유닉스 파일 시스템== | [[유닉스파일시스템-프로세스-이해\|유닉스파일시스템-프로세스-이해]]
					- ==리눅스-윈도우-기본파일시스템== | [[리눅스-윈도우-기본파일시스템\|리눅스-윈도우-기본파일시스템]]
					- 
	4. **입출력(I/O) 장치 관리** = `입출력 관리 시스템`
		- 어떤 기능을 수행? =>
		- 컴퓨터는 다양한 `입출력 장치(키보드, 마우스, 프린터 등)`를 통해 데이터를 송수신 > 다양한 입출력 장치들을 효율적으로 **관리**
			- + 관리하다 = 장치들과 운영체제 간의 상호작용을 조율하는 역할 수행
		- 관리하는 기능을 수행하기 위해 입출력 관리 시스템 내부에는 다양한 **장치 드라이버 프로그램**들이 존재하며, 이들 각각은 특정 하드웨어 장치를 위한 인터페이스 기능을 제공
		- 장치 드라이버 프로그램? =>
			- 장치 드라이버는 입출력 관리 시스템의 중요한 구성 요소
			- 다양한 장치들이 존재 > 따라서 모두 각각 규격/규칙 존재 > 이러한 하드웨어 장치의 세부적인 제어와 통신을 담당하면서, 운영체제와 하드웨어 장치 간의 호환성과 통신을 보장
			- 해당 프로그램 덕분에 사용자 또는 입출력장치에서 발생한 데이터가 필요한 다른 애플리케이션은 복잡한 세부 사항을 알 필요 없이, 운영체제를 통해 일관된 방식으로 하드웨어 장치를 이용할 수 있게 됨
		- EX) 
			- 문서를 프린트하는 동안에도 인터넷에서 파일을 다운로드 진행 > 운영 체제는 프린터로 보내는 출력 작업과 인터넷에서의 파일 다운로드를 동시에 관리하여, 이 두 작업이 서로 방해받지 않도록 조정






##### ㅡ 
- 내 컴퓨터 = 로컬PC = 클라이언트 PC 영역
- ### 3. 소프트웨어-SW-Software :
- 포괄하는 개념의 범위에 따른 차이는 존재하나 교차해서 사용 가능
	- ##### 소프트웨어 용어 : 
	- 하드웨어/컴퓨터 위에서 실행될 수 있는 모든 종류의 프로그램과 데이터 모두를 지칭 (따라서 데이터도 소프트웨어다! 표현 가능)
	- 
	- ##### 프로그램 (Program) 용어 : 
	- 컴퓨터에는 다양한 소프트웨어와 프로그램들이 설치되어 있으며, 사용자는 이러한 프로그램을 실행하여 사용
	- 특정 프로그램을 설치할 때, 그 프로그램을 실행하기 위한 **실행파일**(`.exe` 파일 등)이 함께 설치됨
		- 실행파일? =>
		- 모든 프로그램에는 사용자가 실행할 수 있는 실행 파일이 존재 > 이 실행 파일을 통해 프로그램이 메모리에 로드되어 실행되는 것
		- 이 파일은 소프트웨어의 주요 기능을 구동시키는 데 필요한 코드가 포함
		- Windows 시스템에서는 주로 `.exe` 형식의 실행 파일
		- macOS에서는 `.app` 패키지
		- Linux에서는 주로 스크립트나 바이너리 파일이 실행 파일의 역할
	- 사용자가 바탕화면이나 프로그램 메뉴에서 아이콘을 클릭하면, 이 실행 파일이 GUI(그래픽 사용자 인터페이스) 방식으로 실행되어 프로그램의 기능을 제공
	- 즉, 자연스럽게 사용하던 상황에서 이러한 내부 동작과정이 있었음
	- 
	- 
	- 컴퓨터 내에서 실행되는 모든 것을 '프로그램'이라는 용어로 칭할 수 있음. 모든 소프트웨어는 궁극적으로 개발자에 의해 작성된 코드의 집합이기 때문
	- 일련의 지시사항으로 구성되어 특정 작업을 실행하도록 컴퓨터에 명령하는 소프트웨어 = 컴퓨터에게 특정 작업을 수행하도록 지시하는 명령어들의 집합 
	- EX) 
		- 사용자 > 컴퓨터 명령 X
		- 사용자 > 프로그램 > 컴퓨터 명령 O
		- 
- 그 기능과 용도에 따라 구분되는 더 구체적인 용어들이 존재 =>
	- **응용 프로그램(Application Software)** = **애플리케이션(Application)** = **앱(App)** 
		- 애플리케이션(Application)' 또는 줄여서 '앱(App)'이라는 용어는 사실 '응용 프로그램'과 동일한 의미로 사용 (모바일 환경에서는 '앱(App)')
		- 응용 프로그램이라는 표현 사용 시 일반적으로 사용자가 직접 자신의 컴퓨터나 모바일 기기에 설치하여 사용하는 소프트웨어를 가리킴
		- EX) 
			- 문서 작성을 위한 워드 프로세서, 이미지 편집을 위한 그래픽 디자인 소프트웨어, 게임 애플리케이션 등이 여기에 속합
			- 
		- 실행되는 환경 차이에 따른 용어 구분 =>
		- 1. **웹 애플리케이션**(응용 프로그램) (Web Application) ? =>
			- 주의 : 웹 <> 웹 어플리케이션 의미 차이 존재
				- 웹(web) 용어 
					- 일반적으로 '월드와이드웹(World Wide Web, WWW)'의 줄임말
					- 전 세계적인 정보 공간을 의미 
						- = 온라인, 네트워크 기반의 상호작용과 서비스를 제공하는 영역
						- = 기술, 서비스, 프로토콜의 집합을 의미하며, 이는 특히 정보와 서비스가 상호 연결된 전 세계적인 인터넷-네트워크-통신망를 지칭 > 서로 연결된 수많은 문서와 기타 리소스를 액세스할 수 있는 시스템
					- 이는 웹 페이지, 웹 사이트, 웹 어플리케이션 등을 포함하는 포괄적인 용어
					- **웹**은 네트워크 기반의 인프라와 서비스의 집합을 말하고, **웹 어플리케이션**은 그 위에서 동작하는 특정 프로그램을 지칭
				- ==다양한 웹 기술 존재== | [[IT-개발용어-CS-지식브레인#ㅡ 4. **웹 기술** - 큰 개념\|IT-개발용어-CS-지식브레인#ㅡ 4. **웹 기술** - 큰 개념]]
					- 
			- 웹 애플리케이션은 서버와 클라이언트 모델을 기반으로 동작하는 프로그램.
			- 클라이언트 측에서는 주로 웹 브라우저를 통해 사용자와 상호 작용하며, 서버 측에서는 데이터 처리와 스토리지 관리를 담당하는 프로그램
			- 이 용어는 `웹 브라우저`를 통해 접근하고 사용하는 소프트웨어를 의미  > 사용자는 이러한 프로그램을 자신의 장치에 직접 설치하지 않고, 인터넷을 통해 서비스에 접속 후 사용.
			- EX)
				- 웹 메일, 온라인 문서 편집 도구, 소셜 네트워킹 서비스 등이 웹 응용 프로그램의 예시
				- **웹 브라우저(프로그램) =>**
				- 종류
					- 구글-크롬-Chrome 
					- MS-엣지-Edge
					- Mozilla-파이어폭스-Firefox
					- 애플-사파리-Safari
					- 오페라-Opera
					- 
				- 인터넷 콘텐츠(html 문서, 이미지, 동영상 등)를 검색-요청하고 요청받은 것을 보여주는 기능
				- 동작과정
					- 사용자가 브라우저에 웹사이트 주소 입력 > 브라우저가 서버에 해당 주소에 대한 데이터를 요청한다 > 서버가 요청에 대한 응답을 보내준다. > 브라우저가 서버가 보내준 데이터를 로컬 pc 사용자가 볼 수 있도록 해석 후 실행/출력해 보여준다.
					- 
		- 2. **앱**(APP)? =>
			- 동작 정보 원본 위치 : 앱 프로그램이 동작하기 위한 정보는 사용자 기기쪽에 존재
			- 모바일 앱 개발에 사용되는 Kotlin(안드로이드), Swift(iOS)
			- 웹/앱 용어 존재
				- 이 용어는 때로 이 두 환경 모두를 지원하는 어플리케이션에 사용
					- = 웹 기술/앱 기술 양쪽 특성을 결합한 기술이나 서비스에 사용
					- EX) 
						- 많은 서비스들은 웹 어플리케이션과 모바일 어플리케이션 형태 모두를 제공하여, 사용자가 PC에서는 웹 버전을, 모바일 기기에서는 앱 버전을 사용 가능
				- 
	- **시스템 소프트웨어**(System Software) = (운영체제 프로그램) = (운영체제 내부 프로그램): 
		- 컴퓨터 하드웨어와 다른 소프트웨어 어플리케이션 간의 상호작용을 관리하고, 기본적인 시스템 작업을 처리하는 역할
			- = 기본적인 기능을 실행하며, 응용 프로그램들이 효율적으로 작동할 수 있는 환경을 제공하는 프로그램
			- 
		- > 따라서 **펌웨어**도 시스템 소프트웨어로 분류할 수 있음
		- 펌웨어(Firmware)? =>
			- 특정 하드웨어의 기본적인 제어와 관리를 담당하는 소프트웨어로, 하드웨어 내에 영구적으로 설치되어 그 하드웨어가 의도한 대로 작동할 수 있도록 도움
			- 단순 제어만 필요한 기기(자동차 네비게이션 등)의 읽기 전용 메모리(rom)에 탑재된 기초 소프트웨어
			- 
		- > 따라서 운영체제(프로그램) = 시스템 소프트웨어 한 예
		- 보통 운영 체제와 밀접하게 연관된 프로그램을 의미함 > 따라서  **유틸리티(프로그램)** 도 시스템 소프트웨어의 일부분으로서 시스템 관리와 관련된 특정 기능을 수행
		- 유틸리티 프로그램? =>
			- EX)
				- 디스크 조각모음
				- "방화벽 프로그램" 같은 보안 유틸리티는 컴퓨터를 외부 위협으로부터 보호하는 역할 수행
			- 운영체제와 **함께 제공**되거나 **별도**로 **설치**될 수 있는 작은 프로그램들을 말합
				- = "운영체제와 함께 작동하여 특정 시스템 관리 또는 최적화 기능을 제공하는 소프트웨어"
				- = 유틸리티 프로그램이 운영체제의 일부로 통합될 수도 있고, 독립적으로 설치될 수도 있다
			- 이들은 특정 기능을 수행하여 사용자가 시스템 관리와 최적화 작업을 편리하게 할 수 있도록 함
			- 
	- **악성코드(Malware)**
		- 이는 시스템을 해치거나 무단으로 정보를 수집하려는 목적으로 설계된 소프트웨어 프로그램
		- 악성코드는 바이러스, 스파이웨어, 랜섬웨어 등 다양한 형태로 존재하며, 일반적으로 부정적인 또는 해로운 목적 가짐


##### ㅡ 
- # 2. 서버컴퓨터 영역 : 
- 서버 = 컴퓨터 > 따라서 로컬PC 영역처럼 CPU/메모리 등 하드웨어들이 존재
- 상황예시
	- 서버측 PC에서 메모리가 초과되는 경우 존재 = 메모리 저장 공간 부족 > 서버 에러 메세지 발생
	- EX) 네이버 티켓 구매 웹 사이트에서 한번에 많은 요청/트래픽 발생한 경우 
	- 상황예시=>
		- 
- ### 데이터베이스 프로그램/시스템/서버 존재 =>
- 사용자들의 정보 저장 목적
		- 
- ### 백엔드시스템/영역 존재 =>
- 백엔드 - Backend 의미
	- 일반 사용자에겐 보이지 x 영역
		- = 프론트엔드 영역에서 요청 or 발생한 정보/동작들을 제어하는 시스템 안쪽 영역
		- = 클라이언트쪽의 요청을 처리하는 수 많은 로직들이 정의되어 서버에서 해석되고 실행되는 영역
		- ex) 개인정보 암호화 처리, DB에서 요청한 자료 호출 등


##### ㅡ 
- # 3. 인터넷-네트워크-(통신망/기기) 영역 :
- <span style="background:#d3f8b6">인터넷-네트워크-통신망-이미지</span>
	- ![[Pasted image 20240326181126.png\|Pasted image 20240326181126.png]]
	- 복기 : `**네트워크 영역**: 이들 기기와 서버들을 연결하는 통신망`
	- 통신망이 존재해야 **클라이언트pc** <> **서버pc** 상호작용 가능
	- 
- **용어정리**
	- URL(Uniform Resource Locator) =>
		- 인터넷-네트워크-통신망에서 웹사이트 주소
		- 형식 
			- `통신규칙://인터넷 호스트 주소/경로 이름`
			- 
	- 클라이언트, 서버 용어 =>
		- 관점의 차이에 따른 용어
			- EX) 
			- 내 컴퓨터가 데이터를 요청하고 있다면 > 내 PC = 클라이언트 PC
			- 내 컴퓨터가 데이터를 보내주고 있다면 > 내 PC = 서버 PC
		- 클라이언트(client) 용어
			- 사용자가 보는 화면에서 데이터를 요청하는 컴퓨터/프로그램 의미
			- EX) 웹 브라우저, 사용자PC, 핸드폰
		- 서버(server) 용어
			- 클라이언트쪽 요청에 따른 응답을 제공하는 컴퓨터/프로그램/시스템 의미
			- ex) 웹 서버, DB서버, 파일서버
			- 
			- 서버 PC가 실제로 서버로서 기능하기 위해서는 서버 역할을 수행할 수 있는 **특정 소프트웨어**가 설치되어 있어야 합
			- EX)
				- 웹 서버 >  **아파치(Apache)나 Nginx** 같은 웹 서버 소프트웨어가 설치
					- 아파치-엔진엑스? =>
					- 어떤 기능 수행
						- 이 프로그램은 웹 요청을 처리하고, 웹 페이지나 다른 파일들을 클라이언트(브라우저)에 전달하는 역할 = 네트워크를 통해 들어오는 HTTP 요청을 받아들이고, 적절한 응답을 생성하여 사용자에게 제공함으로써 웹 커뮤니케이션을 가능하게 합
					- 복기 : `관점의 차이에 따른 용어`
						- 따라서 **상황**에 따라서 사용자의 개인 컴퓨터(PC)에서도 아파치 웹 서버 프로그램을 설치해 서버pc로서 동작하도록 할 수 있음.
						- 어떤 상황?
							- 개인 컴퓨터에서 아파치를 설치하는 주된 이유는 개발 환경을 설정하거나 로컬 네트워크 내에서 웹 서비스를 테스트하기 위함
							- 실제 웹 서버에 배포하기 전에 애플리케이션의 기능과 성능을 사전에 점검
				- 데이터베이스 서버 >  MySQL이나 PostgreSQL과 같은 데이터베이스 관리 시스템이 필요
			- 서버 소프트웨어가 없는 컴퓨터는 기술적으로/하드웨어 수준에서 서버 컴퓨터로 구성되어 있을뿐, 일반 클라이언트 컴퓨터와 동일하게 작동
				- = 실제 서버로서의 기능을 수행할 수 x
				- + 위 이미지 확인 : `모니터가 없는 pc > 서버pc로 사용하기 위해 하드웨어 수준으로 구성한 것`
		- 주의
			- 서버라는 용어는 반드시 물리적인 PC를 의미하진 X
			- 서버는 네트워크 상에서 데이터를 제공하거나 특정 서비스를 수행하는 기능을 가진 **장치**나 **소프트웨어**를 의미
- **의미**
	- 전 세계 컴퓨터가 인터넷 **프로토콜(TCP/IP)** 덕분에 서로 연결되어 정보를 교환할 수 있게 되어 생성된 하나의 거대한 통신망
	- 
- **프로토콜**
	- 비유를 통한 인터넷 네트워크 통신망과 프로토콜 이해 =>
		- **인터넷 네트워크 통신망**은 데이터가 이동할 수 있는 광범위한 영역/도로망
		- **각 프로토콜**은 이 도로망 내에서 특정 목적에 맞는 차량(데이터 패킷)이 효율적으로 이동할 수 있는 규칙과 경로를 제공
		- 네트워크 진단 데이터가 이동해야 하는 상황이라면 > TCP 프로토콜-경로-도로가 도로망위에 깔리고 > 그 위에 ICMP 프로토콜-규칙-도로가 깔리는 느낌 > 이렇게 목적지까지 도로가 깔리면 차량(데이터 패킷)이 이동하면서 데이터가 상호작용 되는 느낌
		- 
	- 단순한 의미/정의/기능 =>
		- 프로토콜은 데이터를 **어떻게 주고받는 방법**,  **어떤 형식**, **순서** 등 통신 규칙-규약 
		- 이 규칙들 덕분에 서로 다른 하드웨어와 소프트웨어 구성을 가진 컴퓨터나 네트워크 장비들이 서로 효과적으로 **통신**할 수 있습 
			- = 일관된 처리 + 안정적인 교환 가능
			- = 표준화된 절차 제공함 
			- = 다양한 네트워크 장비 <> 기술 서로 호환
			- 
		- 복기 : `모든 프로그램은 사실 수많은 코드 파일/코드로직덩어리로 이루어져 있음`
			- 프로토콜도 특정 기능을 수행하도록 **코드**로 정의된 '**규칙의 집합**' 표현 가능 > 이를 통해 프로토콜이 단순한 약속이 아니라, 실제로 기능적 구현을 포함하는 코드 기반의 구조임 
			- 
	- "프로토콜(TCP/IP)" 표현 사용하는 이유 =>
		- `프로토콜!`을 언급할 때 이 두 프로토콜을 함께 언급하는 이유는, 대부분의 인터넷 통신이 이 두 프로토콜에 의존하고 있기 때문 = 기본이 되는 프로토콜!
		- 
		- 요약 :  TCP/IP **프로토콜 스위트**의 경우, TCP는 데이터 전송의 신뢰성과 순서를 보장하고, IP는 데이터 패킷의 라우팅을 처리하는 등 각각의 프로토콜이 특정 역할을 수행하지만, 이들이 함께 작용하여 인터넷과 같은 네트워크에서 효과적인 데이터 교환을 가능하게 합
			- 프로토콜 스위트=>
			-  프로토콜 스위트는 TCP, IP를 비롯하여 ARP, ICMP 등 다양한 네트워크 프로토콜들을 포함
		- 비유이해
			- 컴퓨터가 여러 하드웨어와 소프트웨어 요소들이 모여서 전체적인 기능을 수행하는 시스템인 것처럼, 특정한 네트워크 기능을 수행하기 위해 여러 프로토콜이 함께 동작해야 합
			- 각각의 프로토콜들이 상호 연동되어 전체적인 네트워킹 목적을 달성하는 것을 효과적으로 설명하기 위해 "스위트"라는 용어를 사용
			- "스위트"라는 용어는 개별 프로토콜이 독립적으로 작동하는 것이 아니라, 여러 프로토콜이 서로 보완적으로 작동하여 네트워크의 복잡한 요구사항을 충족시킬 수 있도록 하는 집합체를 의미
			- 즉, TCP/IP는 실제로 하나의 프로토콜이 아니라, 이 두 가지 프로토콜이 모여 >  핵심적인 역할 수행
			- 
	- ==종류 =>== [[프로토콜-종류\|프로토콜-종류]]
		- 다양한 프로토콜들이 존재 > 각각 고유한 역할을 가지고 있음 하지만 (웹 페이지 로드와 같은 )특정-대부분 상황에서 여러 프로토콜이 함께 작동하여 특정 작업을 완료됨
			- `다양한 프로토콜들이 존재` 표현=>
			- 네트워크 상에는 데이터 교환이 이루어지는 **다양한 맥락/상황** 존재 > 해당 상황에 따른 최적의 통신 방식과 데이터 전송 프로토콜이 선택되어 사용됨
		- 즉 여러 프로토콜이 각기 다른 단계에서 서로 다른 역할을 수행하면서 전체 인터넷 통신과 웹 페이지 로딩 과정이 원활하게 이루어집
		- 
	- **포트번호**
		- 표준화 정의? =>
			- 이 포트 번호들은 인터넷 표준화 기구에 의해 정의되고, 일반적으로 이 포트를 사용하여 해당 서비스를 제공
			- EX) 
				- SSH는 (안전한 원격 접속을 위해)보통 TCP 포트 22를 사용
				- HTTP는(웹 서버와 클라이언트 간의 통신을 위해) TCP 포트 80을 사용
			    - HTTPS는 (보안이 강화된 웹 통신) TCP 포트 443을 사용
		- ㅡㅡㅡㅡ본문내용
		- 프로토콜과 포트는 데이터 통신을 위해 필수적이며, 각 프로토콜에 할당된 포트 번호는 해당 프로토콜의 데이터 트래픽을 구분하고 관리하는 데 사용
			- = 포트 번호는 해당 프로토콜의 표준 통신 엔드포인트를 나타냄
		- 각 네트워크 프로토콜은 특정 포트 번호와 연관되어 있으며, 이 포트 번호는 해당 프로토콜의 데이터 통신을 위해 **표준화**되어 **정의**되어 있습
		- 
		- **포트번호 존재이유 =>**
			- 이렇게 정해진 포트 번호를 통해 네트워크 상에서 데이터가 올바른 서비스나 애플리케이션으로 정확하게 전달될 수 있습
				- = 데이터를 안전하고 효율적으로 전송
			- 네트워크 보안을 관리하는 데 중요한 역할
				- = 설정한 사용자와 서버 간의 통신을 원활하게 하고, 설정하지 않은 불필요하거나 위험한 접근을 차단하는 데 도움을 줍
				- 
		- 포트번호-사용예시
			- 보안 그룹 설정
				- AWS에서 보안 그룹을 설정할 때, `HTTP`를 선택하면 포트 80이 자동으로 열립 > 이는 웹 서버에 대한 접근을 허용하기 위함
				- 
	- ==다양한 맥락/상황==
		- 데이터 교환 상황에 따라 주체는 매번 달라질 수 있음
		- **정보 조회 목적 데이터 교환** 
			- 주로 **사용자의 PC(클라이언트)** 와 **웹 서버(서비스 제공자의 PC)** 간에 이루어집
		    - = 사용자가 웹 브라우저를 통해 웹 페이지에 접근하고자 할 때, 다음과 같은 과정이 진행
		    - 
		    - 상황예시 - 웹 페이지 로딩 과정
			- 요약 : `A규칙을 기반으로 이 위에 B규칙 실행`
			- 연관노트 : [[DNS-DHCP-서버이해-웹작동과정\|DNS-DHCP-서버이해-웹작동과정]]
				- TCP는 마치 운영체제와 같이 기본적인 네트워크 연결과 데이터 전송의 안정성과 순서를 담당하며, HTTP와 같은 프로토콜은 이 위에서 동작하는 응용 프로그램처럼 작동하여 특정 형태의 데이터 교환(웹 페이지의 요청 및 응답)을 처리
				- 즉 TCP는 데이터 전송의 신뢰성을 보장하며, HTTP는 그러한 안정적인 연결 위에서 사용자의 요청에 따라 웹 서버와 통신하는 구체적인 규칙과 형식을 제공
				- **웹 브라우저에서 URL 입력**: 
					- 사용자가 브라우저의 주소창에 웹사이트의 URL을 입력
				- **DNS 조회**: `DNS 서버와의 상호작용에서는 TCP를 사용`
					- 브라우저는 URL의 도메인 이름을 IP 주소로 변환하기 위해 DNS(Domain Name System) 서버에 조회를 요청
				- **TCP 연결 설정**: 
					- 브라우저는 서버의 IP 주소에 대해 TCP(실행) 연결을 시작
					- 이 과정은 TCP 프로토콜을 사용하여 데이터 전송의 신뢰성을 보장
				- **HTTP 요청 전송**: `웹 서버와의 상호작용에서는 HTTP 프로토콜이 사용`
					- TCP 연결이 성공적으로 설정되면, 브라우저는 HTTP 프로토콜을 사용하여 웹 서버에 웹 페이지 데이터를 요청
				- **서버 응답**: 
					- 웹 서버는 HTTP 요청을 받고, 요청된 웹 페이지를 브라우저로 다시 보냅
				- **데이터 수신 및 렌더링**: 
					- 브라우저는 서버로부터 데이터를 받고, 이를 사용자에게 표시할 웹 페이지로 렌더링
					- 
		- **네트워크 진단 데이터 교환** 상황 
			- ICMP? =>
			    - 노트 확인
			- 호스트 ? =>
				- '호스트' 용어는 네트워크에 연결된 어떠한 기기를 지칭. 
					- = 호스트는 다양한 형태의 네트워크에 연결된 모든 기기를 의미하며, 컨텍스트에 따라 그 정의가 달라질 수 있음
				- EX)
					- 1. 또 다른 사용자의 PC
					- 2. 서버 PC
					- 3. 네트워크 기기
						- + 네트워크 프린터, 라우터, 스위치, 방화벽 등과 같은 네트워크 기기들도 호스트로 간주될 수 있음
			- ==패킷==? => [[패킷-데이터전송-담는단위-정보요소\|패킷-데이터전송-담는단위-정보요소]]
			- ㅡㅡㅡㅡ본문내용
			- 주체 : **사용자의 PC**와 **네트워크 내 다른 호스트** 간 발생
			    - = 네트워크 진단을 위해 **ICMP 프로토콜**을 사용한 데이터 교환
			- 사용자의 PC(출발지 호스트)는 대상 호스트(목적지 호스트)에게 ICMP **에코 요청**을 보냅
			- 대상 호스트는 이 요청에 대해 에코 응답을 보내어 네트워크 연결 상태, 지연 시간, **패킷** 손실 등을 평가할 수 있게 함
		    - 상황예시
				- 사용자는 `ping` 명령을 사용하여 네트워크의 연결 상태를 확인 가능
				- <span style="background:#d3f8b6">네트워크진단-ping-예시코드</span> | [[프로토콜-종류#- 네트워크진단-ping-예시코드\|프로토콜-종류#- 네트워크진단-ping-예시코드]] 
				- 코드설명 =>
					- `ping www.google.com` 명령을 실행할 때, 사용자의 컴퓨터는 'ICMP 에코 요청' 패킷(데이터 단위-상자)을 google.com의 서버로 보냅
					- 이 패킷은 사용자의 컴퓨터로부터 시작하여 여러 네트워크 노드를 거쳐 목적지 서버에 도달 > 서버는 이 요청을 받고 'ICMP 에코 응답' 패킷을 사용자의 컴퓨터로 다시 보냅 
					- 이때 사용자의 컴퓨터는 에코 요청 패킷을 보내고 응답 패킷을 받는 데 걸린 총 시간(라운드트립 타임)을 측정 > 이 과정을 통해 패킷 손실이 없고 라운드트립 타임이 기대치 내에 있으면 네트워크 연결 상태가 양호한 것으로 판단
					- 
		- **파일 전송 > 인한 데이터 교환**
			- 주체 : 사용자의 PC가 파일 서버에 접속하여 파일을 업로드하거나 다운로드하는 상황에서 발생 > 여기서 주체는 **사용자의 PC**와 **파일 서버**
				- = 사용자가 파일을 업로드하거나 다운로드할 때 사용되는 프로토콜 상황 존재
			- FTP, SFTP 기반 > 데이터 교환 발생
			- 이 상황은 데이터의 크기와 보안이 중요한 요소로 작용
		- **실시간 통신 데이터 교환 상황**
			- 주체 : **통신하는 각각의 단말기** (예: 스마트폰, PC 등) 간에 데이터를 교환
			- 음성이나 비디오 통화와 같이 실시간으로 데이터를 교환하는 상황
			- 이러한 경우에는 낮은 지연시간과 높은 데이터 전송률이 요구되며, 주로 RTP(Real-time Transport Protocol) 같은 프로토콜을 사용
		- **이메일 교환 상황**
			- 이메일 서비스와 클라이언트 간의 데이터 교환은 SMTP(Simple Mail Transfer Protocol), IMAP(Internet Message Access Protocol), POP(Post Office Protocol) 등을 포함
		- **VPN을 통한 데이터 교환**: 
			- 가상 사설 네트워크(VPN)을 통한 데이터 교환은 데이터를 암호화하여 보안을 강화
			- VPN은 인터넷을 통해 안전하게 연결을 구성할 수 있도록 도와줍
			- 
- **네트워크 트러블슈팅**
	- 의미 :  이 용어는 네트워크의 복잡한 이슈를 파악 > 진단 > 문제해결 및 예방해 나가는 전체 과정을 포괄 
		- = (인터넷-네트워크-통신망에서 발생하는 문제를 해결하는 과정)
		- 
	- 트러블슈팅을 위해 **데이터 교환 정보**를 활용함 
	- 왜? : 문제를 식별 및 해결하는 데 매우 중요한 정보
	- 
	- **트러블슈팅 프로세스** =>
		- 복기 :
			- `다양한 데이터 교환하는 상황 존재`
			- `대부분 상황에서 여러 프로토콜이 함께 작동하여 특정 작업을 완료됨`
		- 이와 같이 네트워트 문제는 다양한 이유로 발생하기 때문에 네트워크 트러블슈팅은 복잡한 과정
		- 
		- 1. 문제 식별 = 상황파악
			- 다양한 문제상황
				- 네트워크에서 데이터 교환이 지연되거나 실패하는 경우
				- 패킷 손실이 발생
				- 응답 시간이 예상보다 긴 경우
			- > 이러한 상황이라면 이는 네트워크 혼잡-성능 문제, 구성 문제, 하드웨어 결함이 있다는 지표가 될 수 있음
		- 2. 성능 모니터링 = 데이터 교환에 관련된 통계를 기록
			- 이를 통해 네트워크의 성능 변화를 시간에 따라 추적하고, 이상 징후를 조기에 식별 가능
		- 3. 경로 추적
			- 트레이스라우트(Traceroute)와 같은 도구를 사용하여 데이터 패킷이 네트워크를 통과하는 경로를 추적할 수 있습 > 이를 통해 데이터 교환이 **지연**되거나 차단되는 **위치**를 파악하고, 문제의 원인이 되는 네트워크 세그먼트나 장비를 식별
		- 4. 원인 분석
			- 데이터 교환 정보를 분석하여 문제의 원인을 규명
			- 예시상황
				- 예를 들어, `ICMP 에코 요청`이 특정 네트워크 노드에서 일관되게 손실되는 경우, 해당 노드에서 문제가 발생했을 가능성을 검토
		- 5. 문제 해결:
			- 요약 : 문제를 해결한다 = `네트워크 설정 조정` / `장비 교체/수리` 
			- 데이터 교환 정보를 바탕으로 네트워크 설정을 조정하거나, 장비를 교체/수리하고, 네트워크 구성을 최적화하여 문제를 해결
			- 
		- 네트워크 문제가 발생했을 때, 네트워크 관리자가 우선적으로 확인해야 하는 **구성 요소**들 존재
		- 문제 해결 과정에서 각 구성 요소를 체계적으로 확인하고, 문제의 원인을 단계별로 좁혀가는 접근 방식이 중요
			- `컴퓨터 = 하나의 시스템에 문제가 발생하면 다양한 구성요소들을 확인해야 하는 것처럼 > 인터넷-네트워크 통신망 문제가 발생하면 다양한 구성요소들을 단계적으로 모두 확인`
		- 네트워크-시스템 다양한 구성요소 =>
			- 1. **라우터**와 **스위치** 확인
				- 의미/기능
					- 네트워크 트래픽을 관리하고 데이터 패킷을 올바른 목적지로 라우팅하는 중요한 역할
				- 관리자는 이 장비들의 상태와 구성, 로그 파일 등을 확인하여 네트워크 연결 문제나 성능 저하의 원인을 파악
			- 2. **네트워크 인터페이스 카드 (NIC)** 확인
				- 장애가 있는 NIC는 네트워크 연결 문제의 직접적인 원인이 될 수 있음 > 각 네트워크 장비와 컴퓨터에 설치된 NIC의 상태도 중요
			- 3. **케이블**과 **포트** 확인
				- 물리적 연결 문제도 흔한 네트워크 문제 중 하나 = 케이블이 손상되었거나 제대로 연결되지 않았다면 네트워크 문제가 발생할 수 있습
			- 4. **방화벽**과 **보안 설정** 혹인
				- 네트워크 보안 장비와 설정이 너무 제한적이거나 잘못 구성되었을 때도 연결 문제나 성능 저하가 발생할 수 있음 > 관리자는 방화벽 규칙과 기타 보안 설정이 네트워크 트래픽을 적절히 허용하고 있는지 검토해야 합
			- 5. **서버**와 **호스팅된 애플리케이션**
				- 서버 문제 또는 서버에서 실행 중인 애플리케이션의 문제는 네트워크를 통한 서비스 제공에 영향을 줄 수 있습 > 서버의 상태, 애플리케이션 로그, 리소스 사용량 등을 확인
			- 6. **DNS 설정** 확인
				- DNS 문제는 웹사이트 접근 실패나 네트워크 리소스 접근 지연의 원인이 될 수 있습 > DNS 서버 설정과 해석 과정을 확인
			- 7. **DHCP 서버**
				- 네트워크 내의 장비들이 올바른 IP 주소를 받아 사용하고 있는지 확인해야 하며, DHCP 서버의 상태와 구성을 점검해야 합






##### ㅡ 
- # 4. 클라우드 = 가상서버-PC 영역
- **클라우드 기술 등장 배경**
	- 기술의 발전으로 다양한 곳에서 데이터를 탐지하고 수집이 가능해짐 = 폭발적으로 **늘어난 데이터**의 양 > 이러한 데이터를 관리-처리하기 위한 새로운 방법 필요
	- 늘어난 데이터? =>
		- 1. 사람에게 발생한 데이터
			- ex) 
			- 사람이 직접 컴퓨터에서 파일/데이터 생성
			- 네트워크 환경에 글, 이미지, 영상, 댓글 등 데이터를 남김
		- 2. 기기에서 발생한 데이터
			- ex) 
			- 다양한 IT기기에서 남겨진 다양한 로그(log) 정보
			- 사물인터넷(IoT) 센서에 인식되는 정보
- **클라우드 핵심기술**
	- 1. 서버 가상화
		- 별개의 각각 서버들을 소프트웨어를 이용> 병렬로 연결 > 마치 하나의 서버처럼 사용하게 만드는 기술
	- 2. 분산처리 기술
		- 서버 가상화로 인해 병렬로 연결된 서버의 두뇌에 해당하는 각각의 CPU에 하나의 작업을 나눠서 처리하게 만드는 기술
		- 빠른 연산처리 가능
- **클라우드 서비스 유형**
	- 1. **IaaS (Infrastructure as a Service)**
	    - 주로 기업에서 많이 사용하는 클라우드 유형으로, 사용자는 제공되는 가상화된 하드웨어 위에 자신의 운영체제, 애플리케이션 등을 직접 설치하고 관리할 수 있습
	    - **비유 예시**: 가상의 컴퓨터를 사용하기 위해 필요한 것 중에서 '하드웨어'만 제공받고, 나머지 '운영체제'와 '소프트웨어/응용 프로그램'은 사용자가 직접 구축하여 사용하는 형태
	- 2. **PaaS (Platform as a Service)**
	    - 애플리케이션 개발과 배포를 위해 필요한 운영체제, 개발 환경, 데이터베이스 등의 플랫폼을 제공하는 클라우드 유형
	    - **비유 예시**: 가상의 컴퓨터를 사용하기 위해 필요한 것 중에서 '하드웨어'와 '운영체제'는 제공받고, '소프트웨어/응용 프로그램' 개발은 사용자가 직접 수행하는 형태
		- 상황예시=>
			- PaaS (Platform as a Service)는 특히 개발자에게 매우 유익한 클라우드 서비스 모델
			- **개발 속도 향상**: PaaS는 사전 구성된 기능을 제공하기 때문에 개발자는 인프라 설정과 관리에 시간을 쓸 필요 없이 애플리케이션 개발에 집중 가능
			- **비용 효율성**: 하드웨어 구매, 소프트웨어 라이선싱, 인프라 유지보수 등에 드는 비용을 절감
				- PaaS 제공자가 서버, 스토리지, 네트워킹 등의 인프라를 관리함으로써 초기 및 지속적인 운영 비용이 감소
			- **확장성과 유연성**: PaaS는 수요에 따라 자원을 쉽게 확장하거나 축소할 수 있는 유연성을 제공 > 이는 특히 변동성이 큰 애플리케이션에 이점을 제공
			- **다양한 개발 도구와 언어 지원**: PaaS는 다양한 프로그래밍 언어, 라이브러리, 서비스를 지원하여 개발자가 선호하는 도구를 사용할 수 있게 합
			- 
	- 3. **SaaS (Software as a Service)**
	    - 완전히 구성된 애플리케이션을 네트워크(주로 인터넷)를 통해 제공하며, 사용자는 소프트웨어를 직접 관리할 필요 없이 사용할 수 있는 서비스
	    - **비유 예시**: 가상의 컴퓨터를 사용하기 위해 필요한 '하드웨어', '운영체제', '소프트웨어/응용 프로그램' 모두를 완전히 구축된 상태로 제공받아 바로 사용할 수 있는 형태
- **클라우드 기술 정의/특징**
	- 어떻게 확보?
		- AWS, Google, MS와 같은 클라우드 컴퓨팅 회사에서 구축한 데이터센터 자원을 빌려서 사용 하고, 사용한 만큼의 비용을 지불
	- 클라우드 인프라?
		- 클라우드 서비스는 사용자에게 가상 컴퓨팅 자원 = 가상 서버(pc)을 제공 
	- ㅡㅡㅡㅡ본문내용
	- 클라우드 컴퓨팅 = 가상 컴퓨팅 서비스 = 컴퓨터 자원/리소스 = 클라우드 인프라 이용 = 데이터센터 컴퓨터 자원 이용
	- 클라우드 컴퓨팅은 인터넷을 통해 가상의 서버, 스토리지, 데이터베이스, 네트워킹, 소프트웨어 등 가상의 컴퓨팅 서비스의 접근/제공
	-  **물리적 서버** 없이 (사용자 입장에서)**가상의 클라우드 인프라**를 이용해 서버 환경을 빠르게 구축하는 기술 > 사용자는 필요에 따라 이러한 자원을 빠르게 **확보**
- **온프레미스 환경 <> 클라우드 환경** 
	- 디지털 인프라 아키텍처에서 클라우드 가상 PC 영역과 서버 컴퓨터 영역이 **상호 보완적인 관계**
		- + 보완적인 관계?
		- 기업/사용자는 필요에 따라 물리적 서버와 클라우드 가상서버 사이의 균형을 맞출 수 있음 OR 독립적으로 각각 운영/존재 가능
		- EX) 민감한 데이터는 물리적 서버에서 처리하고, 일반 데이터는 클라우드에서 처리하여 비용을 절감하고 유연성을 높일 수 있습
		- 
	- 온프레미스(On-Premise) 환경 = (사용자관점) 물리적인 서버 컴퓨터 운영 = 전통적인 인프라 구축 방식
		- 의미
			- 온프레미스 환경은 회사 내부에 서버를 설치하고, 직접 관리하는 방식 
				- = 서버의 하드웨어와 소프트웨어를 모두 회사가 소유하고 운영
				- = 사내/외에서 접근 가능한 Private/Public(전산실)데이터 센터를 구축하고 독자적으로 운영하는 방식
				- = 서버, 네트워크, 스토리지 등의 자산을 구매, 구성을 등 서버 운영에 대한 모든 것을 직접
		- 장점
			- 기업이나 조직 내에 물리적인 서버들을 두어 데이터 처리 속도가 빠르고, 직접 관리할 수 있어 보안성이 높습
		- 단점
			- 하드웨어 자원의 확장이 필요할 때 물리적 한계와 비용 문제가 발생 가능 = (확장성이 제한)
			- 초기 설치 및 유지 비용이 높고, 물리적 공간이 필요
	- 원격환경 = 가상환경 = (사용자 입장) 클라우드 가상 서버PC 운영
		- + '가상' 서버라는 용어는 사용하는 관점에 따라 의미가 달라짐
			- 사용자 입장에서 클라우드 내의 서버는 '가상'으로 존재하며, 물리적인 위치나 구성에 대해서는 신경 쓸 필요가 없습 <> 클라우드 서비스 제공업체의 백엔드에서는 이 가상 서버를 지탱하는 물리적 서버(PC)가 존재
				- = 클라우드 사용자에게 서버는 가상적으로만 존재하는 것처럼 보이지만, 실제로는 물리적 인프라 구축되어 있음 > 물리적 인프라는 클라우드 제공 업체가 관리
		- 의미
			- 서버를 회사가 직접 관리하지 않고 클라우드 서비스 회사를 이용함
			- 회사는 필요한 컴퓨팅 자원을 클라우드 서비스 제공업체로부터 임대하여 사용하며, 하드웨어 관리와 유지보수는 클라우드 서비스 제공업체가 담당
		- 장점
			- On-Premise와 달리 서버 구매/발주, 네트워크 구성 등에 대해 소요되는 일시적인 투자금액, 시간 등이 소요되지 않아 마음만 먹으면 바로 서비스에 필요한 서버/네트워크/스토리지 등의 빠른 구매 및 사용이 가능
				- = 사용량 기반의 비용 지불 모델 덕분에 초기 비용을 크게 줄일 수 있음
			- 클라우드 서비스는 가상화 기술을 통해 서버 자원을 유연하게 확장하고 관리
			- 다양한 지리적 위치에서 빠른 접근성을 제공
				- = 가상 환경에 구축된 서버이기 때문에 다양한 **디바이스 제약**을 벗어나 기존 환경보다 **편리**하게 IT 환경에 **접근**할 수 있음
		- 단점
			- 외부 클라우드 서비스 제공업체에 의존함으로써 발생할 수 있는 데이터 주권 및 보안 문제
- 일상 생활에서 자주 사용하는 **클라우드 기반 서비스-애플리케이션** =>
	- 일반인들도 AWS(아마존-웹-서비스)와 같은 클라우드 서비스를 직접적으로 사용하지는 않더라도, 일상 생활에서 클라우드 기반의 다양한 서비스와 애플리케이션을 자주 이용하고 있음
	- 즉, 클라우드-서비스-기술은 개발자뿐만 아니라 일반인의 생활에도 깊숙이 통합되어 있음 > 편리함과 접근성을 크게 향상
		- `아래와 같은 서비스-애플리케이션들이 클라우드 기반 서비스였기 때문에 어떤 기기에서도 쉽게 해당 데이터에 접근할 수 있던 거구나`
		- 
	- 온라인 스토리지 서비스 = (개인용 클라우드 서비스)
		- **Google Drive**, **Dropbox**, **iCloud**, 네이버 마이박스
		- 이 서비스들은 내 컴퓨터가 아닌 가상서버에 문서, 사진, 비디오 등의 파일을 저장하며, 이를 여러 기기에서 접근하여 사용할 수 있게 해줍
		- 구글 드라이브를 이용할 때는 구글의 클라우드 서비스가 제공하는 '가상의 서버'와 '가상 컴퓨팅 자원'을 사용하는 것 > 이는 구글의 클라우드 인프라 상에서 작동하는 애플리케이션을 이용하는 것을 의미함
	    - 따라서, 구글 크롬 웹 브라우저를 통해 구글 드라이브나 구글 폼과 같은 프로그램을 사용할 때, 실제로는 구글의 클라우드 서비스에 접속하여 서비스를 이용하고 있는 것
	    - 웹 브라우저를 통해 이러한 서비스에 접근하며, 모든 데이터 처리와 저장은 구글의 클라우드 서버에서 이루어짐
	- 스트리밍 서비스
		- **Netflix**, **YouTube**, **Spotify**: 
		- 이러한 엔터테인먼트 플랫폼은 영화, TV 프로그램, 음악 등을 클라우드에서 호스팅하여 사용자가 언제 어디서나 접근할 수 있음
	- 이메일 서비스
		- **Gmail**, **Outlook.com**: 
		- 이메일 서비스는 메시지, 첨부 파일, 그리고 연락처 정보를 클라우드 서버에 저장하고 관리 > 언제 어디서나 접근 가능
	- 온라인 문서 및 오피스 툴
		- **Google Docs**, **Microsoft Office 365**: 
		- 이러한 도구들은 문서 작성, 편집, 공유를 클라우드에서 바로 수행할 수 있게 해 줍
				- 
- **클라우드 대표 서비스 업체**
	- 국내
		- KT 클라우드
		- 네이버 클라우드 플랫폼 - MyBOX
		- NHN 토스트
		- 더존비즈온 iCUBE 클라우드 에디션 등
	- 해외 서비스 
		- 마이크로소프트 애저 / 
		- 애플 iCloud / 
		- 알리바바 클라우드 / 
		- 구글 클라우드 플래폼 / 
		- IBM 클라우딩 컴퓨터 
		- 아마존 AWS 웹 서비스
			- 아마존에서 제공하는 클라우드 서비스로, 높은 시장점유율을 차지
			- 규모의 경제로 서비스 비용이 지속적으로 절감되는 효과를 누릴 수 있는 것이 AWS만의 차별화된 포인트



---


##### ㅡ [[디지털환경-인프라아키텍처-디지털리터러시\|디지털환경-인프라아키텍처-디지털리터러시]]
- 디지털 인프라
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:#d3f8b6">디지털 인프라 아키텍처-이미지</span>
- <span style="background:#d3f8b6">디지털 인프라 아키텍처 기반 CS전공지식 이해-이미지</span>
- <span style="background:#d3f8b6">코딩-프로그래밍-코더-프로그래머-이미지</span>
- <span style="background:#d3f8b6">컴퓨터메모리-저장데이터-종류-이미지</span>

##### ㅡ [[디지털인프라-개발직군-직무-역량 이해\|디지털인프라-개발직군-직무-역량 이해]]
- 디지털 인프라
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:#d3f8b6">디지털 인프라 아키텍처 기반 다양한 개발직군 이해-이미지</span>
	- 웹 기술/개발 관련 직군
		- 제품/서비스(만) 기획 직무
		- UI/UX 제품-서비스 설계 및 기획 직무
			- 웹 디자인 직무
			- 웹 퍼블리셔 직무
				- 실제 개발을 담당하는 직무들 =>
				- 프론트엔드 개발 - 화면에 보이는 로직구현
				- 백엔드 개발 - 안 보이는 서버쪽 로직구현
				- DBA - 데이터베이스 개발
				- 
	- 기획자/디지털 마케터 : 
		- 하나의 서비스를 성공적으로 진행되게 하기 위한 기능명세서/기획안 작성
		- 예시 =>
			- 네이버에서 특정한 서비스/기능을 사용자들에게 제공 
			- 화면을 사용자친화적 >  어떻게 디자인? 어떤 색? 어떻게 배치? 어떤 내용? 
		- 
	- 클라이언트 측 :
	    - 운영체제 개발자: 운영체제의 설계와 개발을 담당
	    - 소프트웨어 개발자: 클라이언트 응용 프로그램을 개발
	    - 프론트엔드 영역 =>
		    - 사용자가 볼 수 있는 영역 = 사용자가 보는 영역
			    - EX) 화면 레이아웃, 웹 페이지 텍스트-이미지 등
		    - 필요한 기술-스택
			    - 프론트 영역 동작 언어 = HTML/CSS/JS
		    - 다양한 직무
			    - UI/UX 제품-서비스 설계 및 기획
					- 웹 사이트 레이아웃 등 겉으로 보이는 부분  = 사용자 인터페이스 부분 (UI - user interface)
					- 웹 사이트를 이용하는 사용자들의 경험 향상 (UX - User eXperience)
				- **프론트엔드** 개발자
					- 웹이나 모바일 애플리케이션의 사용자 인터페이스 개발
					- 설계한 UI/UX를 웹 언어를 활용해 정의/구현
						- = 사용자 인터페이스와 사용자 경험향상 로직 담당
						- = 사용자 요청 > 백엔드 영역 전송! 로직 담당
						- = 백엔드 영역으로부터 받은 응답값을 사용자에게 표시하는 로직 담당
						- 
	- 서버 측 = 백엔드 영역 : 
		- 필요한 기술-스택
			- 백엔드 영역에서 동작하는 프로그래밍 언어
				- EX) C / C++ / JAVA / PYTHON
			- 클라우드 활용 역량
				- 복기 : `클라우드 기술의 발전으로 서버 자원을 좀 더 유연하게 확장하고 관리 가능해짐`
				- 
	    - 백엔드 개발자
		    - 서버 사이드 로직
			    - = 웹 서버/시스템에 들어오는 다양한 요청-로직들이 잘 동작되기 위해 필요한 여러 기능 구현
			    - = 서버와 클라이언트 간의 통신 
			    - = 데이터베이스 관리
		- DBA(Database Administrator)
			- 데이터베이스의 설계, 구현, 유지보수, 보안 강화 등을 담당하며, 이를 통해 데이터의 안정성과 접근성을 확보
				- = 데이터를 저장하고 관리하는 프로그램을 활용하는 다양한 시스템 환경을 구축하고 운영
				- 
	- 네트워크 영역:
	    - 시스템 엔지니어/데브옵스: 클라이언트와 서버 간의 원활한 통신과 상호작용을 보장하며, 인프라의 배포, 관리, 운영을 담당
	    - 
- <span style="background:#d3f8b6">디지털 인프라 기반 다양한 개발역량-이미지</span>
	- app 개발을 위한 UX/UI 이해 = 분석-설계-기획
	- app 개발을 위한 언어 이해
		- app 개발을 위한 프레임워크/라이브러리 이해
	- 개발한 app 유저와 커뮤니케이션 영역 프론트 이해
	- 개발한 app을 서비스화 하기 위한 서버 이해
		- 서버영역에서 비즈니스 흐름 처리/로직 백엔드 이해
	- 데이터를 수집-저장-관리를 위한 데이터베이스 이해
	- 형상관리-빌드-배포자동화-테스트자동화 이해
	- app 개발을 위한 물리/가상 환경/장비 이해


##### ㅡ [[인프라-컴퓨팅서비스-클라우드서비스-용어이해\|인프라-컴퓨팅서비스-클라우드서비스-용어이해]]
- 디지털 인프라
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 인프라 / 컴퓨팅 서비스 / 클라우드 서비스
	- 컴퓨팅 서비스 <> 클라우드 서비스 이해
		- 컴퓨팅 서비스 용어 이해
			- 컴퓨팅 서비스를 제공한다는 것은 단순히 컴퓨터 자원을 제공하는 의미를 넘어서 사용자가 서비스를 이용할 수 있도록 필요한 모든 **인프라를 제공하는 서비스**라고 표현할 수 있다.
		- 즉, 컴퓨팅 서비스는 클라우드 서비스보다 더 큰 범위를 포함하며, 클라우드 서비스는 컴퓨터 자원/리소스를 대여해주는 서비스인 반면, 컴퓨팅 서비스는 컴퓨터 자원뿐만 아니라 데이터가 사용자에게 도달하기 위해 필요한 모든 구성요소를 포함하는 서비스
	- 인프라 용어 이해
		- 하나의 서비스를 특정한 사용자가 이용하기 위해서는 다양한 구성요소들이 상호작용의 결과 = 다양한 과정을 거친다. 
			- > 이러한 구성요소들을 통합하여 인프라라고 표현
		- 인프라의 구성요소에는 물리적인 구성요소들과 추상적인 기술들이 존재
		- 각각 구성요소들이 서비스의 안정성과 성능에 기여
		- 
		- 요약 
			- **물리적인 구성요소**:
			    - 서버
			    - 스토리지
			    - 데이터 센터
			    - 네트워크 장비(라우터, 스위치, 방화벽 등)
			- **추상적인 기술**:
			    - 가상화 기술
			    - 엣지 컴퓨팅
			    - 클라우드 서비스
			    - 보안 솔루션
			    - 관리 도구 및 소프트웨어
	- 주요 인프라 요소
		- 이렇게 모든 요소들이 조화를 이루어 사용자가 원활하게 서비스를 이용하는 것.
		- **서버(Server)용 PC**:
			- 데이터를 저장하고 처리하는 컴퓨터/시스템 = 서비스 제공자가 자신의 데이터를 저장하고 관리할 수 있는 공간
		- **데이터 센터(Data Center)**:
			- 여러 서버가 위치한 물리적 장소
			- + 단순한 서버 공간 제공뿐만 아니라, 높은 보안 시스템, 전력시설, 냉각시설 등 안정적이고 빠른 네트워크를 제공을 위한 환경
		- **네트워크 인프라(Network Infrastructure)**:
			- 데이터가 사용자에게 도달하기 위한 통로 = 인터넷 네트워크 통신망
			- > 이를 위해 고속 인터넷, 라우터, 스위치, 방화벽 등의 네트워크 장비 및 기술 포함
		- **스토리지(Storage)**:
			- 데이터를 저장하는 공간
			- 하드 드라이브, SSD, 클라우드 스토리지 등 다양한 형태
			- + 추가내용
				- 일반적으로 서버는 내부에 스토리지를 가지고 있어 데이터 저장 기능도 수행 > 따라서 서버와 스토리지를 하나로 취급할 수 있습. 하지만, 스토리지가 서버와 별도로 외부에 있는 경우도 있기 때문에, 상황에 따라 구분
		- **엣지 컴퓨팅(Edge Computing)**:
			- 데이터를 중앙 서버가 아닌 네트워크 가장자리에 위치한 장치에서 처리하여 지연 시간을 줄이는 기술
			- 엣지 서비스를 통해 데이터 처리를 사용자와 가까운 곳에서 수행하여 성능을 향상시키고 지연 시간을 줄이는 역할
		- **보안(Security)**
			- 데이터와 네트워크를 보호하기 위한 방어 시스템
			- 방화벽, 암호화, 침입 탐지 시스템 등이 포함
		- **가상화 기술(Virtualization Technology)**:
			- 물리적 서버를 가상화하여 여러 가상 서버로 분할하고, 자원을 효율적으로 사용할 수 있게 합
		- **백업 및 복구 시스템(Backup and Recovery System)**:
			- 데이터 손실에 대비하여 데이터를 백업하고 필요 시 복구할 수 있는 시스템
		- **클라우드 서비스(Cloud Services)**:
			- 필요에 따라 유연하게 자원을 사용할 수 있는 클라우드 기반의 서비스
			- 예를 들어, AWS, Google Cloud, Microsoft Azure 등
		- **관리 도구 및 소프트웨어(Management Tools and Software)**:
			- 서버와 네트워크를 모니터링하고 관리하기 위한 소프트웨어 > 기능은 인프라의 상태를 실시간으로 파악하고 문제를 신속하게 해결하는 데 도움을 줍
		- 상황예시
			- 어떤 사용자가 온라인 쇼핑몰 서비스를 이용하려고 한다면, 다음과 같은 인프라가 필요
			- **서버**: 쇼핑몰 웹사이트와 데이터베이스를 호스팅
			- **데이터 센터**: 서버가 위치한 물리적 장소
			- **네트워크 인프라**: 사용자가 웹사이트에 접속하고 데이터를 주고받을 수 있도록 하는 인터넷 연결
			- **스토리지**: 상품 이미지, 사용자 정보, 주문 내역 등을 저장
			- **보안**: 사용자 정보를 보호하기 위한 방화벽과 암호화
			- **백업 시스템**: 데이터 손실에 대비한 정기 백업.


##### ㅡ [[프로비저닝(Provisioning)-용어\|프로비저닝(Provisioning)-용어]]
- 디지털 인프라
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 서비스 프로비저닝
	- 인프라 자원 제공?
		- = 물리적인 구성요소/자원 + 추상적인 구성요소/자원
		- **Server Resource Provisioning** : CPU, Memory, IO 등과 같은 실제 서버의 자원을 할당해주고 운영할 수 있게 제공해주는 것
		- **OS Provisioning** : OS를 서버에 설치하고 구성작업을 해서 사용할 수 있도록 제공하는 것
		- **Software Provisioning** : WAS, DBMS 등의 소프트웨어를 설치하고 세팅하여 실행할 수 있도록 제공하는 것
		- **Account Provisioning** : 접근 권한을 가진 계정을 제공해주는 것
		- **Storage Provisioning** : 데이터를 저장하고 관리할 수 있는 Storage 를 제공
			- + 클라우드 사용시 각 서비스들을 용도에 맞게 세팅을 하여 환경 구성을 자동화 하는 것을 자동화 Provisioning
	- ㅡㅡㅡㅡ본문내용
	- 어떤 종류의 서비스든 사업자가 사용자의 요구에 맞게 시스템 자체/**인프라를 제공** 하는 것
		- = IT 인프라 자원을 사용자 또는 비즈니스 Customer에게 Service Vendor 가 제공해주는 것
		- = 고객이 필요한 IT 서비스를 설정하고 제공하는 과정 > 하드웨어, 소프트웨어, 네트워크 서비스 등을 설치하고 구성하여 고객이 즉시 사용할 수 있도록 준비하는 것을 포함
	- 비유이해
		- 서비스 프로비저닝은 마치 새로운 컴퓨터를 설정하는 과정과 비슷
		- 새 컴퓨터를 구입하면 운영 체제를 설치하고, 필요한 소프트웨어를 설치하고, 네트워크에 연결하는 과정 > 데이터센터에서의 서비스 프로비저닝도 이와 유사하지만, 훨씬 더 큰 규모에서 이루어집
		- 데이터센터 서비스 프로비저닝 예시 =>
			- 예시 상황: 한 금융 회사가 에퀴닉스의 데이터센터에서 새로운 서버를 필요
			- **하드웨어 준비**: 금융 회사가 요구한 사양에 맞는 서버 하드웨어를 준비
			- **소프트웨어 설치**: 서버에 필요한 운영 체제와 금융 회사가 사용하는 특정 애플리케이션 소프트웨어를 설치
			- **네트워크 구성**: 서버가 데이터센터의 네트워크에 연결되어 다른 시스템과 통신할 수 있도록 네트워크 설정을 구성
			- **보안 설정**: 금융 데이터의 안전한 처리를 위해 필요한 보안 설정과 방화벽을 구성
			- **테스트 및 검증**: 모든 설정이 제대로 작동하는지 확인하고 테스트합
	- 상황예시-이해
		- 클라우드 서비스/환경에서 사용하는 것은 클라우드 Vendor 로부터 서비스를 Provisioning 받아 사용하는 것
		- EX) 서비스 프로비저닝은 AWS 클라우드 서비스에서 EC2 인스턴스를 생성하는 과정과 비슷
			- EC2 인스턴스 생성 : 
				- AWS에서 새로운 EC2 인스턴스를 생성할 때, 사용자들은 인스턴스 유형, 운영 체제, 스토리지 크기, 네트워크 설정 등을 선택하고 구성 > 이러한 과정을 통해 사용자는 필요한 서버 환경을 설정하고 준비
- 프로비저닝(Provisioning) 용어
	- 소프트웨어 용어 중 하나가 프로비저닝(Provisioning) = 클라우드 서비스에서 주로 사용되는 용어
	- 프로비저닝(Provisioning) 이란 의미는 영어 직역한 그대로 "제공하는것" 


---


# <컴퓨터 시스템>




##### ㅡ [[시스템-프로그램-용어이해\|시스템-프로그램-용어이해]]
- 컴퓨터 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- "시스템" 용어
	- 다양한 문맥에서 사용
	- 개별적인 구성 요소들이 서로 상호작용하여 특정한 목표나 기능을 달성하기 위해 함께 작동하는 집합체 의미
	- 따라서 각각의 프로그램, 모듈, 컴포넌트 상호작용을 한다면 시스템! 용어 사용 가능
		- 프로그램 = 코드(파일)덩어리 
			- 모듈 <=> 컴포넌트 용어
				- : '각 컴포넌트는 인터페이스를 통해 상호작용'
				- 특정 기능 담당 독립적인 코드단위/수행 단위
				- 프로그램 일부 
	- ex)
		- DB 시스템(Database System)
			- 데이터베이스 관리 시스템(DBMS)과 데이터베이스로 구성
			- 데이터의 저장, 검색, 관리 등을 효율적으로 수행하기 위해 상호작용
		- 컴퓨터 (시스템) (Computer System)
			- 하드웨어(프로세서, 메모리, 입출력 장치 등)와 소프트웨어(운영 체제, 응용 프로그램 등)가 결합 > 각 하드웨어 구성요소와 소프트웨어가 상호작용하여 컴퓨터가 원활하게 동작
		- 파일 시스템(File System)
			- 파일과 데이터를 효율적으로 저장, 검색, 관리하기 위해 운영 체제에 의해 사용되는 시스템
			- 디스크 내의 데이터를 조직화하고, 파일에 대한 접근 및 관리를 가능하게 하는 여러 구성요소로 이루어져 있습

##### ㅡ [[알고리즘-문제해결절차-CT-컴퓨터사고\|알고리즘-문제해결절차-CT-컴퓨터사고]]
- 컴퓨터 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 알고리즘(문제해결 절차) = CT = 컴퓨터 사고
	- <span style="background:#d3f8b6">CT-컴퓨터사고-문제해결과정-이미지</span>
	- **배경**
		- 컴퓨터는 사람과 달리 시키지 않은 일, 애매한 작업은 못한다
		- 컴퓨터를 활용해서 의미있는 생산성을 만들어 내려면, 일을 잘 시켜야 함 
			- = 좋은 답변을 받기 위해선 좋은 질문, 구체적인 질문을 해야 하는 것 처럼
			- 
	- 요약 : 특정 문제해결을 위한 개념/설계한 내용을 컴퓨터가 이해할 수 있도록 코드로 구현하는 것
		- 알고리즘은 그 자체로 코드가 아닌, 문제 해결을 위한 개념적 접근 방식이나 절차를 정의한 것
		- 코드는 이 알고리즘을 실제로 구현하기 위한 수단
		- 알고리즘을 통해 어떤 문제를 어떻게 접근하고 해결할 것인지를 논리적으로 **설계**하고, 이 설계를 바탕으로 프로그래밍 언어를 사용하여 컴퓨터가 알고리즘-개념을 이해할 수 있는 명령어로 변환하는 작업을 진행
		- 
		- EX) 
			- "버블 정렬" 알고리즘 : 이는 두 인접한 요소를 비교하고 필요에 따라 위치를 교환하여 전체 리스트를 정렬하는 방법을 개념적으로 설명
			- 이 후에 이 알고리즘/개념적인 내용을 실제 코드로 구현
		- 
	- **과정/프로세스**
		- 1. 하나의 사건/상황/문제를 분해한다.
			- 분해 (decomposition) : 복잡한 문제를 해결할 수 있는 작은 문제들로 쪼갬으로써 쉽게 해결할 수 있다
		- 2. 자료(변수)로 문제를 **표현**하고/정의한다
			- 추상화 (abstraction) : 문제 해결에 필요한 요소를 파악해 컴퓨터가 이해할 수 있는 수준으로 단순하게  표현한다
		- 3. 문제해결 절차를 만들어서(**알고리즘-코드로직**) 일반적 해답을 찾아내는방식-과정을 지칭
			- 알고리즘화 (algorithm) : 문제 해결을 위한 각각의 작업을 논리적 처리 과정/순서를 구체적이고 명확하게 정리한다
			- 알고리즘(개념적인 내용)을 코드로 구현 과정/프로세스 =>
				- 이러한 과정을 통해, 알고리즘은 단순한 이론-개념에서 실제 적용 가능한 해결책으로 전환
				- **문제 이해하기**: 
					- 어떤 데이터를 다루며, 어떤 결과를 원하는지 정확히 파악
				- **알고리즘 선택**: 
					- 문제 해결에 적합한 알고리즘-개념을 선택
				- **알고리즘 설계**: 
					- 선택한 알고리즘의 원리를 이해하고, 이를 기반으로 해결책을 설계
				- **코드 구현**: 
					- 설계한 알고리즘을 실제 코드로 구현
					- 구현 시 데이터 구조와 프로그래밍 언어의 특성을 고려
					- 
	- **알고리즘 표현방법**
		- 1. 자연어(natural language)
		- 2. 순서도(flow language)
			- <span style="background:#d3f8b6">알고리즘-순서도예시-이미지</span>
				- 1번 구조-로직보다 < 2번 구조-로직
				- 2번 구조-로직 < 3번 구조-로직 좀 더 효율적인 방법
				- 이러한 구조-코드로직-과정으로 해당 문제를 정의/해결 과정을 정의한 알고리즘(방법) 존재 = **Binary Search Algorithm**
				- 
				- 이진 탐색 알고리즘(Binary Search Algorithm)? =>
				- **정렬**된 리스트에서 특정 요소의 위치를 찾는데 사용
				- 정렬 =>
					- 크기순으로 배치된 상태 의미
					- 
				- 이진 탐색 알고리즘의 **작동원리**
					- `이진 탐색 알고리즘 내부에 이러한 내용이 개념적으로 정의되어 있었구나`
					- 
					- **정렬된** 리스트에서 시작
					- 리스트의 중간 요소를 선택하고, 찾고자 하는 값과 비교
					- 만약 중간 요소가 찾고자 하는 값과 일치하면, 그 위치를 반환
					- 찾고자 하는 값이 중간 요소보다 작으면, 리스트의 왼쪽 절반에서 탐색을 계속합
					- 찾고자 하는 값이 중간 요소보다 크면, 리스트의 오른쪽 절반에서 탐색을 계속합
					- 이 과정을 찾고자 하는 값이 발견되거나 더 이상 탐색할 부분이 없을 때까지 반복합
					- 
					- 실제예시 =>
					- 정렬된 숫자 리스트 [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]에서 숫자 40을 찾고자 할 때의 이진 탐색 과정
					- 처음 중간의 요소는 50입
					- 40은 50보다 작으므로, 탐색 범위를 왼쪽 절반인 [10, 20, 30, 40, 50]으로 줄입
					- 새로운 중간 요소는 30
					- 40은 30보다 크므로, 탐색 범위를 오른쪽 절반인 [30, 40, 50]으로 줄입
					- 다음 중간 요소는 40입. 그리고 이 값은 찾고자 하는 값과 일치하므로 탐색을 종료
					- 
			- 알고리즘-절차에는 **순차구조/로직, 선택구조/로직, 반복구조/로직** 존재 =>
				- 1. 순차구조 : 문제해결을 위한 순서대로 배치
				- EX) 
					- 요리를 위해 당면이 필요한 상황에서 문제해결 절차.
					- 슈퍼마켓에간다. 01
					- 당면을산다. 02
					- 집으로되돌아온다. 03
				- 2. 선택구조-로직 : 조건식으로 실행할 단계를 바꾸는방식
					- <span style="background:#d3f8b6">순서도-선택구조-이미지</span>
				- 3. 반복구조-로직 
					- <span style="background:#d3f8b6">순서도-반복구조-이미지</span>
					- 
		- 3. 가상코드(pseudo code)
		- 4. 프로그래밍언어 (programming language)


# ㅡ 1. **컴퓨터 구조** - 큰 개념

##### ㅡ [[비트(bit)용어\|비트(bit)용어]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 비트 용어 이해
	- 비트 정의
		- 비트(bit)는 'binary digit'의 줄임말
		- 컴퓨터는 모든 데이터/정보를 이진 형태로 처리하기 때문에, 비트는 컴퓨터가 데이터를 처리하는 기본 단위로 사용
		- 1비트는 **데이터의 크기 단위**이며, 컴퓨터나 기타 디지털 시스템에서 정보를 저장하고 처리하는 가장 작은 단위 > 따라서 "1비트를 처리한다"는 것은 실제로 '데이터 포인트 한 개를 처리한다'는 것과 동일한 의미를 가지며, 이 데이터 포인트는 0 또는 1의 값 중 하나를 가질 수 있음
	- 비트와 데이터 표현 
		- <span style="background:#d3f8b6">비트-스위치-이해-이미지</span>
			- 이미지 설명 =>
			- 4비트 상황 = 스위치가 4개인 상황
			- 스위치/비트 1개 당 표현할 수 있는 경우의 수 2가지.
			- 따라서 현재 4비트인 상황에서 표현할 수 있는 경우의 수/종류는 16개!
			- 
		- 1비트는 두 가지 상태(0 또는 1)를 나타낼 수 있습
		- 이는 하나의 비트가 표현 가능한 데이터의 '개수' 또는 '가능성'을 의미. 
		- 즉, 1비트에 의해 표현될 수 있는 값의 경우의 수/종류는 두 가지.
		- 
	- 메모리와 비트
		- 메모리에서 1비트의 용량은 그 메모리가 저장할 수 있는 정보의 최소 단위를 나타냅
			- 주의 : 1비트는 두 가지 가능한 정보 값을 저장할 수 있는 최소 단위로, 크기가 '2'를 의미하지는 않습
		- 1비트는 0 또는 1, 즉 두 가지의 다른 상태를 나타낼 수 있으므로, 메모리에서 1비트는 두 가지 가능한 상태를 저장할 수 있는 공간을 의미
		- = 1비트는 두 가지 상태를 표현할 수 있는 **용량**을 가진다고 이해
		- 
	- 요약 : 비트는 데이터 최소/기본 크기 단위 (데이터 포인트 1개..) 이지만, 이는 동시에 그 비트로 표현할 수 있는 데이터 값의 '경우의 수' 또한 나타냅. + 메모리 입장에선 1비트는 2가지 값 상태를 표현할 수 있는 용량을 가지고 있음을 의미
	- 
	- <span style="background:#d3f8b6">비트-진법-손풀이-이미지</span>
		- 이미지 설명 =>
		- 10진수로 표현된 512 숫자 존재
		- 특정한 진법으로 표현되어 있는 숫자는 `각 자리 숫자 x 해당 진법의 자리값` 끼리 더하면 해당 값이 나온다.
		- 
		- 이미지 설명 =>
		- 2진수로 표현된 1001 숫자 존재
		- `각 자리 숫자 x 해당 진법의 자리값` 끼리 더하면 1001 이진수 값에 대한 십진수 값을 파악 가능



##### ㅡ [[CPU기능-메모리-상호작용-과정이해\|CPU기능-메모리-상호작용-과정이해]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
    - 메모리 계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:#d3f8b6">이미지</span>


##### ㅡ [[저장장치-캐시계층-구조\|저장장치-캐시계층-구조]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- **캐시 메모리** 계층 존재
	- ==캐시 메모리? =>== | [[캐시메모리-성능-작동원리\|캐시메모리-성능-작동원리]]
	- 
	- 현재 대부분의 마이크로프로세서는 여러 레벨의 캐시(L1, L2, 때로는 L3까지)를 내장하고 있음
	- L1, L2, L3 캐시는 각기 독립적인 레벨의 캐시 메모리로 존재
	- 주의
		- 캐시 메모리는 L1, L2, L3과 같은 여러 레벨로 나눌 수 있지만, 반드시 모든 시스템이 이 세 가지 레벨을 모두 갖추고 있는 것은 아닙
		- 오래된 컴퓨터 시스템에서는 L1과 L2 캐시만을 사용할 수도 있고, 고성능 시스템에서는 L1, L2, L3 캐시를 모두 활용하여 데이터 처리 효율을 높일 수 있습
		- 
	- L1 캐시
		- 거의 모든 현대 프로세서에 존재하며, CPU 코어에 매우 가까워서 가장 빠른 액세스 속도를 제공
	- L2 캐시
		- L1보다는 느리고 크지만, 여전히 빠른 데이터 접근을 제공하여 CPU의 성능을 향상
	- L3 캐시
		- 주로 멀티코어 프로세서에서 볼 수 있으며, 여러 코어 사이에 데이터를 공유하는 데 도움을 줍
		- 
	- 다양한 형태-구조 캐시 메모리 존재 = 캐시 메모리 위치
		- CPU 내부에도 존재할 수 있고, 과거에는 CPU와 RAM 사이에 위치하는 외부 캐시로 구현
		- 현대의 컴퓨터 아키텍처에서는 주로 내부 캐시를 말합
		- 과거 컴퓨터 아키텍처에서는 CPU 외부에 별도의 캐시 메모리를 두는 경우가 더 흔했음 > 하지만 기술의 발전으로, 특히 반도체 제조 공정이 미세화되면서, 캐시 메모리를 CPU 칩 내부에 통합할 수 있게 되었습 > 내부 통합 캐시는 더 짧은 지연 시간과 빠른 접근 속도를 제공하며, CPU의 성능을 대폭 향상
		- 
		- <span style="background:#d3f8b6">계층적 캐시 메모리-이미지</span>
		- <span style="background:#d3f8b6">멀티코어 프로세서 캐시 메모리-이미지</span>
			- L3코어가 공유되는 형태
			- L1, L2 각각 코어에 존재
		- <span style="background:#d3f8b6">분리형 캐시 메모리-이미지</span>
			- 멀티코어 구조와 비슷하지만, L1 캐시 메모리가 분리된 구조



##### ㅡ [[플래시메모리-기반보조기억장치\|플래시메모리-기반보조기억장치]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 1. ==플래시 메모리(Flash Memory) 기반 보조기억장치==
	- 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치 > 따라서 비플래시 메모리 즉, hdd와 모양이 많이 다름
	- 
	- 플래시 메모리(Flash Memory)
		- 플래시 메모리는 실제로 존재하는 물리적인 하드웨어 요소(물리적인 저장 매체) 이면서 동시에 그 하드웨어가 데이터를 저장하고 관리하는 '기술' 의미도 포함
		- 플래시 메모리의 핵심 기능은 데이터를 저장하는 것이며, 이러한 저장 기능은 다양한 형태와 용도로 전자 기기에서 구현
			- = 보조기억장치에만 한정되지 않는다는 점을 이해 = 범용성이 높다
			- ex) 휴대폰, 태블릿, USB 드라이브 등에서도 널리 사용
			- 
		- ==플래시 메모리를 이루고 있는 저장 단위/용어== => [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
		- 
	- 특징
		- 플래시 메모리에서는 비플래시-하드디스크와 달리 데이터를 직접 수정하거나 덮어쓰는 것이 불가능
			- = 수정된 새로운 데이터는 항상 새로운 공간에 저장
		- ~ 특징으로 인한 플래시 메모리에서 데이터를 업데이트할 때의 기본적인 동작 프로세스 - 상황예시
			- <span style="background:#d3f8b6">플래시메모리-가비지 컬렉션 과정-이미지</span>
			- 이미지 설명 =>
				- 한 칸 = 한 페이지 가정
				- 새로운 데이터 c 를 저장 = 블록 x 3번 페이지에 저장
				- 1번 페이지에 존재하던 A데이터를 수정을 진행. A > A' 
				- 따라서 1번 페이지에 존재하던 A데이터는 필요없는 값이 되어버림 = Invalid 상태
				- 가비지 컬렉션 진행
					- 1. 기존 x블록에 존재하는 유요한 페이지들만을 새로운 블록으로 복사
					- 2. 기존 x 블록 삭제
				- 
		- 이 과정을 통해 유효하지 않은 페이지는 지워지고, 해당 공간은 새로운 데이터 저장을 위해 다시 사용 가능해집 > 이러한 프로세스-과정은 메모리의 수명을 연장하고, 데이터의 무결성과 안정성을 보장
		- 시스템은 정기적으로 또는 필요할 때 'Invalid' 상태의 페이지를 정리하는 **가비지 컬렉션**을 수행
			- + 가비지 컬렉션?
			- 유요한 페이지들만 새로운 블록으로 복사한 후 기본 블록을 삭제해 공간을 정리하는 기능/과정
			- 상황예시
				- 워드 문서를 편집하고 저장할 때를 생각
				- 처음 문서를 저장하면 해당 데이터는 플래시 메모리의 특정 페이지에 기록
				- 이후 같은 문서를 수정하고 다시 저장하면, 수정된 새로운 데이터는 새로운 페이지에 저장되고, 원래 페이지에 있던 데이터는 'Invalid' 상태가 됩
				- 즉, 원본 데이터는 여전히 메모리에 남아 있지만, 시스템은 그 데이터를 더 이상 유효한 정보로 인식하지 않습 이렇게 유효하지 않게 된 데이터는 나중에 가비지 컬렉션 과정에서 지워지게 됩
				- 
	- 플래시 메모리 종류
		- 1. NAND (넨드) 플래시 메모리
			- 대용량 저장 장치로 주로 사용 > 따라서 특별한 언급이 없다면 플래시 메모리는 넨드! 를 의미
		- 2. NOR 플래시 메모리


##### ㅡ [[RAID레이드-기술-종류-레벨\|RAID레이드-기술-종류-레벨]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
		    - 보조기억장치
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==RAID의 정의와 종류==
	- <span style="background:#d3f8b6">RAID레이드-이해-이미지</span>
		- 1TB 하드 디스크 4개로 RAID 구성 시 4TB 하드 디스크 1개를 사용하는 것 보다 성능과 안전성이 더 좋다
		- 레이드를 구성하다! 표현 존재
	- RAID 정의
		- Redundant Array of Independent Disks
		- "하나로 묶는 기술"이라는 표현은 단순히 저장 공간을 확장하는 측면만 강조 > 따라서 좀 더 정확한 표현은 "HDD나 SSD(보조 메모리) 여러 개를 동시에 함께 사용하는 기술"
			- = RAID는 물리적인 디스크들을 추상적인 방식으로 조합하여 데이터 보호와 성능 향상을 목적으로 하는 기술
			- 즉, RAID 구성은 실제 하드 드라이브를 사용하여 데이터를 여러 디스크에 분산 저장하거나 복제하는 방식을 정의하지만, 그 방식 자체는 사용자에게 직접 보이지 않는 추상적인 레벨로 표현됨
			- 
	- RAID 기술의 장점
		-  RAID가 여러 개의 독립적인 저장 장치들을 효율적으로 협력(마치 하나처럼 동작...)시켜 더 높은 데이터 보호와 성능 향상을 목적
		- 1. 안전성
			- 상황예시 =>
			- 사진이나 중요한 문서를 컴퓨터에 저장
			- 만약 한 개의 하드 드라이브를 사용하고 있고, 그 하드 드라이브가 고장 난다면 모든 사진이나 문서를 잃게 될 수 있음
			- RAID 기술을 사용하면, 같은 데이터를 여러 하드 드라이브에 복사해 놓기 때문에 하나의 드라이브가 고장 나도 다른 드라이브에서 데이터를 찾을 수 있음. 즉 데이터를 더 안전하게 보관 가능
		- 2. 성능
			- 컴퓨터가 데이터에 접근할 때 여러 드라이브가 팀처럼 협력하게 만들어 동시에 사용할 수 있기 때문에, 컴퓨터의 속도도 더 빨라질 수 있음
		- 주의
			- 모든 RAID 설정/레벨이 이 두 가지 기능을 모두 제공하는 것은 아니며, 어떤 설정은 데이터 보호에 더 중점을 두고, 어떤 설정은 성능 향상에 더 중점을 둠
			- 
	- RAID 다양한 레벨-종류-설정 존재
		- RAID는 여러 레벨이 있으며, 각 레벨은 데이터의 중복 저장 방식, 성능 향상 방법, 내결함성 등에서 다른 특징을 가짐 > 따라서 어떤 상황에서 어떤 특징을 가장 최우선으로 원하는지에 따라 최적의 RAID 레벨-종류는 달라짐
		- EX) 
			- RAID 0, RAID 1, RAID 2, RAID 3, RAID 4, RAID 5, RAID 6 > 그로부터 파생된 RAID 10, RAID 50
			- 0 / 1 / 4/ 5 / 6 주로 사용됨
			- 
		- RAID에 필요한 용어 
			- 스트라이핑(striping) 용어 : 데이터를 스트라이프로 나누어 여러 하드 드라이브에 분산하여 저장하는 과정을 의미
			- 스트라입(stripe) 용어 : 하나의 데이터가 나누어진 각각의 조각을 의미
			- 미러링(mirroring) : 복사본을 반드는 방식/과정
			- 
		- RAID 0
			- <span style="background:#d3f8b6">RAID 0-이미지</span>
			- 그렇다면 어떠한 내부과정으로 데이터를 분산 저장? =>
				- 하나의 프로그램/데이터를 쪼개서 각 하드 디스크에 번갈아 가며 데이터를 저장.
				- 즉, 저장되는 데이터가 하드 디스크 개수만큼 나눠져 저장
				- EX) 4개 HDD 존재 > 하나의 프로그램이 4개에 나눠서 저장
				- 
			- 특징/장점/단점
				- 즉, 데이터를 나누어 저장하는 구성 방식
				- 여러 드라이브에 하나의 데이터를 분산하여 저장하는 '스트라이핑'을 사용하여 **입출력 성능/속도**을 향상 <> 어느 한 드라이브가 고장 나면 데이터를 복구할 수 없습
					- + 입출력 성능/속도?
					- 이미지로 이해
					- 하나의 데이터를 하나의 HDD에서 출력하는 것 보다 여러 곳에서 동시에 출력하는 방식이 더 속도가 빠르다
					- 
		- RAID 1
			- <span style="background:#d3f8b6">RAID 1-이미지</span>
			- 특징/장점/단점
				- RAID 0 방식처럼 분산해 저장은 하되 > 같은 데이터를 두 개의 드라이브에 미러링하여 저장함으로써 데이터 보호를 제공 
					- = 백업과 복구가 쉽다 <> 각각 저장 : 저장 효율이 절반으로 줄어듭, 느린 쓰기 속도
				- 즉, 데이터를 쓸 때/저장 시 원본과 복사본을 각각 저장
				- 
		- RAID 4
			- <span style="background:#d3f8b6">RAID 4-이미지</span>
			- - RAID 1과 RAID 4는 데이터 복구 메커니즘이 서로 다르게 작동
				- 복기 : `**RAID 1**에서는 각 데이터가 두 개 이상의 디스크에 동일하게 복사되어 저장`
				- 요약 : **RAID 4**는 모든 데이터 디스크의 데이터를 종합하여 페리티 정보를 생성하고 이를 별도의 페리티 디스크에 저장
				- 
			- 특징
				- 페리티 데이터? 
					- 페리티 데이터는 여러 디스크에 저장된 데이터의 오류를 검출하고 복구할 수 있게 하는 추가적인 정보
					- RAID 4 시스템에서 패리티 데이터는 모든 데이터 디스크의 동일한 위치에 있는 데이터 비트들을 XOR 연산하여 생성됨 > 이렇게 생성된 패리티 정보는 어떤 하나의 디스크가 실패했을 때 나머지 디스크들의 데이터와 결합하여 손실된 데이터를 복구하는 데 사용
				- ㅡㅡㅡㅡ본문내용
				- 데이터 안전성을 위해 1처럼 완전한 복사본을 저장하는 대신 오류를 검출하고 복구하기 위한 정보를 저장 = **페리티 데이터**
				- 단점
					- RAID 4의 단점 중 하나는 쓰기 작업 시 발생하는 병목 현상
					- 패리티 정보를 계산하고 저장해야 하기 때문에, RAID 4는 쓰기 연산에 있어서 RAID 0이나 RAID 1과 비교할 때 더 느릴 수 있습
						- = 모든 쓰기 작업에 대해 패리티 정보가 업데이트되어야 하는데, 이 모든 정보가 하나의 패리티 디스크에 저장되므로, 동시에 여러 쓰기 작업이 이루어질 경우 패리티 디스크가 병목 지점 발생 가능 > 성능 저하
				- 패리티 기반의 복구 메커니즘 - 상황예시 =>
					- 현재 RAID 4 구성에는 세 개의 데이터를 저장하는 HDD와 하나의 패리티 정보를 저장하는 HDD가 있습
					- 만약 1번 HDD에 문제가 생겨 데이터를 읽을 수 없게 된다면, 나머지 2번과 3번 HDD에 있는 데이터와 4번 HDD에 저장된 패리티 정보를 활용하여 손실된 1번 HDD의 데이터를 복구
					- > 이러한 복구 프로세스는 데이터의 무결성과 가용성을 보장하며, 특히 중요한 데이터를 다루는 서버나 대용량 스토리지 시스템에서 중요한 역할  
					- 
		- RAID 5
			- <span style="background:#d3f8b6">RAID 5-이미지</span>
			- RAID 5는 RAID 4의 단점을 보완한 기술
				- = RAID 5는 RAID 4의 주요 단점인 패리티 디스크 병목 현상을 해결하기 위해 디자인
			- RAID 5는 패리티 정보를 모든 디스크에 분산하여 저장함으로써 이러한 병목 현상을 제거 > 따라서 RAID 5는 RAID 4 대비 쓰기 성능에서 향상을 보이며, 동일한 수준의 데이터 복구 능력
			- 상황예시
				- 네 개의 디스크가 있지만, 이번에는 패리티 정보가 모든 디스크에 순환적으로 분산 저장 > 따라서 모든 디스크가 패리티 정보를 일부 포함하고 있기 때문에 어느 하나가 과부하를 받는 상황이 발생하지 x 
					- = 어떤 특정 디스크에 쓰기 부하가 집중되는 일 X
				- 한 디스크가 실패했을 때 나머지 세 디스크의 데이터와 패리티 정보를 사용하여 손실된 데이터를 복구
					- = 스트라이핑과 함께 패리티 정보를 사용하여 한 드라이브의 실패에도 데이터를 복구할 수 있는 내결함성을 제공
					- 
		- RAID 6 
			- <span style="background:#d3f8b6">RAID 6-이미지</span>
			- 두 종류의 패리티 저장 > 따라서 5보다 안전, 쓰기는 느림



##### ㅡ [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==플래시 메모리를 이루고 있는 저장 단위/용어== 
	- <span style="background:#d3f8b6">플래시메모리-저장단위-용어-이미지</span>
	- 셀 (cell)
		- 플래시 메모리에서 데이터를 저장하는 가장 작은 단위
		- 예시를 통한 이해
			- 셀! : 데이터를 저장할 수 있는 공간/집
			- 비트! : 0과 1을 표현할 수 있는 사람 한 명
		- 셀들이 모여 MB, GB, TB 저장 장치가 됨
		- 하나의 셀에 몇 비트를 저장할 수 있는지에 따라서 **종류**가 달라짐 | [[비트(bit)용어\|비트(bit)용어]]
			- ==종류==? | [[플래시메모리-셀-종류-비트\|플래시메모리-셀-종류-비트]]
			- 
	- 데이터 저장단위/크기 단위
		- 1. 셀들이 모여 페이지(page)
			- 다양한 페이지 상태 표현 존재
				- 1. Free 상태
					- 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태
				- 2. Valid 상태
					- 이미 유요한 데이터를 저장하고 있는 상태
				- 3. Invalid 상태
					- 유효하지 않은 데이터(쓰레기 값)을 저장하고 있는 상태
		- 2. 페이지들이 모여 블록(block)
		- 3. 블록들이 모여 플레인(plane)
		- 4. 플레인들이 모여 다이(di)
		- 
	- 플래시 메모리 내부적인 특징
		- 데이터 읽기/쓰기 시 사용하는 기본 단위와 데이터 삭제 시 사용되는 기본 단위가 다르다
		- 읽기/쓰기는 페이지 단위로 이루어짐
		- 삭제는 블록 단위로 이루어짐 = 삭제 시 읽기/쓰기 보다 더 큰 단위로 삭제됨





##### ㅡ [[플래시메모리-셀-종류-비트\|플래시메모리-셀-종류-비트]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==종류==
	- 1. 한 셀에 1비트 저장 플래시 메모리 = SLC 타입 = 싱글 레벨 셀
		- 특징/장점
			- 하나의 셀에 1비트-정보 저장 가능 
				- = 하나의 셀로 두 개의 정보 표현 가능
				- EX) 1과 0 표현 가능
			- 1비트 저장으로 인한 빠른 입출력
				- 이해예시 :  하나의 공간/집에 1명만 살고 있으면 빠르게 밖으로 나갈 수 있음.
			- 긴 수명
			- 용량 대비 고가격
				- 이해예시 : 한 집에 혼자서 살고 있음. 따라서 혼자서 월세 내야함
				- 
	- 2. 한 셀에 2비트 저장 플래시 메모리 = MLC 타입 = 멀티 레벨 셀
		- 특징/장점
			- <span style="background:#d3f8b6">MLC타입-비트-이미지</span>
			- 하나의 셀에 2비트-정보 
				- = 하나의 셀로 4가지 정보 표현 가능
			- SLC보다 느린 입출력
				- 이해예시 : 하나의 공간/집에 2명이 살고 있으니 1명이 존재했을 때보다 느리게 나갈 수 있음
			- SLC보다 짧은 수명
				- 이해예시 : 입구에서 충돌이 발생하니까....
			- SLC보다 저렴
			- SLC보다 시중에서 많이 사용
				- SLC보다 저렴 + 더 많이 저장-표현이 가능하기 떄문
				- 
	- 3. 한 셀에 3비트 저장 플래시 메모리 = TLC 타입 = 트리플 레벨 셀
		- 특징/장점
			- 하나의 셀에 4비트-정보
				- = 하나의 셀로 8가지 정보 표현 가능
			- MLC보다 느린 입출력
			- MLC보다 짧은 수명
			- MLC보다 시중에서 많이 사용
			- 
	- 4. 한 셀에 4비트 저장 플래시 메모리 = QLC 타입 = 쿼드 레벨 셀
		- 
	- 종류에 따라서 메모리 **성능**, **가격**, **수명**이 달라짐.
		- <span style="background:#d3f8b6">다양한종류-셀-특징표-이미지</span>
	- 성능? =>
		- 셀 당 비트 수가 증가할수록 즉, SLC에서 QLC로 갈수록, 셀 내에서 데이터를 읽고 쓰는 **과정이 복잡**해집
		- 과정이 복잡? =>
			- 메모리의 읽기 및 쓰기 속도에 직접적인 영향을 미치며, 비트 수가 많을수록 처리 속도가 느려질 수 있습
	- 수명? =>
		- 셀의 수명은 주로 쓰기 **사이클**(데이터를 쓰고 지우는 횟수)에 의해 결정
			- = 셀이 견딜 수 있는 쓰기/삭제 작업의 횟수에 의해 결정되며, 이 횟수가 소진되면 메모리 셀이 더 이상 정상적으로 기능하지 못하게 됩
			- 사이클 횟수가 많다 = 셀이 한번에 처리/저장하는 양이 적다 = 셀이 받는 부하가 적다 = 수명이 길다 = 마모가 적다
			- 
			- "높은 데이터 쓰기 사이클을 지원한다"는 문장 존재
				- = 데이터를 저장하고 삭제하는 과정을 더 많이 견딜 수 있음을 의미
				- = 더 높은 내구성을 가진다는 것을 의미
				- = 메모리 수명이 더 길다는 것을 의미
			- 
		- SLC 메모리가 한 셀에 데이터를 한 비트만 저장 > 그 셀이 받는 부하가 적어 다른 유형의 메모리보다 더 많은 쓰기/삭제 작업을 견딜 수 있음
		- QLC 메모리는 한 셀에 더 많은 데이터를 저장 = 한 셀에 4비트를 저장
			- = 비트 수가 증가 > 표현할 수 있는, 한번에 처리할 수 있는 경우의 수 증가 > 메모리의 셀은 더 높은 수준의 전기적 스트레스와 복잡한 데이터 관리를 경험
			- = 셀 당 처리하는 정보량이 많기 때문에 더 민감하게 반응하여 더 빠른 성능 저하를 가져오고, 따라서 쓰기 사이클이 감소
		- 즉, QLC는 더 많은 데이터를 저장할 수 있지만, 이는 셀이 더 빨리 마모되는 원인이 되어 전체적인 메모리 수명을 단축
		- 
	- 가격? =>
		- 셀 당 비트 수가 증가하면 해당 메모리 셀이 더 많은 데이터를 저장할 수 있으므로, 이론적으로는 저장 용량이 늘어남 > 그렇다면 더 많은 데이터를 저장하면 더 비싸겠군! > X
		- 저장할 수 있는 데이터의 양이 메모리의 단가를 결정하는 유일한 요소는 X
		- 가격 결정에는 여러 요소가 작용
		- EX) 성능측면과 내구성 측면
			- QLC 메모리는 한 셀에 4비트를 저장할 수 있어 용량 대비 비용이 낮지만, 이는 성능과 내구성의 저하를 수반 > 수명이 짧음
			- SLC는 더 빠른 데이터 액세스와 높은 쓰기/지우기 사이클을 제공하기 때문에, 고성능을 요구하는 응용 프로그램에서 선호

##### ㅡ [[캐시메모리-성능-작동원리\|캐시메모리-성능-작동원리]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
			- 캐시
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==캐시 메모리? =>==
	- CPU 내부에 존재하는 레지스터보다 용량이 크고, 메모리보다 용량이 작지만 속도는 빠른 SRAM 기반 저장 장치
		- = 따라서 RAM에 존재하는 모든 내용을 미리 저장할 순 없다.
	- 캐시 메모리는 CPU가 실행 후 생성된 결과물 중 자주 사용되는 데이터를 **임시 저장**
	- 임시 저장? =>
		- CPU가 미래에 다시 접근할 가능성이 높은 데이터를 **예측**해 **미리 저장** 후 > 빠르게 제공하여 처리 속도를 향상시키고, 메인 메모리와의 데이터 전송 횟수를 줄이는 역할
		- 예측 > 미리저장? =>
			- 예측이 성공하면 캐시히트(Cache Hit 용어) 발생! 표현 사용
				- <span style="background:#d3f8b6">캐시히트-이미지</span>
					- 이미지 설명 =>
					- 예측이 성공한 상황 > 따라서 메모리까지 접근하지 x 
					- 상황예시
						- 자주 사용하는 값을 클라이언트가 서버에 데이터 요청 > 서버는 매번 응답 = 비효율
						- 웹 서버 자주 사용하는 데이터 클라이언트 측-캐시 저장 후 재요청 시 직접 반환 = 효율적
							- = 빈번하게 접근하는 데이터는 L1 캐시에 저장되어 빠르게 액세스할 수 있으며, 덜 접근하는 데이터는 L2 또는 L3 캐시에 저장됩
						- 자주 사용하는 값? =>
							- 정적 데이터/정적 자원
								- 웹 페이지 이미지
								- 스타일시트, 스크립트 
								- 
			- 예측이 실패하면 캐시 미스(Cache Miss 용어) 발생! 표현 사용
				- <span style="background:#d3f8b6">캐시미스-이미지</span>
			- 이러한 상황에서 사용하는 공식 존재 = 캐시 적중률!
				- 캐시 히트 횟수 / (히트 횟수 + 캐시 미스 횟수)
				- Long Tail 법칙 그래프 존재
				- 
			- 성능을 높인다! = CPU가 사용할 법한 데이터를 잘 예측한다
			- 참조 지역성의 원리 : CPU가 메모리에 접근할 때 주된 **경향성/패턴/규칙**을 바탕으로 만들어진 원리
			- 경향성 존재? =>
				- 1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
				- 2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다 = 공간 지역성
				- 
	- <span style="background:#d3f8b6">캐시메모리 존재이유-이미지</span>
	- CPU가 메모리에 접근하는 시간은 CPU 연산 속도보다 느리다.
	- CPU와 메인 메모리 사이의 데이터 전송 속도 차이/메모리 접근 시간/데이터 처리 속도를 완화하기 위한 방법 중 하나 = 중간에 캐시 메모리를 배치
		- = 이는 **프로세서의 성능**을 결정하는 중요한 요소 중 하나
		- ==프로세서(Processor) 성능? =>== | [[프로세서(Processor)-CPU-성능\|프로세서(Processor)-CPU-성능]]


##### ㅡ [[프로세서(Processor)-CPU-성능\|프로세서(Processor)-CPU-성능]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==프로세서(Processor) 성능? =>==
	- 프로세서는 그 프로그램을 실행하는 하드웨어 장치를 의미 
	- = CPU(Central Processing Unit)를 가리키는 용어로 사용
	- 
	- 각 용어는 프로세서 성능 향상의 다양한 이점을 나타내며, 비록 서로 연결되어 있기는 하지만, 각각이 강조하는 부분은 다릅
	- 1. **응답시간 단축:** 
		- 프로세서의 향상된 성능은 컴퓨터가 사용자가 입력한 명령어을 더 빠르게 처리하게 해, 사용자와 시스템 간의 상호작용이 빨라지게 합
		- 
	- 2. **로딩속도 향상:** 
		- 향상된 프로세서는 사용자가 입력한 명령어를 pc가 해석한 이후 작업인 = 메모리와의 데이터 교환을 더욱 빠르게 할 수 있어, 필요한 데이터나 애플리케이션의 로딩 시간이 단축
			- = 메모리와 데이터 교환 속도 = 데이터 처리 속도= 액세스 속도
			- = 사용자가 프로그램이나 파일을 더 빠르게 열 수 있게 합
		- 
	- 3. **서버 부하 감소:** 
		- 서버측 pc 성능 향상 이점.
		- 서버 내 프로그램을 동시에 처리할 수 있는 작업량이 증가
		- = 서버가 더 많은 사용자 요청을 처리할 수 있게 하고, 서비스의 가용성과 신뢰성을 높입


##### ㅡ [[컴퓨터구조-이미지\|컴퓨터구조-이미지]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 이미지
	- 전체구조도
	- <span style="background:#d3f8b6">시스템버스-cpu-작동예시</span>
	- 메인보드-마더보드(mother board)-시스템보드(system board)
	- 중앙처리장치CPU-이미지
	- 주기억장치-RAM-메인메모리
	- <span style="background:#d3f8b6">보조기억장치-HDD-SSD</span>
	- 아두이노-라즈베리파이-이미지
	- 
- SSD (Solid State Drive)
	- <span style="background:#d3f8b6">SSD내부-이미지</span>
	- 전통적인 하드 드라이브보다 빠른 데이터 액세스 속도를 제공하는 저장 장치로, 여러 핵심 구성 요소를 포함
	- SSD 컨트롤러
		- SSD의 작동을 제어하며, 데이터 읽기/쓰기, 에러 수정, 웨어 레벨링 등의 작업을 관리
	- DRAM (Dynamic Random-Access Memory)
		- 데이터를 일시적으로 저장하여 SSD 컨트롤러가 빠르게 접근할 수 있도록 하는 버퍼 역할
	- 낸드 플래시 메모리 (NAND Flash Memory)
		- SSD에서 데이터를 영구적으로 저장하는 주요 구성 요소

##### ㅡ [[CPU-레지스터-작동과정예시\|CPU-레지스터-작동과정예시]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 1~4번 레지스터 작동과정 예시
	- <span style="background:#d3f8b6">1~4번 레지스터 작동과정-이미지</span>
	- 
	- 실행할 프로그램(명령어와 데이터들)이 메모리에서 1000번 ~ 1500번에 저장되어 있음
	- `프로그램 카운터`에 실행될 메모리 처음 위치가 저장됨
		- = 즉 1000번지에 존재하는 값이 필요함
	- (접근해야 하니까...)프로그램 카운터에 있던 주소 값이 `메모리 주소 레지스터`에 해당값이 복사된다 
	- 메모리 주소 레지스터에 저장된 주소위치는 `주소버스`를 통해 메모리로 전달 + 동시에 제어장치에서 생성된 제어신호는 `제어버스`통해 메모리로 전달
	- 메모리가 주소값+명령-제어신호를 받은 후 명령어대로 1000번지에 저장된 값을 CPU쪽으로 `데이터버스`를 통해 보내준다. = `메모리 버퍼 레지스터`에 보내준다. 
	- 위 작업/메모리에서 보내진 값이 `메모리 버퍼 레지스터`에 저장이 되면 동시에 다음작업 수행을 위해 `프로그램 카운터`에 있던 값을 증가시킨다. (순차적인 실행 흐름위해)
	- 메모리 에서 받은 값이 `명령어 레지스터`에 할당된다. 즉 1000번지에 존재하던 값이 해당 레지스터에 할당된다.
	- 순차적인 실행 흐름? =>
		- 순차적인 실행 흐름이 끊기는 경우 존재
			- 1. 인터럽트(Interrupt) 발생 시
				- 인터럽트 용어 | [[입출력방식-인터럽트기반-과정이해#- CPU-인터럽트-요청신호-처리과정-이미지\|입출력방식-인터럽트기반-과정이해#- CPU-인터럽트-요청신호-처리과정-이미지]]
					- 1. **인터럽트 과정**: 
						- 이는 CPU가 현재 실행 중인 프로세스나 작업을 일시적으로 중단하고, 더 높은 우선순위를 가진 작업을 처리하고 이 작업이 완료되면, CPU는 원래 수행 중이던 작업으로 돌아가 계속 수행 과정/매커니즘을 의미
						- 이 과정은 시스템의 효율성과 반응성을 향상
							- = 특정한 신호나 사건에 반응하여 시스템의 응답성과 효율성을 높이는 추상화된 용어
							- =  하드웨어 또는 소프트웨어에 의해 발생하는 이벤트에 대응하는 CPU의 작동 방식을 지칭하는 용어
							- =  CPU가 다양한 태스크와 요청 사이에서 멀티태스킹을 수행하는 과정을 묘사하는 용어
							- 
					- 2. **인터럽트 (요청) 신호**: 
						- 인터럽트는 또한 CPU에게 현재 작업을 중단하라고 알리는 전기적인 신호로도  이해 가능
						- 이 신호는 하드웨어 장치나 소프트웨어 프로그램에서 발생
				- 
			- 2. (일반적인 상황) 프로그램 내 실행 흐름 변경:
				- 이는 프로그래머가 프로그램의 논리에 따라 의도적으로 실행 순서를 변경하는 경우
				- EX) 프로그래밍 언어(고급언어)로 조건문 작성을 통해 실행 순서 변경하는 상황
				- 위 예시 내부과정 이해 =>
					- <span style="background:#d3f8b6">파이썬 예시코드</span>
						- 파이썬 코드는 실행될 때, 파이썬 인터프리터에 의해 내부적으로 CPU가 이해할 수 있는 명령어로 변환되고 있음
						- `a > b`가 참일 경우: (CONDITIONAL JUMP) 저수준 명령어 실행되어 > "a is greater"를 출력하는 코드의 위치로 점프
						- 즉, 내부적으로 이러한 점프가 있기에 프로그램의 실행 흐름을 적절하게 제어가 되고 있던 것
					- 파이썬과 같은 고급 언어로 조건문을 작성할 때 내부적으로는직접 저수준 명령 코드를 작성하지 않지만, 컴파일러나 인터프리터는 그러한 조건문을 저수준의 명령어로 변환
					- 저수준 명령어? =>
						- JUMP, CONDITIONAL JUMP 등이 포함
						- 일반적인 사용자나 개발자는 파이썬과 같은 고급 프로그래밍 언어를 사용할 때, 그 언어의 문법과 코드 표현식을 이해하고 사용할 줄 알면 충분 =  사용자가 저수준의 명령어를 직접 다루지 않아도 됨. 이 모든 저수준 작업은 파이썬 인터프리터에 의해 추상화되어 처리됩
					- 왜? 
						- 파이썬과 같은 고급 프로그래밍 언어로 작성된 코드는 컴퓨터에서 직접 실행될 수 있는 형태가 아님
					- 주의
						- 이 과정에서 실제 메모리 주소가 변경되는 것은 아니고, `프로그램 카운터`가 가리키는 명령어의 위치가 변경되는 것
							- = 조건문 실행 시 이 프로그램 카운터의 값이 변경되어 다음에 실행할 명령어의 위치를 결정

##### ㅡ [[프로세서-프로그램-설치버전-이해\|프로세서-프로그램-설치버전-이해]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 프로세서 아키텍처에 따른 적절한 소프트웨어 버전 선택
	- 특정 소프트웨어는 호환되는 프로세서 아키텍처에 따라 설치해야 하는 버전이 다르다 > 따라서 사용자는 자신의 장치에 맞는 올바른 소프트웨어를 선택하고 설치
- 프로세서 아키텍처 설명
	- 프로세서 = 중앙처리장치 = CPU
	- "64-bit x86"과 "64-bit Arm" 프로세서 아키텍처의 차이
	- 
	- (전통적인)x86 아키텍처 =>
		- 주로 인텔과 AMD가 제조
	- Arm 아키텍처 =>
		- 특히 최근의 Apple M1 칩과 같은 최신 기술에서 사용
		- ex) 애플 노트북에 탑재된 M1 칩과 같은 Arm 기반 프로세서가 사용되는 경우, 해당 기기에는 Arm 아키텍처에 맞는 소프트웨어 버전을 설치

##### ㅡ [[다양한종류-레지스터\|다양한종류-레지스터]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==다양한종류-레지스터==
	- 각각 다른 역할/기능 수행 = 각각 다른 종류 데이터 저장
	- ==1~4번 레지스터 작동과정 예시== | [[CPU-레지스터-작동과정예시\|CPU-레지스터-작동과정예시]]
	- 
	- 1. 프로그램 카운터(Program Counter, PC)
		- CPU가 다음에(미리..) 실행할 명령어/메모리에서 가져올 명령어 주소 저장
			- = 현재 실행 중인 명령어의 주소를 가리키며, 프로그램의 실행 흐름을 관리하는 데 사용
	- 2. 명령어 레지스터(Instruction Register, IR)
		- 현재 실행 중인 명령어를 저장
		- 메모리에 존재하는 명령어들의 주소를 저장 = 제어장치가 해석할 명령어 저장
	- 3. 메모리 주소 레지스터(Memory Address Register, MAR)
		- CPU가 데이터를 저장 OR 사용하던 특정 메모리 위치에 접근할 필요가 있을 때, 그 위치의 주소 정보를 MAR에 저장
		- 메모리 컨트롤러는 이 주소를 사용하여 해당 메모리 위치와 데이터를 교환
		- MAR은 메모리와 CPU 사이의 데이터 통신을 원활하게 하기 위해 필수적인 레지스터
	- 4. 메모리 버퍼 레지스터(Memory Buffer Register, MBR) 또는 메모리 데이터 레지스터(Memory Data Register, MDR
		- 메모리에서 읽은/가져온 데이터나 메모리에 쓸 데이터를 임시로 저장하는 역할
		- 예시상황
			- CPU입장에서 데이터를 보낸다 = 데이터를 쓴다 = 메모리입장에선 데이터를 받는다
				- 반대로, CPU가 데이터를 메모리에 쓸 때, 그 데이터는 먼저 MBR/MDR에 저장된 후, 해당 메모리 주소로 전송됩
			- CPU입장에서 데이터를 받는다 = 데이터를 읽는다 = 메모리입장에서 데이터를 보낸다.
				- CPU가 메모리에서 데이터를 읽을 때, 해당 데이터는 먼저 MBR/MDR에 저장되고, 이후 CPU로 전송됩
	- 5. 상태 레지스터(Status Register) 또는 플래그 레지스터(Flag Register): 
		- 기존기록 확인
	- 6. 범용 레지스터(General Purpose Registers)
		- 다양한 용도?
			- 데이터 저장, 중간 계산 결과의 보관, 주소 계산, 루프 카운팅 등 
			- 다양한 데이터와 메모리에서 가져올 명령어 주소 값을 임시로 저장 사용
		- ㅡㅡㅡㅡ본문내용
		- 프로그램 내에서 **다양한 용도**로 사용 = 범용 레지스터는 그 활용도가 훨씬 넓고 유연 = 다른 레지스터 기능들 범용적 수행
	- 7. 스택 포인터(Stack Pointer, SP)
		- 기존노트 확인 : [[자료구조-용어\|자료구조-용어]]
	- 8. 베이스 레지스터
		- ==유효한 메모리 주소에 접근하기 위한 두 가지 방식== | [[유효한메모리주소-접근방식\|유효한메모리주소-접근방식]]


##### ㅡ [[RAM메모리-작동원리-성능\|RAM메모리-작동원리-성능]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==RAM의 기본적인 작동 원리==
	- 데이터 상호작용 순서 =>
	- 1. CPU(연산처리 진행) <> 2. RAM (실행할 대상/프로그램 존재) <> 3. 보조기억장치 (보관할 대상/프로그램 존재)
	- 상황예시
		- RAM으로 복사됨?
			- <span style="background:#d3f8b6">RAM용량-성능-이미지</span>
				- : 보조기억 장치는 3개의 프로그램을 가지고 있는 상태. 하지만 RAM은 용량이 작아 1개만 가지고 있을 수 있는 상태 > RAM 용량-사이즈가 커지면 한번에 많은 프로그램을 가지고 있을 수 있는 상태
			- 따라서 한 번에 여러 프로그램을 실행하거나 무거운 프로그램을 실행하려면 **RAM 용량**이 높아야 한다. (한 번에 여러 프로그램 = 많은 공간)
				- + RAM의 용량이 크다 = 성능이 좋다
			- 실행하고 있는 프로그램(명령어+데이터)가 RAM 위에 저장/할당/복사 된 상태
		- ㅡㅡㅡㅡ본문내용
		- 사용자가 컴퓨터에서 'a'라는 프로그램을 실행
		- 운영 체제는 보조기억장치에서 'a' 프로그램을 찾는다
		- 프로그램 'a'는 보조기억장치에서 RAM으로 복사 = 프로그램의 코드와 필요한 데이터가 메모리로 옮겨집 > (프로그램을 종료하면 RAM의 해당 작업 공간은 비워진다)
		- CPU는 RAM에서 'a' 프로그램을 읽어서 명령어를 처리하기 시작
		- 즉,  보조기억장치에 있는 프로그램을 실행할 때, 그 프로그램은 **RAM으로 복사됨** > 이는 실행 중인 프로그램이 빠르게 데이터에 접근하고 처리할 수 있게 해 주며, 보조기억장치에서는 해당 프로그램이 사라지지 않고 그대로 유지


##### ㅡ [[D-S-RAM-종류\|D-S-RAM-종류]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==RAM 램의 종류==
	- 크게 4가지 존재.
	- 1. DRAM(Dynamic RAM) = 디램
		- 특징/장점/단점
			- 새로 고쳐준다?
				- DRAM의 각 셀에는 1비트의 데이터를 저장하기 위해 한 개의 커패시터와 한 개의 트랜지스터가 사용
				- 데이터는 커패시터에 전하의 형태로 저장되며, 전하의 유무로 1과 0을 표현
				- "정보를 고쳐준다"는 말은 커패시터에 전하를 다시 충전하여 데이터를 원래의 상태로 유지시키는 행위를 의미
			- 전하 누설? =>
				- `DRAM` 특성 상 사용하는 커패시터는 지속적으로 전하를 잃는다. 즉, 전원이 켜져 있는 동안에도 커패시터의 전하 누설로 인해 데이터가 점차 사라지기 때문에, 전원 공급 중이더라도 주기적으로 리프레시(재활성화)가 필요
				- = SRAM과 차이점 : 구조적 차이로 인해 전원 공급 중 데이터가 안정적으로 유지
			- ㅡㅡㅡㅡ본문내용
			- 디램이 가진 장점으로 인해 일반적으로 메모리에 많이 사용됨
			- 메모리 셀에 데이터를 저장하기 위해 `커패시터`와 `트랜지스터`를 사용
			- 커패시터는 전하를 저장하는 방식. > 시간이 지남에 따라 **누설**되어 그 전하를 잃게 되는 특징 존재 (저장된 데이터가 동적으로 사라짐) > 이 때문에 DRAM은 저장된 정보를 유지하기 위해 주기적으로 **새로 고쳐**줘야 하는데, 이 과정을 "**리프레시(refresh)**"라고 함
				- 
	- 2. SRAM(Satic RAM) = 에스램
		- 특징
			- 전원이 공급되는 한 저장된 데이터가 사라지지 않는 RAM
			- DRAM보다 일반적으로 빠른 속도 > DRAM보다 가격이 높다
			- 주로 `캐시` 메모리에서 사용
			- 
	- Q. DRAM <> SRAM 어떤 것을 사용?
		- <span style="background:rgba(205, 244, 105, 0.55)">D-S-RAM표-이미지</span>
		- DRAM과 SRAM은 각각의 요구상황과 해당 RAM이 가진 특성을 고려하여 선택
		- 1. 비용 효율성 차이
			- DRAM은 SRAM보다 훨씬 비용 효율적
			- = "소비전력이 낮다"는 장기적으로 "비용적으로 효율적이다"같은 의미
			- 왜?
				- SRAM을 구성하는 데는 더 많은 트랜지스터가 필요하며, 이로 인해 SRAM은 같은 양의 데이터를 저장하기 위해 DRAM보다 더 많은 공간을 차지하고 더 비쌉 
				- = 대량의 메모리가 필요한 시스템에서는 DRAM이 훨씬 경제적
				- 
		- 2. 밀도의 차이
			- "밀도가 높다"는 표현은 물리적 공간 대비 데이터를 저장할 수 있는 용량이 크다는 것을 의미하며, "집적도가 높다"는 같은 양의 공간에서 더 많은 데이터를 저장할 수 있다는 것을 의미. 따라서 같은 맥락에서 사용
			- DRAM은 SRAM에 비해 더 높은 데이터 밀도를 제공. > 이는 DRAM이 더 적은 공간을 사용하여 더 많은 데이터를 저장할 수 있음을 의미
				- = 대용량 메모리를 필요로 하는 응용 프로그램에서 DRAM이 선호
				- 
		- 3. 용도의 차이 
			- SRAM은 그의 빠른 접근 속도 덕분에 캐시 메모리 같이 빠른 데이터 접근이 필수적인 상황에 주로 사용 
			- DRAM은 시스템의 주 메모리와 같이 큰 용량이 요구되지만 접근 속도가 SRAM만큼 민감하지 않은 경우에 사용
			- 
	- 3. SDRAM (Synchronous DRAM) - 에스디 
		- = SDR(Single Date Rate) SDRAM 표현 가능
		- 발전된 형태의 DRAM
		- = 클럭 신호화 동기화된 DRAM 표현 가능
		- 
	- 4. DDR SDRAM (Double Data Rate SDRAM)
		- <span style="background:rgba(205, 244, 105, 0.55)">SDR과 DDR 차이점-이미지</span>
		- 의미/특징
			- 최근 가장 대중적으로 사용되는 RAM 종류 중 하나
			- 발전된 형태의 SDRAM = **대역폭**을 넓혀 속도를 빠르게 만든 SDRAM
			- 대역폭이란? =>
				- 데이터를 이동 시 주고 받는 길의 너비  > 너비가 클수록 한번에 주고받을 수 있는 데이터 양이 많다진다 =  속도가 빨라진다
		- DDR2 SDRAM도 존재
			- <span style="background:rgba(205, 244, 105, 0.55)">SDR-DDR2-차이점-이미지</span>
			- DDR SDRAM 의미 생각 > 2의 제곱승으로 성능이 좋아짐
			- EX) 2 > 4 > 8 > 16 ....


##### ㅡ [[HDD구성요소\|HDD구성요소]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==HDD-구성요소== => 
- <span style="background:#d3f8b6">HDD구성요소-이미지</span>
	- 플래터(platter)
		- 비 자성체인 비금속 원판 표면에 자성체인 산화 금속 막을 양면에 도장한 것
		- 산화 금속의 막을 논리적으로 나눈(partitioning)뒤 위치를 지정(formatting)하면 정보를 저장할 수 있게 됩
		- 플래터 양면 모두 사용
		- 
		- 플래터에 존재하는 저장 단위 =>
			- 하나의 플래터는 `트랙`과 `섹터`-저장단위를 나눌 수 있음
			- 여러 플래터가 모여 + 같은 트랙들이 모이면 `실린더`! 저장단위로로 나눌 수 있음
			- 
			- <span style="background:#d3f8b6">섹터-트랙-실린더-이미지</span>
			- 트랙, 섹터 (Track, Sector)
				- 하드디스크 기록 단위의 하나로 자기 매체에 늘어선 동심원으로 구획된 하나하나를 트랙이라 부르고 그 트랙들은 다시 섹터로 나뉘게 됩
				- 섹터(sector)와 트랙(track) 단위로 데이터를 저장
				- 섹터의 크기 : 512 바이트 ~ 4096 바이트
				- 하나 이상의 섹터를 묶어 블록(block)이라고 표현하기도 함
			- 실린더(cylinder)
				- 여러 겹의 플래터 상에서 같은 트랙이 위치 한 곳을 모아 연결한 논리적 저장 단위
				- 연속된 정보는 한 실린더에 기록된다.
				- 왜?
					- 복기 - `헤드는 같이 움직인다`
					- 하나의 실린더에 연속된 데이터를 저장하면 헤드를 움직이지 않고 바로 데이터를 읽/쓸 수 있음
					- 
	- 스핀들(Spindle)
		- 플래터가 회전할 수 있도록 모터와 직접 연결된 축
		- 플래터를 일정한 속도로 회전시키는 장치인 모터가 존재 하고, HDD용 모터는 스핀들에 직접 연결이 되어 있음 = "스핀들 모터"
		- RPM 용어 : 분당 회전수
		- 플래터를 축에 단단히 고정을 시킵
		- 스핀들에 여러장의 플래터를 설치할 경우에는 플래터 사이에 지름이 1.25" 두께 1/8" 의 스페이서(Spacer)를 넣어서 함께 고정
		- 
	- 헤드(Head)
		- 플래터 표면에 정보를 저장 또는 삭제를 하는 장치 또한 저장된 정보를 읽는 역할
		- 일반적으로 해더의 수는 플래터의 수의 2배
		- 왜?
			- 플래터는 양면이기 때문에 한장의 플래터는 2개의 면으로 되어 있기 때문에 각면에 하나씩 해서 헤드가 2개가 필요. 즉, 3장의 플래터로 구성된 하드디스크는 6개의 헤드가 필요
			- 
	- 헤드 구동 장치(Actuator)
		- 주의 
			- 헤드 구동 장치(actuator)는 디스크암을 포함하는 더 큰 시스템.
			- 즉, 디스크암은 헤드 구동 장치의 중요한 부분 중 하나이지만, 전체 헤드 구동 장치 시스템을 단순히 '디스크암'이라고 부르는 것은 그 기능과 구성을 완전히 설명하지 않음
			- 헤드 구동 장치는 디스크암을 움직여서 HDD 내부의 읽기/쓰기 헤드가 디스크 표면 위에서 정확한 위치로 이동할 수 있도록 합
			- 
		- 액츄에이터 라고 불리는 장치는 헤드를 움직이는 장치
		- HDD 회로 기판으로 부터 제어신호를 받으면 actuator용 구동장치는 헤드가 부착된 암을 지정한 위치 까지 이동 시킵


##### ㅡ [[HDD작동원리-데이터접근과정\|HDD작동원리-데이터접근과정]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==HDD작동원리-데이터접근과정==
	- 하드 디스크의 작동원리
		- 하드디스크의 자성 물질로 덮인 플래터를 회전 시키고, 그 위에 헤드를 접근시켜 플래터 표면 자기 배열을 변경하는 방식으로 데이터를 읽거나 쓴다.
		- = 전자기 기술을 사용해 데이터를 저장
		- 
		- 플래터의 중심에는 플래터를 회전 시키기 위해서 `스핀들 모터`가 있고, 스핀들 모터의 회선속도(RPM)가 높을 수록 더욱 빠르게 데이터를 읽고 쓸 수가 있다. 허나 소음과 진동이 발생하는 단점 발생
		- `헤드`는 실제로 플래터와 접촉을 하고 있는 것이 아니고 표면에 살짝 더있는 상태로 데이터를 읽거나 쓴다. 따라서 하드 디스크가 동작하는 도중에 외부에서 충격이 가해지거나 갑자기 전원이 차단되면 헤드가 플래터의 표면을 긁어서 고장 나기도 합
		- 
	- HDD-데이터 접근 과정
		- 하드 디스크에 저장된 데이터를 읽거나, 저장할 때 보통 **3개의 시간**이 소요됨
			- = 하드 디스크가 저장된 데이터에 접근하는 시간
		- 3개의 시간? =>
			- 1. 탐색시간(seek time)
				- <span style="background:#d3f8b6">탐색시간-이미지</span>
				- 필요한/접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
				- ex) 0번 트랙 존재하던 헤드 > 1번 트랙으로 이동
				- 
			- 2. 회전지연(rotational latency)
				- <span style="background:#d3f8b6">회전지연-이미지</span>
				- 헤드가 있는 곳으로 플래터-섹터를 회전시키는 시간
				- 
			- 3. 전송시간(transfer time)
				- <span style="background:#d3f8b6">전송시간-이미지</span>
				- 헤드와 해당 데이터가 저장된 섹터가 만난 이후 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간
				- 
		- <span style="background:#d3f8b6">Jeff-시스템성능-접근시간표-이미지</span>
			- 이미지 설명 =>
			- Jeff Dean - numbers every programmer should know (모든 프로그래머가 알아야 하는 기본적인 숫자들)
			- ns(나노초) 단위 존재
			- 패킷 : 네트워크 기본 전송 단위
			- 해당 표에 나와있는 시간 단위/HDD 데이터 접근 과정시 발생하는 시간 작아 보이더라도 전체적인 관점/컴퓨터 시스템에서 발생하게 되는 시간들에 비해서 굉장히 큰 시간이라고 표현 가능
			- 
			- CPU와 가까울 수록 빠름
				- = 내부 메모리 접근 시간이 네트워크를 통한 접근 시간보다 훨씬 빠르다
				- = Jeff Dean의 숫자에 따르면 메모리에 데이터를 읽는 데는 일반적으로 몇 십 나노초가 걸리지만, 네트워크를 통해 데이터를 보내는 데는 수십 밀리초가 소요될 수 있음
				- 
			- 상황예시
				- 웹 어플리케이션을 개발할 때 데이터베이스 응답 시간을 최적화하고자 할 때, 이러한 숫자들을 참고하여 로컬 메모리 접근이 네트워크 요청보다 월등히 빠르다는 것을 확인하고  설계-캐싱 전략을 구현
				- 즉,  웹 애플리케이션에서 자주 요청되는 데이터를 로컬 메모리에 캐싱하는 것은 네트워크를 통해 서버로부터 매번 데이터를 가져오는 것보다 훨씬 빠르고 효율적 = 서버의 부하를 줄이고 응답 시간을 단축시켜 사용자 경험을 향상
		- Jeff Dean이 제안한 컴퓨터 시스템의 성능 측정을 위한 기준 숫자 존재 > 소프트웨어를 설계하거나 문제를 해결할 때 참고해야 할 중요한 시스템 연산과 네트워크 지연 시간에 대한 기준점를 제공함
			- = 데이터를 어디에 저장하고 접근하는 것이 효율적인지를 판단하는 데 도움



##### ㅡ [[유효한메모리주소-접근방식\|유효한메모리주소-접근방식]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
	    - 레지스터, 캐시
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==유효한 메모리 주소에 접근하기 위한 두 가지 방식== 
	- 메모리 주소 접근하는 방식이 존재하는 **이유** =>
		- 모든 주소를 있는 그대로 저장하는 방식 사용?
			- 여러 가지 제약사항과 단점이 발생
			- 모든 주소값을 사전에 알고 있어야 하며, 프로그램이 런타임에 데이터 구조의 크기나 위치가 변경되었을 경우 이를 적절히 처리할 수 없습
				- = 동적으로 접근 X 
				- = 유연성 X 
			- 프로그램이 특정 메모리 주소에 고정되어 있기 때문에, 코드의 재사용성이 떨어지고 유지 보수가 어려워집
			- 프로그램이나 데이터 구조의 확장이 필요할 때, 모든 관련된 주소 참조를 업데이트해야 하는 번거로움
			- 상황예시
				- 배열이나 리스트와 같은 연속된 메모리 구조에서 시작 주소만 알고 있으면, 그 시작 주소에 인덱스와 데이터 타입의 크기를 곱한 값을 더해 각 원소에 접근 가능
				- 이렇게 하면, 데이터 구조의 크기가 변경되거나 다른 메모리 위치로 이동해도 동일한 접근 방식을 유지할 수 있습
		- ㅡㅡㅡㅡ본문내용
		- 메모리에 연속적으로 저장된 데이터에 대해 유연하고 동적으로 접근할 수 있게 하는 것 > 이 방식을 통해 프로그램은 실행 시점에 데이터 구조 내의 특정 요소에 효율적으로-유연하게 접근 가능
			- = 메모리에 접근하는 유연성을 향상시키는 방식
		-  이 방식은 프로그램의 시작점 또는 기준이 되는 주소에 변위(오프셋) 값을 더하거나 빼서 원하는 메모리 위치에 접근. 즉, 레지스터에는 기준이 되는 주소 1개만 저장 > 변위값을 이용해 각각에 접근
		- **모든 주소**를 **고정**하여 **저장**하는 것보다 메모리를 더 효율적으로 사용
			- = 프로그램을 더 동적으로 만들며, 재사용성과 유지 보수성을 개선
			- 
	- <span style="background:#d3f8b6">메모리주소-접근방식-이미지</span>
		- 어떤 방식을 사용하는지에 따라 어떤 레지스터가 사용될지 달라짐
		- 두 방식은 모두 메모리 주소를 동적으로 계산하는 방법이지만, 사용되는 기준점이 다릅
		- 변위 주소 지정은 특정 베이스 주소로부터의 오프셋을 이용하는 반면, 상대 주소 지정은 현재 코드의 위치나 명령어의 위치를 기준으로 한 오프셋을 사용
		- 
	- 요약 :
		- `프로그램 시작 주소 저장
		- `실행 중인 명령어 주소 저장
	- 1. 변위 주소 지정 방식(Displacement-Addressing)
		- 변위?
			- 주어진 기준점(베이스 레지스터의 값)으로부터 얼마나 떨어진 위치인지를 나타내는 값
		- ㅡㅡㅡㅡ본문내용
		- <span style="background:rgba(205, 244, 105, 0.55)">베이스레지스터-동작과정-이미지</span>
			- ex) 50일 경우 > 기준/처음 위치에서 얼만큼 떨어져서...
		- 베이스 주소(또는 시작 주소)에 변위(또는 오프셋) 값을 더해 최종 주소를 계산
		- 상황예시
			- 배열이나 구조체에서 특정 요소에 접근할 때, 배열의 시작 주소가 베이스 주소가 되고, 배열 내에서의 요소 위치가 변위 값이 됩
			- 
		- 베이스 레지스터는 프로그램 실행 중 사용되는 데이터나 명령어의 주소를 기준으로 삼아 다른 메모리 접근을 용이하게 하는 데 사용
			- = 베이스 레지스터에 저장된 주소를 기반으로 하여, 인덱스 레지스터의 값(배열의 인덱스 등)과 **변위**값을 더해 최종적인 유효한 메모리 주소를 계산
			- = 현재 코드의 위치를 기준으로 다른 코드 또는 데이터의 위치를 찾는 방식
			- = 베이스 레지스터 값은 기준 역할 수행 (실제 메모리에서 프로그램 시작점/기준점 물리주소 존재)
			- 
	- 2. 상대 주소 지정 방식(Relative Addressing)
		- <span style="background:rgba(205, 244, 105, 0.55)">
		상대주소 지정방식-이미지</span>
		- 상대 주소 지정 방식에서는 현재 주소나 실행 중인 명령어의 주소를 기준으로 하여 메모리 주소를 계산
		- 상황예시
			- `프로그램 카운터(PC)`가 현재 실행 중인 명령어의 주소를 가리킬 때, 상대 주소는 이 PC 값을 기준으로 하여 다음에 실행할 명령어의 위치를 결정
			- `프로그램 카운터` 레지스터 기존기록 복기!



##### ㅡ [[제어장치-제어신호\|제어장치-제어신호]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==제어장치== 
	- <span style="background:#d3f8b6">제어장치-신호발생-이미지</span>
	- 요약 :
		- `신호를 생성 후 > 보낸다
		- `신호를 받기도 한다
	- : 제어신호 발생 > 각 부품들에게 전기적인 제어신호를 보내는 기능 + 명령어를 해석하는 기능
	- 
	- 컴퓨터 부품들을 동작시키기 위해선 크게 2가지 신호를 **생성**.
		- 1. ~ 위해 ~ 데이터가 필요하니 메모리 "읽기 신호" 보낸다!
			- 데이터 필요하다 = 접근하다 = 읽는다 = 사용하다
		- 2. ~위해 ~ 데이터가 저장되어 있어야 하니 메모리에 "쓰기 신호"를 보낸다!
			- 데이터를 저장하다 = 메모리에 쓴다 = 적재한다 = 위에 올린다 = 할당한다
			- 
	- 컴퓨터 부품들을 동작시키기 위해 크게 2가지 방향으로 신호를 **보낸다**.
		- 1. CPU 내부쪽으로 전달되는 제어신호
			- 1. 레지스터 전달
			- 2. ALU 전달
		- 2. CPU 외부쪽으로 전달되는 제어신호
			- 1. 메모리 전달
			- 2. 입출력장치 전달
				- 동작을 지시하는 제어 신호
				- 
	- 신호를 **받는다**.
		- 1. 명령어 레지스터에서 해석할 명령어를 받아들임
			- 명령어를 받아들이고 해석해야 기능수행/연산에 필요한 값들에 대한 제어신호를 발생 > 보낼 수 있음
		- 2. 플래그 레지스터에서 플래그 값을 받아들임
		- 3. 제어신호를 받아들임
			- 제어장치가 주로 제어 신호를 발생시키는 주체지만, 다른 구성 요소들도 특정 상황에서는 제어 신호/상태 신호를 발생시킬 수 있음.
			- 상황예시
				- 메모리가 데이터 읽기/쓰기 작업을 완료했을 때 완료 신호를 CPU에 보내거나, I/O 장치가 데이터 전송 준비가 되었음을 알리는 신호를 보낼 수 있음
		- 4. 클럭 신호 존재 
			- <span style="background:#d3f8b6">클럭-이미지</span>
			- 클럭 신호는 CPU 내부의 모든 부품에 '지금 이 순간 무엇을 시작하거나 끝내야 하는지'를 알려줍 > 즉 클럭 신호는 컴퓨터 내의 각 부품이 작업을 언제 시작하고 마무리해야 하는지를 알려주는 타이밍 신호
			- EX)
				- 클럭 신호가 한 번 발생할 때마다 CPU 내의 부품들은 다음 단계의 작업을 시작! OR 현재 단계의 작업 마무리!
			- 이해를 위한 상황예시
				- 클럭 신호를 학교의 종소리에 비유
				- 학교에서 종이 울리면, 모든 학생과 선생님이 무엇을 해야 하는지 알게 됩 > 수업 시작이다! 공부시작 , 쉬는 시간이다! 공부 마무리! 
				- 즉, 종소리는 '지금 이 시간에 해야 할 일'을 모두에게 알려주는 신호
				- 
			- 클럭 신호 존재 이유
				- 클럭 신호가 존재해야 각 부품이 동기화되어 함께 작동하면서 컴퓨터는 명령을 처리하고, 프로그램을 실행됨.
				- CPU 내의 모든 구성 요소들이 정확히 동기화되어 함께 작동해야 컴퓨터는 효율적으로 데이터를 처리하고 명령을 실행 가능
					- = 클럭 신호 없이는 컴퓨터의 다양한 부품들이 서로 조화롭게 작동하기 어려움. 즉, 작업을 시작하는 타이밍이 모두 일치해야 효율적





##### ㅡ [[ALU-산술논리장치-플래그레지스터\|ALU-산술논리장치-플래그레지스터]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==ALU-산술 논리 장치==
	- : 계산기와 같은 연산 기능 수행
	- 
	- <span style="background:#d3f8b6">ALU 받아들이는 정보-이미지</span>
	- 레지스터로부터 피연산자 값을 받아들이고 제어장치로부터 제어신호를 받아들임
	- 상황예시
		- 연산을 수행하기 위해선 연산자!와 피연산자! 값 필요 (데이터와 명령어 필요)
		- 1 + 2 연산 수행 상황
			- 1 피연산자, 2 피연산자, + 연산자
			- 
	- ALU 내보내는 정보 존재
	- 요약 :
		- `플래그 값! 이라는 게 존재 > 플래그 레지스터에 저장`
		- `다양한 플래그 값 존재 > 각각 저장됨`
		- 플래그 (flag)? =>
			- 중요한 정보, 핵심적인 역할?
				- <span style="background:#d3f8b6">플래그 레지스터 내부-이미지</span>
					- EX) 플래그 레지스터 내부-부호플러그에 1이 존재 > 해당 값은 음수!
				- 컴퓨터는 모든 데이터를 이진수 형태로 처리 함. 하지만 이진수 형태의 데이터만으로는 값의 부호를 직접적으로 알 수 X =  이진수 자체는 부호 정보를 내포하고 있지 X 
					- EX) 0101(2) 해당 이진수 값은 +5? -5?
				- 예를 들어, 연산 결과의 부호(양수 또는 음수), 제로(결과가 0인지 여부), 오버플로우(연산 결과가 처리 가능 범위를 초과했는지 여부) 등을 나타냅
			- ㅡㅡㅡㅡ본문내용
			- 연산결과에 대한 부가정보/연산결과의 특정 특성을 나타내는 비트로 구성
			- 컴퓨터가 다음 연산을 어떻게 처리할지 결정하는 데 **중요한 정보**
				- = 플래그 레지스터의 정보가 CPU 결과 값의 해석에 핵심적인 역할을 하며, 특히 부호 플래그는 결과가 양수인지 음수인지를 나타냅
		- ㅡㅡㅡㅡ본문내용
		- ALU는 연산의 결과를 내보낼 때, 그 결과에 대한 추가적인 정보를 제공하는 **플래그 값**을 플래그 레지스터에 전달
		- 플래그(값) 종류 다양
			- <span style="background:#d3f8b6">다양한 플래그 값 표-이미지</span>
				- 부호 플래그
				- 제로 플래그
				- 캐리 플래그
				- 오버플로우 플래그
				- 인터럽트 플래그
				- 슈퍼바이저 플래그


##### ㅡ [[자료구조-용어\|자료구조-용어]]
- 1. **컴퓨터 구조** - 큰 개념
    - 메모리 계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 자료구조(Data Structure) 용어
	- : 데이터를 메모리에 어떻게 효율적으로 저장하고 접근할지를 방법을 정의한 개념 > 따라서 프로그래밍 시 적절한 자료구조를 활용해 메모리 내 데이터를 최적화해서 저장-관리해야함
		- = 프로그래밍 시 데이터를 관리하는 방식을 결정
	- 주의
		- 메모리 내 특정 '영역'이 사전에 자료구조 유형별로 지정되어 있는게 X 
			- = 미리 메모리 내 스택영역, 큐 영역, 배열 영역 등등 존재하는 상태가 X 
		- 프로그램 내에서 데이터를 저장하기 위해 특정 자료구조를 사용할 결정을 하면, 그 자료구조는 실행 시 메모리 내에 생성되고, 필요에 따라 확장
			- = 자료구조를 사용하겠다는 코드가 작성되고 실행될 때, 그때 해당 자료구조에 대한 메모리 공간이 동적으로 할당되는 것
			- = 자료구조는 실행 시간에 메모리에 할당
		- 예시
			- 자바에서 `Stack<Integer> stack = new Stack<>();` 코드를 사용하여 스택을 생성하면, 이 코드가 실행될 때 메모리 내에서 스택을 위한 공간이 할당됨
			- 자바에서 `List<Integer> list = new ArrayList<>();`를 실행하면, 리스트를 위한 초기 메모리 할당이 이루어짐
			- 
	- 스택(Stack) 자료구조
		- <span style="background:#d3f8b6">메모리-스택자료구조-이미지</span>
		- 스택 주소 지정 방식=스택 자료구조 방식
		- 특징/의미
			- 후입선출(Last In, First Out; LIFO) 방식으로 데이터를 관리 = 이는 마지막에 들어온 데이터가 가장 먼저 나가는 방식
			- '스택'은 데이터를 저장하는 추상적인 개념이자 방법론/규칙이며, 이 개념은 실제 물리적 메모리 내에 구현됨. 
				- = 실제 메모리 내에는 이 규칙에 따라 데이터가 저장되고 관리되는 구체적인 영역이 존재
				- = 스택은 메모리 내에서 연속적인 공간을 차지
		- 스택 자료구조는 스택 포인터 (레지스터 )(Stack Pointer) 필요
			- <span style="background:#d3f8b6">스택포인터-동작원리-이미지</span>
		- 상황예시
			- 함수 호출, 괄호 매칭 등 다양한 프로그래밍 상황에서 활용
				- 이는 스택의 최상단을 가리키는 레지스터로, 현재 스택의 꼭대기를 나타냅. 즉, 스택에서 가장 최근에 저장된 데이터의 메모리 주소를 가리킵
				- 상황예시
					- 어떤 함수가 호출되면, 해당 함수의 실행에 필요한 매개변수, 반환 주소, 지역 변수 등이 스택에 저장
						- 1. 함수의 매개변수 저장
							- 함수를 호출할 때 전달되는 매개변수 값이 스택 메모리에 저장
						- 2. 반환 주소 저장
							- : 현재 함수가 끝나고 제어가 반환될 위치, 즉 호출한 함수로 돌아가기 위한 주소가 스택에 저장
						- 3. 지역 변수
							- : 함수 내에서 선언된 지역 변수들이 스택 메모리에 할당
					- 이 모든 정보들은 함수가 호출될 때 스택의 상단에 순차적으로 쌓이며, 함수가 종료될 때 이들은 스택에서 제거되어 메모리가 반환
					- 이때 스택 포인터는 스택의 최상단을 가리키게 되며, 데이터가 스택에 추가될 때마다 위로 이동하고, 데이터가 제거될 때마다 아래로 이동합
					- 
	- 큐(Queue) 자료구조 
		- 선입선출(First In, First Out; FIFO) 방식으로 데이터를 관리 = 첫 번째로 들어온 데이터가 가장 먼저 나가는 방식
		- 버퍼, 대기열 관리 등에 사용
	- 배열(Array)
	- 리스트(List)
	- 해시테이블(Hash Table)

##### ㅡ [[입출력방식-직접메모리접근-DMA컨트롤러\|입출력방식-직접메모리접근-DMA컨트롤러]]
- 1. **컴퓨터 구조** - 큰 개념
    - 입력/출력 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==**3. 직접 메모리 접근(DMA: Direct Memory Access) 입출력 방식**== 
	- <span style="background:#d3f8b6">기존방식-DMA없는경우-이미지</span>
		- **1번 방식**과 **2번 방식**에서는 모두 `입출력장치`와 `메모리` 간 데이터 이동 `CPU`가 주도함 + 이동하는 데이터 역시 `CPU`를 거침
		- 이미지 이해 =>
			- 필요한 데이터를 RAM-메인-메모리 저장하는 상황
			- 복기 : `CPU가 HDD 장치 컨트롤러-레지스터에 있는 값을 확인하고 > CPU레지스터에 값이 저장되고 > 메모리에 저장`
			- CPU는 처리해야 하는 연산이 많다.
				- = 대용량 데이터를 처리하는 상황에선 기존 방식은 부담이 크다
				- = 입출력장치를 위한 신호-연산처리도 처리해야 하니 부담됨
				- 
	- <span style="background:#d3f8b6">직접 메모리 접근-DMA방식-이미지</span>
	- 이미지 이해 =>
		- CPU는 DMA 컨트롤러에 입출력 작업을 명령
			- EX) `너가 나대신 ~ 처리해`
		- DMA 컨트롤러는 CPU 대신 `장치 컨트롤러`와 상호작용하며 입출력작업 수행
		- 입출력작업이 끝나면 `DMA 컨트롤러`는 인터럽트 신호를 통해 `CPU`에게 작업이 끝났음을 알림
		- 결국 CPU는 입출력 작업의 시작과 끝만 관여하게 됨
	- 대용량 데이터를 효율적으로 처리해야 하는 경우, 예를 들어 디스크 드라이브에서 파일을 읽거나 쓸 때 주로 사용
	- DMA 컨트롤러 존재 > 이 하드웨어 요소 덕분에 CPU를 거치지 않고 입출력장치가 메모리에 직접 접근 가능
	- `DMA 컨트롤러`가 `CPU`의 개입 없이 직접 `메모리`와 `입출력 장치` 사이에서 데이터 전송을 처리 > 이는 대량의 데이터를 효율적으로 처리할 수 있도록 하여 CPU의 부담을 크게 줄입
	- 
	- <span style="background:#d3f8b6">DMA방식-시스템버스-이용과정-사이클 스틸링-이미지</span>
	- "**사이클 스틸링**"이라는 개념 존재
	- 사이클 스틸링? =>
		- DMA 컨트롤러가 메모리 접근을 위해 일시적으로 CPU의 메모리 접근을 중단시키는 것을 의미
		- = 사이클 스틸링은 CPU와 DMA 컨트롤러가 메모리 대역폭을 공유할 때 발생하며, DMA 컨트롤러가 메모리 사이클을 '훔친다'고 해서 이런 표현을 사용
	- 이미지 이해 =>
		- DMA 과정에서 상호작용 위해 `시스템 버스`를 이용
		- `시스템버스`는 공용 자원이기에 동시 사용 불가능
			- = 즉, CPU가 `시스템버스`를 사용할 땐 `DMA 컨트롤러`는 `시스템 버스`를 사용할 수 X 
			- = `DMA 컨트롤러`가 `시스템버스`를 사용할 땐 `CPU`는 `시스템 버스`를 사용할 수 X 
		- 따라서 `DMA 컨트롤러`는 `CPU`가 `시스템버스`를 이용하지 않을 때마다 허락을 구하고 조금씩 `버스`를 이용함
		- 
		- <span style="background:#d3f8b6"> DMA방식-실제구조-시스템버스-입출력버스-이미지</span>
		- 이미지 이해 =>
			- **시스템 버스**는 공용 자원으로서 동시에 여러 컴포넌트에 의한 사용이 제한됩 
				- 기존 설명 이미지에서는 `장치 컨트롤러`가 `시스템 버스`에 직접 연결된 이미지들임
				- = 따라서 각각 `장치 컨트롤러`가 모두` 시스템 버스`에 연결되어 있는 구조는 좋지 않음
				- 이러한 구조로 되어 있어야 `입출력 버스`를 통해 `시스템 버스`의 이용 빈도를 낮춤 > `시스템 버스`는 공용 자원이라 빈도를 줄여야 `CPU`와 상호작용 속도 상승
			- 이로 인해 CPU, 메모리, 그리고 DMA 컨트롤러가 시스템 버스를 통해 연결되어 데이터를 전송
			- 장치 컨트롤러들은 주로 **입출력 버스**에 연결되어 다른 유형의 데이터 흐름을 관리하며, 이는 입출력 작업에 최적화되어 있습


##### ㅡ [[프로그램입출력방식\|프로그램입출력방식]]
- 1. **컴퓨터 구조** - 큰 개념
    - 입력/출력 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==1. 프로그램 입출력 방식(Programmed I/O)==
	- 1. **일반적인 프로그램 입출력** = 전통적인 방식
		- <span style="background:#d3f8b6">프로그램-입출력과정-방식-이미지</span>
			- 이미지 상황예시 =>
			- 메모리에 저장된 정보를 하드 디스크에 백업 상황 = HDD에 새로운 정보를 쓴다 = 저장한다
			- 1. 과정
				- `CPU`는 데이터를 저장하기 위해 `HDD 컨트롤러`에 제어신호를 보냄
				- 해당 제어신호는 `제어 레지스터`에 저장됨
			- 2. 과정
				- `HDD 컨트롤러`가 HDD 상태를 확인함 > 문제가 없다면 `상태 레지스터`에 준비완료 값 생성
			- 3. 과정
				- CPU는 HDD 컨트롤러-상태 레지스터에 어떤 값이 있는지 확인 진행
				- 준비완료! 값을 확인 후 실제 저장할 데이터를 HDD 컨트롤러에 보냄 = 컨트롤로-데이터 레지스터에 저장됨
				- 
		- CPU가 모든 입출력 작업을 직접 처리 > 따라서 CPU 자원을 많이 사용하며, CPU가 다른 중요한 작업을 수행하는 데 방해가 될 수 있습
			- = 데이터를 읽거나 쓸 때마다 CPU가 개입하여 데이터를 입출력 장치로부터 직접 전송
			- =  CPU가 입출력 장치의 데이터 전송 준비 상태 `장치 컨트롤러 레지스터`를 **직접 확인**하고 **관리(값을 읽고 씀)** 으로써 동작하는 방식
			- = 이 방식에서 CPU는 주기적으로 입출력 장치의 상태를 폴링하여 데이터가 전송 준비가 되었는지 확인하고, 준비가 되면 데이터를 읽거나 씁
			- 
		- 파일 데이터를 프로세스 주소 공간에 매핑하지 않는 전통적인 입출력 방식에서는 **시스템 콜**을 사용하여 파일 데이터를 읽고 씁
			- + 시스템 콜(system call)? => 기존노트 확인
			- 상황예시
				- 웹 서버가 사용자의 요청에 따라 이미지 파일을 전송-응답해야 한다고 가정
				- **파일 열기:** 
					- 웹 서버는 `open` 시스템 콜을 사용하여 디스크 상의 이미지 파일을 엽
				- **파일 읽기:** 
					- 웹 서버는 `read` 시스템 콜을 사용하여 이미지 파일의 내용을 메모리(버퍼)로 읽어 들입
					- 이 때, 운영 체제는 디스크에서 데이터를 읽는다 =  프로세스의 사용자 공간으로 데이터를 복사
				- **데이터 전송:** 
					- 읽혀진 이미지 데이터가 네트워크를 통해 사용자에게 전송
				- **파일 닫기:** 
					- 모든 작업이 완료되면 `close` 시스템 콜을 사용하여 파일을 닫음
		- 사실 이러한 과정에서 데이터는 디스크와 메모리 사이를 반복해서 복사! 됨
		- ex)
			- 먼저, 디스크에서 운영 체제의 커널 공간으로 데이터가 복사되고, 그 다음에 프로세스의 사용자 공간으로 데이터가 다시 복사됩
			- 따라서 전통적인 방법은 메모리 맵 입출력에 비해 상대적으로 더 많은 시간과 시스템 자원을 소모하게 됩
			- 
			- 
	- 메모리 맵 입출력(Memory-mapped I/O)과 고립형 입출력(Isolated I/O) 존재 =>
	- 각 방식의 사용은 특정 하드웨어 설계와 운영 체제의 구조에 따라 다르게 선택됩
	- 이 두 방식의 주된 차이는 데이터와 제어 신호를 CPU와 입출력 장치 사이에서 어떻게 **주소 지정-관리**하는지에 있음
	- 현대 컴퓨터 시스템에서 **메모리 맵 입출력 방식이 더 널리 사용**
		- 왜?
		- 프로그래밍의 편의성과 고성능 처리 능력 때문
	- 2. **메모리 맵 입출력 (Memory-mapped I/O)**
		- <span style="background:#d3f8b6">메모리 맵 입출력방식-주소공간-이미지</span>
			- 이미지 이해 =>
			- 516번지 : `프린터 컨트롤러` 데이터 레지스터 주소
			- 517번지 : `프린트 컨트롤러` 상태 레지스터 주소
			- 518번지 : `하드 디스크 컨트롤러` 데이터 레지스터 주소
			- 519번지 : `하드 디스크 컨트롤러` 상태 레지스터 주소
			- 
			- 저러한 방식으로 주소가 존재한다면 데이터를 입출력하기 위해 프린터의 상태값에 접근하기 위해서 `517번지 값을 읽어라`! 라는 명령을 실행하면 됨
				- = 즉, `메모리 접근 명령어` = `입출력장치 접근 명령어`
				- = 즉, `고립형 입출력` 방식과 달리 별도의 입출력 명령어 필요 X
			- 단점
				- 메모리 주소 공간이 축소됨
			- 장점
				- 실제 파일 입출력 연산보다 더 효율적인 데이터 처리가 가능해지며, 복잡한 입출력 프로세스를 단순화
				- 이 방식을 사용하면 CPU는 메모리를 읽거나 쓰는 것과 같은 일반적인 메모리 접근 명령을 통해 입출력 장치를 제어할 수 있습 | [[높은수준작업-낮은수준작업-표현의미\|높은수준작업-낮은수준작업-표현의미]]
				- 입출력 데이터에 빠르게 접근할 수 있는 이점 > 그래픽 처리 장치(GPU)와 같이 대용량의 데이터를 빈번하게 처리하는 장치에서 주로 사용됩
		- 특징
			- 매핑(mapping)? 일반적인 메모리 접근?
				- 흔히 사용하는 딕셔너리나 맵 자료구조에서 키와 값을 연결하는 것과 유사한 개념을 의미
				- 따라서 파일이나 장치의 데이터를 프로세스의 주소 공간 내에 연결하는 것을 말합
				- 즉 매핑을 하면 특정 파일의 내용이나 장치의 데이터를 메모리 주소와 직접 연결된 것처럼 동작 = 프로그램이 마치 자신의 메모리 공간 안에 있는 데이터처럼 접근하고 조작할 수 있게 합
			- ㅡㅡㅡㅡ본문내용
			- 일반적인 하나의 메모리 주소 공간에 프로그램이 올라갈 주소공간(메모리를 위한 주소 공간 표현)과 입출력장치에 대한 주소공간이 함께 각각 존재
				- = 파일-데이터이나 입출력 장치의 데이터를 프로세스의 주소 공간(일반 메모리 주소 공간)에 **매핑**하여, 프로그램이 해당 데이터에 대한 읽기 및 쓰기 작업을 **일반 메모리 접근**처럼 수행할 수 있게 하는 기법
				-  = 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
				- 
	- **3. 고립형 입출력 (Isolated I/O)**
		- <span style="background:#d3f8b6">고립형 입출력-주소공간-이미지</span>
		- 특징
			- 별도의 명령어?
				- 입출력 읽기/쓰기 선을 활성화 시키는 `입출력 전용 명령어` 존재
				- 메모리 맵 입출력 방식과 같은 CPU가 직접 입출력 장치를 제어하기 위해 사용하는 기계어 수준의 명령어
				- 'IN' (입력)과 'OUT' (출력) 같은 기계어 명령어
			- 전용 주소 공간?
				- 전용 주소 공간이 존재 > 따라서 별도의 명령어 존재 > 즉 운영 체제의 커널 수준 서비스와는 다르게 작동하며, 하드웨어 레벨에서 직접적인 데이터 전송을 가능하게 합
				- 이 방식은 메모리 주소 공간을 절약할 수 있고, 메모리 맵 입출력 방식과 비교하여, 특정 시나리오에서 더 효율적일 수 있
			- ㅡㅡㅡㅡ본문내용
			- 입출력 장치를 위한 **전용 주소 공간**을 사용 
				- > 따라서 **별도의 명령어** 필요
				- > 따라서 읽기/쓰기 신호가 이동되는 `제어버스` 각각 존재 (`메모리 읽기/쓰기` 제어버스, `입출력 읽기/쓰기` 제어버스)
		- 단점
			- 하지만 프로그래밍이 조금 더 복잡해질 수 있으며, 메모리 맵 입출력에 비해 유연성이 떨어짐 = 입출력 전용 명령어 존재


##### ㅡ [[입출력방식-인터럽트기반-과정이해\|입출력방식-인터럽트기반-과정이해]]
- 1. **컴퓨터 구조** - 큰 개념
    - 입력/출력 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==**2. 인터럽트 기반 입출력(Interrupt-driven I/O)**== 
	- <span style="background:#d3f8b6">인터럽트기반 입출력 과정-이미지</span>
	- 
	- 대부분의 현대 컴퓨터 시스템에서 가장 흔하게 사용되는 방식
	- 보통 입출력장치는 동시다발적으로 많이 사용됨 = 입출력 요청 신호가 동시다발적으로 CPU 보내짐 = `인터럽트 요청 신호`
		- + 연관노트 확인 : [[CPU-레지스터-작동과정예시\|CPU-레지스터-작동과정예시]]
	- **입출력 장치가** 데이터 전송 준비가 완료되면 `CPU`에 인터럽트 신호를 보냄
	- 이 신호를 통해 CPU는 (다른 작업을 수행하다)필요할 때만 입출력 작업을 처리
		- = (프로그램 일출력방식 1번과 달리 )CPU는 입출력 장치의 준비 상태를 지속적으로 확인할 필요가 없으므로, CPU의 부하가 줄어들고, 다른 작업에 더 많은 자원을 할당할 수 있습
		- 
	- Q. 동시에 신호를 받으면 CPU는 어떻게 처리하고 있을까?
		- <span style="background:#d3f8b6">CPU-인터럽트-요청신호-처리과정-이미지</span>
		- 1. 이미지 설명 =>
			- 인터럽트가 발생한 순서대로 처리하는 경우임 = 순차적 처리 
			- 기존 코드 해석 > A 코드 해석 > 기존 코드 해석 > B 코드 해석 > 기존 코드 해석 
			- 현실적으로 이미지처럼 인터럽트를 순차적으로 처리하지 X
			- 왜? : 인터럽트 중에서도 더 빨리 처리해야 하는 우선순위가 높은 인터럽트 요청 신호가 존재함
		- 2. 이미지 설명 =>
			- PIC(Programmable Interrupt Controller)?
				- 참고자료 : https://m.blog.naver.com/pamajo2/221539015211
				- <span style="background:#d3f8b6">PIC-처리과정이해-이미지</span>
					- 일반적인 데이터 흐름 
						- 상황예시 =>
						- 컴퓨터 시스템에 키보드, 마우스, 프린터, 그리고 네트워크 카드와 같은 여러 입출력 장치가 연결되어 있다고 가정
						- 사용자가 키보드를 사용하여 데이터를 입력하는 동시에, 네트워크 카드는 네트워크 패킷을 받고, 프린터는 인쇄 작업을 완료하여 상태를 업데이트할 준비가 되어 있는 상황
						- 
						- **입출력 장치**: 이 장치들은 사용자의 입력이나 시스템 내부 프로세스로부터 작업을 수행하고, 해당 작업이 완료되거나 특정 이벤트가 발생했을 때 인터럽트를 발생시킵
						- **PIC 하드웨어**: PIC는 다수의 인터럽트를 받아들이고, 이들 인터럽트의 우선순위를 판단하여 중요한 순서대로 CPU에 전달 > 이 과정은 시스템의 효율성을 높이고 CPU가 더 중요한 작업부터 처리할 수 있게 도와줍
						- **CPU 하드웨어**: CPU는 PIC로부터 인터럽트를 받고 해당 인터럽트에 대응하는 처리를 수행
				- PIC(Programmable Interrupt Controller)는 일반적으로 각 장치 컨트롤러에 하나씩 있는 것이 아니라, 시스템 레벨에서 중앙집중식으로 관리되는 컴포넌트임
					- = PIC는 전체 시스템에서 단 하나 또는 소수일 수 있으며, 모든 인터럽트를 중앙에서 처리하여 CPU에 효율적으로 인터럽트를 전달
				- 요약 :  `입출력 장치에서 발생하는 인터럽트가 PIC(Programmable Interrupt Controller)를 거쳐 CPU로 전달되는 것 `
					- 꼭지점 마다 각각의 `장치 컨트롤러`들이 연결된 상태 생각 > 중앙집중식으로 관리 가능
					- 윈도우 운영체제 - `시스템 정보` 에서 동시다발적으로 발생하는 여러 하드웨어 인터럽트 우선순위 확인 가능
					- 
				- 요약 : `인터럽트 신호는 입출력 컨트롤러로부터 바로 CPU에 전달되며, CPU가 신호를 받고 처리하기 시작할 때 운영체제가 관여합`
					- 1. **인터럽트 발생**:
						- 사용자가 마우스를 클릭하거나 움직일 때, 마우스 하드웨어는 해당 동작에 대한 신호를 생성 > 이 신호는 연결된 포트(USB 등)를 통해 컴퓨터로 전송
					    - 입출력 장치(예: 마우스)의 컨트롤러는 특정 이벤트(예: 버튼 클릭, 마우스 이동)가 발생하면 인터럽트 신호를 생성
					- 2. **CPU로의 인터럽트 전송**:
					    - 생성된 인터럽트 신호는 직접 CPU로 전송됨
					    - 주의 : 이 과정에서 중간에 운영체제가 신호를 받지 않음. 운영체제는 CPU가 인터럽트를 받고 처리를 시작한 후에 개입합
					- 3. **운영체제의 개입 (드라이버 개입)**:
					    - CPU는 인터럽트를 받은 후, 현재 수행 중인 작업을 일시 중지하고 인터럽트 처리 루틴을 실행합
					    - 이 루틴은 일반적으로 운영체제에 의해 제공되며, 운영체제는 이 시점에서 드라이버나 다른 시스템 리소스를 호출하여 인터럽트를 처리
					- 4. **인터럽트 서비스 루틴(ISR)**: 
					    - 운영체제는 인터럽트를 처리하기 위해 특정 인터럽트 서비스 루틴(ISR)을 실행
					    - 이 ISR은 장치 드라이버에 의해 정의되고 관리됩
			- ㅡㅡㅡㅡ본문내용
			- 우선순위를 반영한 이미지
			- 기존 코드 해석 > A 코드 해석 > B 코드 해석 > A 코드 해석 > 기존 코드 해석
			- 즉 A 인터럽트 요청 신호를 처리하더라도 B가 우선순위가 높으면 B를 해석 시작
			- 이러한 방식인 경우 실제 하드웨어 요소-**PIC(Programmable Interrupt Controller)** 사용됨



##### ㅡ [[장치컨트롤러-역할-기능-내부구조\|장치컨트롤러-역할-기능-내부구조]]
- 1. **컴퓨터 구조** - 큰 개념
    - 입력/출력 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==장치 컨트롤러 = 입출력 제어기(I/O controller) = 입출력 모듈(I/O modure)==
	- <span style="background:#d3f8b6">장치컨트롤러-이미지</span>
		- 실제 물리적으로 존재하는 부품/하드웨어 요소
	- "장치 컨트롤러"라는 용어에서 "장치" 부분은 해당 컨트롤러가 연결되고 제어하는 **특정 하드웨어를 지칭**
		- + 특정 하드웨어를 지칭? = 다양한 장치 컨트롤러 존재 의미
		- **디스크 컨트롤러:** 
			- 하드 드라이브, SSD와 같은 저장 장치를 관리하며 데이터 읽기/쓰기 작업을 조정
		- **키보드 컨트롤러:** 
			- 키보드 입력을 처리하고, 해당 데이터를 시스템으로 전송
		- **비디오 컨트롤러:** 
			- 디스플레이 장치에 데이터를 전송하며, 화면에 출력되는 그래픽을 관리
		- **네트워크 인터페이스 컨트롤러(NIC):** 
			- 네트워크 통신을 담당하며, 데이터 패킷을 전송 및 수신
	- 각 입출력 장치의 종류와 용도에 따라 연결된 장치 컨트롤러의 이름과 기능이 다릅
	- 왜? 복기 :
		- `다양한 입출력 장치 존재` > 각각 `컨트롤러` 필요 
		- `장치가 다양하면 > 각 장치마다 CPU와 상호작용 속도, 데이터 전송 형식-방식, 요구사항 및 통신 프로토콜 다름 > 규격화 하기 어려움`
	- **장치 컨트롤러 역할/기능** =>
		- 버퍼링?
			- [[장치컨트롤러-역할-기능-내부구조#- 입출력장치-버퍼링과정-이미지\|장치컨트롤러-역할-기능-내부구조#- 입출력장치-버퍼링과정-이미지]]
			- 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 **`버퍼`** 라는 임시 저장 공간에 저장해 전송률을 비슷하게 맞추는 방법.
			- 버퍼? =>
				- `장치 컨트롤러` 내부에 존재.  = 실제로 존재하는 물리적인 메모리 공간
				- 주의
					- `버퍼`와 `레지스터`는 장치 컨트롤러 내에서 각각 독립적으로 존재
					- = 각각이 고유한 기능과 목적을 가지고 있음
				- 상황예시
					- 네트워크 카드의 `버퍼`는 네트워크로부터 수신된 데이터 패킷을 임시 저장하거나, 전송할 데이터 패킷을 임시로 보관 > 입출력 장치와 CPU 간의 속도 차이를 완화하고 시스템의 전체적인 효율성을 향상
		- ㅡㅡㅡㅡ본문내용
		- 해당 입출력 장치의 데이터 전송, CPU와 장치 간의 속도 차이를 조정하여 시스템의 전반적인 효율성과 안정성을 증진 > 따라서 모든 입출력장치에는 결국 하나 이상의 장치 컨트롤러와 연결되어 있음
			- = 각 컨트롤러는 해당 장치와 시스템 간의 인터페이스 역할을 수행
			- = CPU와 입출력장치 간 통신중개
			- = 오류 검출
			- = 데이터 **버퍼링** 역할 수행
	- **장치 컨트롤러 구조** =>
		- 복기 : 
			- `시스템 버스-통로` 존재
			- `레지스터는 어떤 데이터를 저장하는지에 따라서 명칭 다름`
		- <span style="background:#d3f8b6">장치 컨트롤러-구조-이미지</span>
		- 컨트롤러는 CPU 도달하기 위해 시스템 버스에 연결됨


##### ㅡ [[입출력장치-CPU-입출력방식-데이터통신과정\|입출력장치-CPU-입출력방식-데이터통신과정]]
- 1. **컴퓨터 구조** - 큰 개념
    - 입력/출력 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==장치 컨트롤러 = 입출력 제어기(I/O controller) = 입출력 모듈(I/O modure)==
	- **입출력장치와 CPU 사이의 데이터 통신 과정** =>
		- 입출력장치와 CPU사이 **주고 받는 데이터는 3가지 존재**
			- <span style="background:#d3f8b6">장치 컨트롤러-구조-이미지</span>
			- 1. 데이터 > `데이터 레지스터` 존재
				- CPU와 입출력장치 사이에 주고받을 데이터가 담김 = `버퍼`에 전송할 데이터
			- 2. 상태 > `상태 레지스터` 존재
				- **상태 정보** 저장
					- + 상태정보?
					- 입출력장치가 입출력 작업을 할 준비가 되었는지
					- 입출력장치 작업이 완료가 되었는지
					- 입출력장치에 오류가 없는지 등등의 정보
					- 이해예시
						- CPU가 장치컨트롤러와 상호작용을 통해
						- 준비가 되었는지 확인
						- 준비가 되면 시작
						- 시작이 되면 완료 되었는지 확인
						- 그 과정에서 오류가 있었는지 확인 진행
			- 3. 제어 > `제어 레지스터` 존재
				- 입출력장치가 수행할 내용에 대한 제어 정보 저장
				- 
		- 데이터 통신과정 요약 : [[프로그램입출력방식#- 프로그램-입출력과정-방식-이미지\|프로그램입출력방식#- 프로그램-입출력과정-방식-이미지]]
			- `입출력 장치`에서 시작해 `장치 컨트롤러`를 거쳐 `메모리`로 이동하고, 그 후 `CPU`가 데이터에 접근합 
			- 이 데이터 흐름은 반대 방향으로도 동일하게 작동하여 `CPU`에서 처리한 데이터가 `입출력 장치`로 전달
			- 좀 더 구체적 표현 시 
				- `입출력 장치`에서 `장치 컨트롤러`의 `레지스터`를 통해 상태가 조절되고, `장치 컨트롤러` 내 `버퍼`를 거쳐 임시로 데이터가 저장된 후, 이 데이터가 `메모리`로 이동하고 마지막으로 `CPU`가 이를 처리
				- 1. **입출력 장치**
					- 사용자 입력을 받거나 데이터를 출력하는 하드웨어
				- 2. **장치 컨트롤러**
					- 입출력 장치와 CPU 사이의 데이터 통신을 관리
					- 다양한 입출력 장치의 속도 차이와 데이터 형식을 조정
				3. **장치 컨트롤러-레지스터**
					- 장치의 현재 **상태정보**나 CPU에 의해 설정된 **작업 명령/제어정보**을 저장
					- 장치 상태정보-제어정보?
						- 레지스터는 CPU에 전송할 데이터 자체를 '저장'한다기보다는, 데이터 전송 과정이나 장치의 상태를 제어하는 필요한 데이터를 저장.
				- 4. **장치 컨트롤러-버퍼**
					- 입출력 장치와 CPU 간의 데이터 전송 속도 차이를 조절하기 위해 데이터를 일시적으로 저장
				- 5. **CPU**
					- 최종적으로 데이터를 처리하고, 계산하며, 결과를 출력
	- 입출력장치 <> CPU 사이 입출력방식 3가지 =>
		- <span style="background:#d3f8b6">입출력방식-구조-이미지</span>
		- "입출력 방식" = "데이터를 주고받는 방식"
			- = 1. 데이터 교환 방식
			- = 2. 데이터 전송 방식
			- = 3. 데이터 통신 방식
		- 이 표현은 입출력 장치와 컴퓨터 시스템/CPU 간에 데이터를 어떻게 교환하는지에 대한 메커니즘을 설명
		- 중요 : 
			- 입출력 방식은 하나의 컴퓨터 시스템에서 여러 가지가 정의되어 있으며, 상황에 따라 다양한 입출력 방식 중에서 가장 적합한 방식이 선택되어 사용됩
			- = 입출력 방식은 시스템의 요구사항, 특정 하드웨어의 특성, 그리고 소프트웨어의 최적화 상태에 따라 다양
		- 
		- ==**3. 직접 메모리 접근(DMA: Direct Memory Access) 입출력 방식**== | [[입출력방식-직접메모리접근-DMA컨트롤러\|입출력방식-직접메모리접근-DMA컨트롤러]]
		- 
		- 프로그램 입출력 방식과 인터럽트 기반 입출력 방식의 주된 차이점 : 입출력 장치의 데이터 전송 준비 상태 관리하는 주체
			- ==**1. 프로그램 입출력 방식(Programmed I/O)**== | [[프로그램입출력방식\|프로그램입출력방식]]
				- 입출력 명령어를 사용해 `입출력장치-컨트롤러`를 제어하는 방식
				- 간단한 장치 또는 데이터 전송량이 많지 않은 경우에 사용됩
				- EX)
					- 키보드나 마우스 같은 장치에서는 여전히 프로그램 입출력 방식이 사용
				- 프로그램 입출력 방식(Programmed I/O)을 좀 더 세분화하면, 일반적으로 다음 **세 가지 방식**으로 나눌 수 
				- 
			- ==**2. 인터럽트 기반 입출력(Interrupt-driven I/O)**== | [[입출력방식-인터럽트기반-과정이해\|입출력방식-인터럽트기반-과정이해]]



##### ㅡ [[장치드라이버-기능-과정이해\|장치드라이버-기능-과정이해]]
- 1. **컴퓨터 구조** - 큰 개념
    - 입력/출력 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==장치 드라이버==
	- 연관노트 : [[프로그램입출력방식#- 고립형 입출력-주소공간-이미지\|프로그램입출력방식#- 고립형 입출력-주소공간-이미지]]
		- 복기 : `프로그램은 메모리 위에 존재. 공간 차지`
		- 입출력 장치 주소 공간 존재
			- = 메모리 내에서 하드웨어 장치를 가리키는 위치를 의미 
		- 입출력 장치에 대한 주소 공간 관리 역시 커널 영역 존재
		- 장치 드라이버가 입출력 장치의 주소 공간에 접근하여 장치와 통신
		- 
		- 상황예시
			- 컴퓨터에서 키보드 입력을 받는 경우=>
			- 사용자가 키보드의 키를 누르면, 키보드 장치는 해당 신호를 하드웨어 인터럽트로 컴퓨터에 전달
			- 컴퓨터에 전달한다는 것은 곧 인터럽트-신호가 CPU에 의해 처리되며, 처리 과정에서 **커널 내의 키보드 드라이버**가 활성화
			- 키보드 드라이버는 해당 키 입력에 대한 정보를 읽고, 이를 시스템 내에서 적절한 방식으로 처리하여, 최종적으로 사용자 프로그램에게 이 데이터를 전달
			- 이 모든 과정에서 키보드와 같은 입출력 장치에 대한 주소 공간은 **커널 영역** 내에서 관리
		- 내부과정
			- 사용자 프로그램이 입출력 장치와 상호작용하려면, 직접적으로 하드웨어를 조작할 수 없기 때문에 시스템 콜을 통해 운영체제에 요청을 보냅
			- 운영체제는 이 요청을 받아 해당 장치 드라이버에 명령을 전달하고, 드라이버는 그 **명령**을 하드웨어 장치에 전달하여 요청된 작업을 수행
			- 명령? =>
				- 장치 드라이버는 이 주소 공간을 활용하여 하드웨어 장치와 통신
				- 드라이버는 해당 장치에 대한 명령어를 주소 공간에 쓰고, 장치로부터의 데이터를 해당 주소 공간 읽고 쓴다
				- 이 과정을 통해 드라이버는 장치의 작동을 제어하고, 필요한 데이터 교환을 수행
				- 
	- 장치 컨트롤러가 `입출력장치`를 연결하기 위한 하드웨어적인/물리적인 통로라면, `장치 드라이버`는 입출력장치를 연결하기 위한 **소프트웨어적인 통로**
	- 소프트웨어적인 통로? =>
		- **운영체제**가 연결된 `장치 드라이버`를 인식하고 실행할 수 있다면 그때 컴퓨터 내부와 입출력장치 간 정보를 주고 받을 수 있음
		- 드라이버는 `컨트롤러` 처럼 특정 하드웨어의 세부적인 통신 프로토콜과 기능을 알고 있어야 하며, 이를 통해 해당 장치의 모든 기능을 **운영 체제**가 활용할 수 있도록 지원
		- 운영체제 내부에 장치 **드라이버 프로그램** 존재 구조
			- + 프로그램?
				- > 따라서 운영체제에서 확인 가능 > 장치 관리자 프로그램!
			- 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램 > 따라서 장치 드라이버가 설치되어 있지 않다면 해당 입출력장치는 사용 X
				- = 각각의 하드웨어 장치를 운영 체제에서 인식하고 효과적으로 사용할 수 있도록 하는 소프트웨어인 장치 드라이버도 각각 존재
			- EX) 프린터의 드라이버 / 그래픽 드라이버
				- 키보드 장치 드라이버
					- : 사용자가 키보드의 키를 누를 때, 드라이버는 해당 키 입력을 운영 체제가 이해할 수 있는 신호로 변환하여 처리
				- 마우스 장치 드라이버
					- 전달과정-상황예시=>
					- 1. **입력 감지:** 
						- 마우스 장치 드라이버는 마우스의 움직임이나 클릭 같은 물리적인 입력을 감지
					- 2. **데이터 변환:** 
						- 드라이버는 감지된 입력을 운영 체제가 이해할 수 있는 데이터 형태로 변환
						- 예를 들어, 마우스의 움직임을 좌표 변경으로, 클릭을 특정 이벤트 신호로 변환할
					- 3. **운영 체제로의 데이터 전달:** 
						- 변환된 데이터는 운영 체제에 전달
						- 운영 체제는 이 데이터를 받아 적절한 처리를 수행하며, 필요한 경우 해당 정보를 관련된 **다른** 응용 프로그램이나 시스템 서비스로 **전달**
							- + 다른 쪽으로 전달?
								- CPU 전달
									- 운영 체제 내에서 처리된 데이터는 필요에 따라 CPU로 전달될 수 있습
									- 예를 들어, 사용자가 그래픽 사용자 인터페이스의 특정 부분을 클릭했다면, 이에 대한 정보가 CPU로 전송되어 해당 이벤트에 맞는 프로그램 또는 명령이 실행
								- 다른 프로그램에 전달
									- 만약 마우스 클릭이 특정 응용 프로그램의 버튼에 해당한다면, 운영체제는 해당 마우스 클릭 이벤트를 그 응용 프로그램에 전달



-----
# ㅡ 2. **운영 체제** - 큰 개념


##### ㅡ [[운영체제-메모리-프로세스-파일관리-이미지\|운영체제-메모리-프로세스-파일관리-이미지]]
- 2. **운영 체제** - 큰 개념
    - 운영 체제의 역할과 기능
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:#d3f8b6">운영체제-이미지</span>
- <span style="background:#d3f8b6">OS-프로세스관리-이미지</span>
- OS-파일시스템-이미지
- <span style="background:#d3f8b6">OS-메모리관리-메모리내부구조-메모리공간-이미지</span>
	- 연관노트 : [[커널영역-사용자영역\|커널영역-사용자영역]]


##### ㅡ [[운영체제-파일데이터-저장-할당방법\|운영체제-파일데이터-저장-할당방법]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
-  ==파일 할당 방법==
- 운영체제는 파일/디렉토리를 **블록 단위**로 읽고 쓴다 = 블록 단위로 관리! 
	- 연관노트 : [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
	- 주의 : 
		- 플래시 메모리와 운영체제가 데이터를 저장하는 단위에 차이 존재
		- 운영체제 : 대부분의 파일 시스템은 '**블록**' 단위로 데이터를 저장
		- 블록? =>
			- 운영체제의 블록은 일반적으로 하드 드라이브 또는 SSD 상의 연속된 데이터 덩어리로, 파일이나 데이터의 논리적 조각을 추상화한 것
			- ex) 파일 크기 작다 = 적은 수의 블록 차지하면서 저장
	- 상황예시
		- 파일 시스템에서 하나의 파일을 저장할 때, 운영체제는 파일의 크기에 따라 하나 이상의 블록을 할당
		- 파일이 블록 크기보다 작더라도 최소한 하나의 블록을 차지 > 디스크 공간의 일부가 낭비될 수 있음을 의미합(이를 '**슬랙 스페이스**'라고 합). 
		- 파일이 여러 블록에 걸쳐있을 경우, 각 블록의 위치는 파일 시스템의 **디렉토리 엔트리**에 저장되어 있어, 파일을 읽을 때 필요한 모든 블록을 찾을 수 있습
		- 
		- 슬랙 스페이스 <> 외부 단편화 의미 차이 =>
			- 두 용어는 저장 공간 관련 문제를 설명하지만, 발생 원인과 처리 방식이 다릅
			- 요약 : 슬랙 스페이스는 **단일 파일 내부의 낭비**를, 외부 단편화는 **전체 저장 공간의 비효율적 활용**을 각각 나타내는 용어
			- 
			- 1. 슬랙 스페이스(Slack Space)
				- 하나의 파일이 할당받은 블록 내에서 사용되지 않는 공간을 의미 = 내부적으로 발생하는 공간 낭비
				- 파일이 할당받은 블록의 크기와 실제 파일 크기 사이의 차이 때문에 발생
				- 상황예시
					- 하나 블록 = 4KB 가정
					- 7KB의 문서 파일을 저장하기 위해 파일 시스템이 8KB를 할당 > 이때 남는/사용하지 않는 1KB는 슬랙 스페이스
			
			- 2. 외부 단편화(External Fragmentation)
				- 파일 시스템 전체에서 작은 자유 공간 덩어리들이 흩어져 있어서, 큰 파일을 저장하기 위한 충분하고 연속된 공간을 확보하기 어려운 상황 = 외부적으로 발생하는 공간의 낭비
				- 상황예시
					- 여러 번의 파일 저장과 삭제 후, 디스크에 3KB, 2KB, 5KB 크기의 여러 자유 공간 조각이 생긴 상황 > 10KB 크기의 새 파일을 저장하려 하지만, 이 크기의 연속된 공간이 없어 저장할 수 없습
					- 
- 파일을 (보조기억장치)블록에 할당하는/저장하는 다양한 방법 존재 =>
	- 1. 연속 할당
		- <span style="background:#d3f8b6">블록저장-연속할당-이미지</span>
		- 가장 단순한 방법
		- 이름 그대로 보조기억장치 내 연속적인  블록에 파일 할당
		- 해당 방식으로, 연속된 파일에 접근하기 위해선 디렉토리 엔트리에는 파일이름 / 첫 번째 블록 주소 / 블록 단위 길이 3가지가 명시
		- 
		- 단점
			- <span style="background:#d3f8b6">블록저장-연속할당-단점-외부단편화-이미지</span>
			- 구현 자체는 단순하지만 **외부 단편화**를 야기할 수 있음
			- 똑같은 사이즈를 가진 파일이 생성되기 전까진 중간에 비어있는 공간이 생길 수 있음 > 이러한 단점을 극복한 방식이 바로 `불연속 할당 방식`
		- 
	- 2. 불연속 할당 (주된 방식)
		- 1. 연결 할당
			- <span style="background:#d3f8b6">불연속할당-연결할당-이미지</span>
			- 디렉토리 엔트리에 저장되는 값
				- 파일 이름 / 첫 번째 블록 주소 / 길이 OR 마지막 블록 주소
			- 각 블록의 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당/저장됨 > 따라서 파일이 여러 블록에 흩어져 저장되어도 상관 X 
			- 파일을 이루는 데이터 블록은 연결 리스트로 관리
			- 단점
				- 반드시 첫 번째 블록부터 하나씩 읽어들어야 함 = 파일 임의 위치에 접근하는 속도가 느리다.
				- 오류 발생 시 해당 블록 이후 블록 접근이 어려움
				- 이러한 단점을 보완한 방식 > `색인 할당`
			- 
		- 2. 색인 할당
			- <span style="background:#d3f8b6">불연속할당-색인할당-이미지</span>
			- 파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 모아 관리하는 방식 > 파일 내 임의 위치에 접근하기 용이해짐
				- =  색인 블록에는 파일 데이터가 저장되는게 아닌 파일 데이터를 가지고 있는 블록들의 주소가 담겨져 있는 느낌
			- 디렉토리 엔트리에 저장되는 값
				- 파일 이름 값 / 색인 블록 값 저장



##### ㅡ [[리눅스-윈도우-기본파일시스템\|리눅스-윈도우-기본파일시스템]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==리눅스-윈도우-기본파일시스템==
	- 리눅스 운영체제 파일 시스템 =>
		- 리눅스 운영체제는 유닉스를 기반으로 개발되었기 때문에 유닉스 파일 시스템의 개념을 많이 차용
			- =  리눅스 파일 시스템에서도 i-node(inode) 방식을 사용하여 파일과 디렉터리의 메타데이터를 저장
			- = 리눅스에서는 이 **i-node 구조**를 기반으로 여러 파일 시스템을 구현
			- 
			- i-node(inode) 방식? =>
				- I-node는 유닉스 및 유닉스 계열 시스템(리눅스 포함)에서 파일의 메타데이터를 저장하는 데이터 구조
				- 이 메타데이터에는 파일의 권한, 소유자 정보, 파일 크기, 생성 및 수정 날짜, 데이터가 저장된 블록의 위치 정보 등이 포함
				- 주의
					- I-node 자체는 파일의 실제 데이터를 저장하지 않고, 데이터가 저장된 위치를 가리키는 역할
			- 
		- 리눅스 운영체제 명령어
			- `ls -i` 명령어
				- 파일의 i-node 번호를 표시하여 해당 파일의 메타데이터가 저장된 i-node를 확인
			- `df -T` 명령어
				- 파일 시스템의 세부 정보 확인 가능 
				- 마운트된 파일 시스템의 종류와 사용 중인 파티션의 정보를 볼 수 있습
				- 
		- Ext4는 일반 데이터 저장용으로 사용
			- Ext2, Ext3, Ext4 등
			- 리눅스 배포판을 설치할 때 기본적으로 **Ext4 파일 시스템**을 사용하도록 설정되어 있음
		- FAT32는 다양한 운영체제 간의 호환성이 필요한 외장 하드 드라이브에 주로 사용
		- Btrfs는 스냅샷이나 데이터 복구 기능이 필요할 때 사용
		- XFS는 높은 성능과 대용량 파일 처리에 적합하여 대규모 데이터 저장소나 서버 환경에서 유리
						- 
	- 윈도우 운영체제 파일 시스템 =>
		- **NTFS**: 보안, 파일 압축, 대형 파일 및 볼륨 지원 등의 기능을 제공
			- 대부분의 윈도우 시스템은 **NTFS**로 설치됩
		- **FAT32**:  광범위한 호환성을 제공하지만, 파일 크기와 볼륨 크기에 제한이 있어, 작은 데이터를 저장하는 이동식 드라이브에 주로 사용
		- **exFAT**:  FAT32의 제한을 넘어서며, 큰 파일과 볼륨을 지원
		- 
	- 하나의 컴퓨터에서 여러 개 파일 시스템을 사용 가능
		- = 운영체제는 하나의 파일 시스템 프로그램을 사용한다기보다는, 다양한 파일 시스템을 지원 (다양한 프로그램과 기능을 포함)
		- = 저장할 데이터의 종류-유형, 필요에 따라 선택할 수 있는 옵션을 제공
		- = 파일 시스템들은 각각 데이터를 저장하고 관리하는 최적의 방법을 제공하기 위해 설계
		- 
		- 윈도우 운영체제에서 사용 중인 파일 시스템을 확인하고, 다른 파일 시스템으로 변경하는 방법
			- 1. 파일 시스템 확인 방법
				- 시작 메뉴에서 파일 탐색기 > 내 PC 클릭
				- 사용 중인 파일 시스템을 확인하고 싶은 드라이브를 마우스 오른쪽 버튼으로 클릭한 후 '속성'을 선택
				- 드라이브 속성 창의 '일반' 탭에서 파일 시스템 유형이 표시됩 (예: NTFS, FAT32).
			- 2. 파일 시스템 변경 방법
				- 파일 시스템을 변경하기 위해서는 해당 드라이브를 포맷해야 합
				- 주의: 포맷 과정에서 드라이브의 모든 데이터가 삭제되므로, 중요한 데이터는 반드시 다른 곳에 백업
			- 
		- **Q.** 다양한 파일 시스템이 존재? 사용자는 매번 선택해야됨?  
			- 드라이브를 처음 포맷할 때 파일 시스템을 선택하면 그 이후로는 해당 드라이브에 데이터를 저장할 때 자동으로 선택한 파일 시스템을 사용하게 됩 > 따라서 인터넷에서 자료를 다운로드하여 컴퓨터에 저장할 때, 사용자가 어떤 파일 시스템을 사용할지 선택할 필요는 없습
			- 즉, 컴퓨터의 주 하드 드라이브는 처음 컴퓨터를 설정할 때 NTFS로 포맷-설정 시 이후에 인터넷에서 어떤 파일을 다운로드하든, 그 파일은 자동으로 이 NTFS 파일 시스템을 사용하는 드라이브에 저장되고 있음
			- 
			- 컴퓨터나 다른 디지털 장치에서는 기본적으로 선택되어 설치되는 파일 시스템이 있고, **특정한 사용 상황**이나 요구에 따라 다른 파일 시스템으로 변경하여 사용할 수 있습
				- = 대부분의 경우, 운영체제 설치 시 기본 파일 시스템이 설정됩
			- 특정한 사용 상황? =>
				- 큰 파일을 저장해야 하거나, 특정 타입의 데이터 보호 기능이 필요한 경우, 보다 적합한 파일 시스템을 선택할 수 있습



##### ㅡ [[운영체제기능-이중모드-매커니즘\|운영체제기능-이중모드-매커니즘]]
- 2. **운영 체제** - 큰 개념
    - 운영 체제의 역할과 기능
	    - 시스템 호출
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==이중모드== | [[운영체제기능-이중모드-매커니즘\|운영체제기능-이중모드-매커니즘]]
	- <span style="background:#d3f8b6">CPU-커널-사용자모드-이미지</span>
		- 이미지 요약 =>
		- 복기 : `CPU 연산작업 = 명령어를 해석 > 실행 > 출력하는 것`
		- CPU의 이중모드는 '사용자 모드'와 '커널 모드'로 구분되며, 각 모드에서 CPU가 해석 > 실행할 수 있는 명령어와 자원 접근 권한이 다름
		- 
	- 복기 : [[운영체제-메모리-프로세스-파일관리-이미지#- OS-메모리관리-메모리내부구조-메모리공간-이미지\|운영체제-메모리-프로세스-파일관리-이미지#- OS-메모리관리-메모리내부구조-메모리공간-이미지]]
		- 컴퓨터 메모리는 크게 **커널 영역과 사용자 영역** 2가지로 구분 | [[커널영역-사용자영역\|커널영역-사용자영역]]
	- 메모리 상에 각 영역이 존재한다는 의미는 결국 각 영역에 존재하는 코드를 CPU가 해석하고 실행하는 두 가지 모드 존재한다는 것
		- = 메모리 영역의 구분과 비슷하게 CPU는 운영체제의 보안과 안정성을 유지하기 위해 서로 다른 수준의 접근 권한을 가지고 코드를 해석 > 실행함
		- 
		- 1. 사용자 영역 >` 사용자 모드`로 코드 해석 > 실행
			- 해당 모드에서는 제한된 권한으로 실행
			- = 자원 접근 불가
			- 커널 영역의 코드를 실행할 수 없는 모드
			- 
		- 2. 커널 영역 > `커널 모드`로 코드 해석 > 실행
			- 운영체제의 서비스를 제공받을 수 있는 실행모드
			- 자원 접근을 비롯한 모든 명령어 실행 가능.
			- CPU가 모든 하드웨어 자원과 메모리에 접근할 수 있는 권한을 가짐 
			- 권한을 가짐 = 하드웨어 자원과 메모리 접근에 대한 코드를 해석 > 실행 가능
			- 
	- ==시스템콜과 CPU 이중모드 전환 과정 =>== | [[시스템콜-CPU이중모드-과정\|시스템콜-CPU이중모드-과정]]


##### ㅡ [[시스템콜-CPU이중모드-과정\|시스템콜-CPU이중모드-과정]]
- 2. **운영 체제** - 큰 개념
    - 운영 체제의 역할과 기능
	    - 시스템 호출
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==시스템콜과 CPU 이중모드 전환 과정 =>==
	- 상황예시1
		- <span style="background:#d3f8b6">시스템콜-이중모드-전환과정-이미지</span>
			- 이미지 설명 =>
			- 현재 이미지 상황이 바로 인터럽트! 상황
			- 따라서 사실상 운영체제 코드를 실행하고 복귀하고 이런 과정 = 인터럽트 과정이 매우 자주 발생하게 됨
			- 
		- 특정 응용 프로그램에서 생성된 데이터를 HDD에 저장하는 상황.
		- 응용 프로그램 <> HW-HDD 직접 상호작용을 통해 데이터가 저장 X
		- 운영체제와 먼저 상호작용 진행 > 운영체제와 HDD 상호작용을 통해 최종 데이터가 저장됨
		- EX) 운영체제에 존재하는 `HDD에 데이터를 저장해라!` 의미를 가진 명령코드 실행
		- 
	- `상황예시1` 상황에서 아래와 같은 과정이 있었던 것
		- 1. **시스템콜 사용**: 
			- `시스템콜`을 통해 `애플리케이션`은 `운영체제`에 서비스를 요청하며, `운영체제는` 이러한 요청을 받아 `하드웨어`에 접근하고 제어
			- 시스템콜은 운영체제 터미널에서 사용하는 명령어와 다름
			- 응용 프로그램이 시스템 자원에 접근하고자 할 때, 시스템콜을 통해 운영체제에 요청을 합
				- EX) `OS야 나 ~ 프로그램인데 ~ 데이터 HDD에 저장해야됨`> `HDD야 나 OS인데 ~ 프로그램이 ~데이터 저장해야된데 너 코드 해석>실행하는 모드 변경하고 데이터 저장해줘`
			- 이는 CPU-사용자 모드에서 실행 중인 프로그램이 하드디스크 드라이브(HDD)와 같은 하드웨어에 접근하고자 할 때 필요 (접근해야 해석 > 실행함)
			- 
			- 시스템 콜(system call) = 시스템 호출? =>
				- 시스템 콜은 운영 체제가 제공하는 더 높은 수준의 서비스/운영체제의 커널 기를 일반 프로그램이 사용-요청하기 위해 사용되는 인터페이스
					- = 운영체제가 제공하는 서비스에 프로그램적으로 접근할 수 있도록 하는 명령코드
					- = 시스템콜은 응용 프로그램과 운영체제 사이의 명령 코드
					- = 응용 프로그램이 운영체제를 통해 하드웨어 자원을 안전하게 사용할 수 있도록 하는 인터페이스 역할 
				- 즉, 응용 프로그램이 운영체제의 자원을 안전하고 효율적으로 사용하도록 특정 **작업을 요청**하는 명령어나 코드로 이해
				- 
				- 주의 
					- 시스템콜은 응용 프로그램에서 사용하는 명령코드! 하지만 시스템 콜 자체는 운영체제의 일부(내부에 정의-존재)
					- "운영체제에서 사용하는 명령코드이다!"라는 표현 X
					- 
				- 작업요청? =>
					- 응용 프로그램은 HW-자원에 직접 접근하면 위험. 
					- 응용 프로그램이 하드웨어에 직접 접근하지 않고 운영 체제를 통해 필요한 작업을 수행하도록 요청하는 방식은 응용 프로그램이 시스템 자원(HW)을 효율적이고 안전하게 사용할 수 있도록 함
						- = 운영체제 기능 - `응용프로그램들이 자신을 통해서 HW 자원에 접근하도록 함`
						- 해당 기능은 메모리 관리, CPU 관리를 포함하여 운영체제의 여러 기능에 걸쳐 있음
				- 
				- 시스템 콜-명령어 종류
					- <span style="background:#d3f8b6">시스템 호출-명령어 종류-이미지</span>
						- 이미지 설명 =>
						- 운영체제의 다양한 기능들에 대한 명령코드가 정의되어 있고 > 해당 기능이 필요할 때 해당 코드가 실행되고 있던 것
						- 
						- 프로레스 관리 시스템 콜-명령어
						- 파일 관리 시스템 콜-명령어
							- **`open`**: 파일을 열고 파일에 대한 접근 권한을 획득
							- 파일의 내용을 읽을 때, 응용 프로그램은 `read` 시스템 콜을 통해 운영 체제에게 데이터를 요청 > 운영 체제는 CPU 모드 변경 > 따라서  파일에서 데이터를 읽어 프로세스의 메모리 공간으로 전송 가능해짐
						- 디렉토리 관리 시스템 콜-명령어
						- 파일 시스템 관리 시스템 콜-명령어
						- 
		- 2. **모드 전환**: 
			- 참고노트 : [[ALU-산술논리장치-플래그레지스터#- 다양한 플래그 값 표-이미지\|ALU-산술논리장치-플래그레지스터#- 다양한 플래그 값 표-이미지]] / 슈퍼바이저 플래그
			- 시스템콜-요청(예: 데이터 저장 요청)을 받으면 > 운영체제는CPU를-커널 모드로 전환합 > 커널 모드에서는 운영체제가 직접 하드웨어를 조작할 수 있는 권한을 가짐 
				- = ~한 코드를 해석 > 실행할 수 있음
				- 즉, 응용 프로그램이 시스템콜을 운영체제쪽으로 보내면 운영체제는 CPU 모드를 변경한다. 요청-코드를 해석 > 실행하기 위해
				- 
		- 3. **작업 수행 및 모드 복귀**: 
			- 요청된 작업(예: HDD에 데이터 저장)이 완료되면, 운영체제는 다시 사용자 모드로 전환하여 응용 프로그램에 제어권을 반환
			- 이렇게 함으로써 시스템의 보안과 안정성을 유지하면서도 필요한 작업을 효과적으로 수행



##### ㅡ [[메모리-주소체계-주소공간-작동원리\|메모리-주소체계-주소공간-작동원리]]
- 2. **운영 체제** - 큰 개념
    - 메모리 관리
	    - 가상 메모리
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==메모리 주소 공간 구분 = 주소 체계==
	- 메모리 기본적인 작동원리
		- CPU나 실행 중인 프로그램은 스스로 메모리의 특정 주소에 무엇이 저장되어 있는지, 어떤 주소가 비어 있는지를 직접 알 수 없음
			- = 실행되는 프로그램은 가상 메모리 주소를 사용하여 자신이 실제 메모리의 어느 위치에 적재되었는지 모르는 상태로 실행
		- 이 정보/실제 주소는 운영 체제에 의해 관리되며, 운영 체제는 프로세스가 요청할 때 메모리를 할당하고 회수함 (운영체제 기능) 
		- 메모리에 저장되는 값들은 프로그램의 실행과 종료에 따라 계속 변함 
			- = 한 프로그램이 종료되면 그 프로그램이 사용했던 메모리 영역은 다른 프로그램이 사용할 수 있게 됨
			- = 같은 프로그램이라도 다른 시점에 실행될 때 메모리의 다른 위치에 적재될 수 있습
			- 
	- **물리 주소와 논리 주소(가상 주소)는 컴퓨팅 시스템 내에서 데이터에 접근하는 두 가지 다른 방식 존재.**
	- ==물리주소-논리주소? =>== | [[물리주소-논리주소-운영체제-MMU\|물리주소-논리주소-운영체제-MMU]]- 
	- 
	- Q. 두 가지 다른 방식이 존재하는 이유?
		- 메모리보호
		- = 이런 **메커니즘/개념**은 프로세스 간 메모리 격리를 보장하고, 시스템의 안정성과 보안을 향상
		- 이런 매커니즘/개념? =>
			- <span style="background:#d3f8b6">논리주소-물리주소-프로세스-이미지</span>
				- : CPU는 메모리 접근하기 전 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지를 항상 검사하고 있음
				- = 실행 중인 프로그램의 독립적인 실행 공간 확보 = 하나의 프로그램이 다른 프로그램을 침범하지 못하게 보호
				- 
	- 물리주소 <> 논리주소 없다면?
		- <span style="background:#d3f8b6">논리주소-물리주소-존재이유-이미지</span>
		- 
	- 이러한 두 가지 다른 방식의 주소가 존재할 때 영역을 침범하는 경우를 방지하기 위해, 메모리를 보호하기 위해 `한계 레지스터` 존재
	- **한계 레지스터(Limit Register)? =>**
		- <span style="background:#d3f8b6">베이스-한계레지스터-MMU-이미지</span>
			- 상황예시 =>
			- 논리주소 값 범위를 넘어서는 주소값 사용 X 
			- 논리 주소 범위를 벗어난 명령어/제어신호 발생한 상황
			- 현재 제어신호가 실행된다면 논리주소 200 + 베이스 값 100 = 300번지 값이 삭제됨
				- = 영역을 침범
				- = 삭제되면 안되는 값이 삭제됨
		- 역할/기능
			- 프로그램 영역을 침범할 수 있는 명령어 실행을 막음
		- 어떻게? =>
			- 베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한 것 처럼 한계 레지스터는 논리 주소의 **최대 크기**를 저장
				- = 메모리 세그먼트의 크기를 제한하는 데 사용
				- = 해당 세그먼트가 차지하는 메모리의 범위를 나타냅
			- 베이스 레지스터 값 + 한계 레지스터 값이 존재 > 실제 메모리에서 프로그램의 처음위치와 최대 위치/끝 위치 파악 가능
			- 이를 통해 프로그램이 할당된 메모리 범위를 넘어서는 접근을 시도할 때 오류를 발생시켜 보호 메커니즘을 제공



##### ㅡ [[물리주소-논리주소-운영체제-MMU\|물리주소-논리주소-운영체제-MMU]]
- 2. **운영 체제** - 큰 개념
    - 메모리 관리
	    - 가상 메모리
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==물리주소-논리주소? =>== 
	- <span style="background:rgba(205, 244, 105, 0.55)">논리주소-물리주소-존재이유-이미지</span> | [[메모리-주소체계-주소공간-작동원리#- 논리주소-물리주소-존재이유-이미지\|메모리-주소체계-주소공간-작동원리#- 논리주소-물리주소-존재이유-이미지]]
	- 
	- 1. 물리 주소 (Physical Address)
		- 이는 실제 메모리 칩 내에서 데이터가 저장되는 물리적 위치 > 따라서 0번지 위치는 오직 하나 뿐
			- = 실제 메모리 셀에 접근하는 데 사용되는 주소
		- 이 주소는 메모리 관리 하드웨어에 의해 직접 참조
		- 
	- 2. 논리 주소=가상 주소=추상화 주소 (Logical Address)
		- 논리 주소는 각 프로세스가 자신만의 가상의 독립된 메모리 공간을 가지는 것처럼 작동하게 해주는 추상화된 개념
			- = 각 프로세스는 마치 전체 시스템 메모리를 해당 프로그램/프로세스가 전체를 다 사용하고 있는 것처럼 느끼게 됨
			- = 각 프로세스는 자신만의 독립된 주소 공간을 가지며, 이 공간 내에서는 0번지부터 시작하는 주소 체계를 가집 
			- = 각각 공간에 0번지 존재 가능
		- 이는 CPU와 프로그램에 의해 사용되는 주소로, 운영 시스템에 의해 관리
		- 
		- 가상 주소이기 때문에 운영 체제는 프로세스가 사용하는 **논리 주소를 실제 물리 주소로 변환**하여 실제 메모리 접근을 가능하게 합
		- 논리 > 물리 주소변환(Address Translation)? =>
			- 운영 체제와 MMU 모두 관여. 즉, 두 컴포넌트는 협력하여 메모리 접근 및 관리를 가능하게 합
				- 운영 체제
					- 높은 수준의 메모리 관리 작업을 수행
						- =="높은 수준의 작업"과 "낮은 수준의 작업"이라는 표현== | [[높은수준작업-낮은수준작업-표현의미\|높은수준작업-낮은수준작업-표현의미]]
					- = 운영 체제는 가상 메모리 관리를 개념적으로 수행
					- = 프로세스에 가상 주소 공간을 할당하고, 해당 공간의 관리, 가상 주소와 물리 주소 간의 매핑 정보를 유지 관리하는 역할
					- = 프로세스가 메모리를 요구할 때 해당 주소 변환을 가능하게 하는 매핑 정보를 설정
					- 
				- MMU (Memory Management Unit) =메모리 관리 장치
					- 실제 하드웨어 장치
					- 구체적인 작업은  하드웨어 수준에서 MMU가 담당
						- = CPU에서 발생하는 메모리 접근 요청 시 운영 체제에 의해 설정된 페이지 테이블이나 다른 주소 매핑 구조를 사용 > 논리 주소를 물리 주소로 변환하는 구체적인 작업을 담당
					- 
					- <span style="background:#d3f8b6">베이스-한계레지스터-MMU-이미지</span> | [[메모리-주소체계-주소공간-작동원리#- 베이스-한계레지스터-MMU-이미지\|메모리-주소체계-주소공간-작동원리#- 베이스-한계레지스터-MMU-이미지]]
						- 내부과정 =>
							- CPU는 논리주소를 메모리에게 보낸다. > 사실 그 전에 MMU 장치 거친다 > MMU가 논리주소를 물리 주소로 변환 > 메모리는 최종적으로 물리주소를 받는다.
							- 논리주소 100번지 삭제 신호 > 논리주소 + 베이스 레지스터 값 > 물리주소 15100번지 삭제 신호 > 메모리 도착
							- 가상의 공간에서 논리주소 값 = 실제 메모리에서 첫 시작점으로부터 떨어진 거리/변위가 됨.
							- 
						- 논리주소 + 베이스 레지스터 값 더해 논리주소를 물리주소로 변환함
							- = 논리주소와 베이스 레지스터 값을 더하면 실제 메모리상에 존재하는 주소/위치 파악 가능
						- 복기 - `가상공간-논리주소는 0번부터 시작`
						- 복기 - `베이스 레지스터에는 프로그램의 시작점 주소 존재`
						- 
						- 주의
							- 복기 : `데이터는 CPU-논리주소 > MMU에 의해 변환된 물리 주소를 기반으로 메모리로 전송 > 도착`
							- 그 이후 메모리에서 CPU로 데이터가 전송될 때, 물리 주소가 다시 논리 주소로 변환될 필요는 없음
							- 왜? =>
								- 그 이유는 이미 CPU 내에서 실행 중인 프로세스가 논리 주소를 통해 데이터를 요청하고, MMU가 이를 물리 주소로 변환하여 메모리 접근을 수행. 
								- 즉, 메모리에서 데이터가 CPU로 돌아올 때, 이미 해당 데이터는 특정 논리 주소에 대한 응답으로 간주되어 논리 주소를 요청한 해당 지점에서/논리 주소를 통해 필요한 값을 받게 됨
								- 




##### ㅡ [[높은수준작업-낮은수준작업-표현의미\|높은수준작업-낮은수준작업-표현의미]]
- 1. **컴퓨터 구조** - 큰 개념
    - 메모리 계층구조
    - 
- 2. **운영 체제** - 큰 개념@
    - 메모리 관리
	    - 가상 메모리
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- =="높은 수준의 작업"과 "낮은 수준의 작업"이라는 표현== =>
	- 요약 =>
	- CPU에서 사용하는 명령어 = 기계어 레벨 명령어 = 하드웨어 레벨 명령어 = 낮은 수준 명령어 
	- 운영체제에서 사용하는 명령어 = 시스템콜
	- 각각 추상적인 작업과 구체적인 하드웨어 작업을 구분하는 용어
	- 
	- 낮은 수준의 작업 (Low-Level Tasks)
		- 물리적인 장치나 하드웨어가 수행하는 물리적인, 기술적인 작업을 의미
			- = 컴퓨터의 물리적 구성 요소에 직접적으로 영향
		- EX)
			- MMU 같은 하드웨어가 실제 메모리 주소 변환, 데이터 전송, 접근 제어와 같은 작업을 수행하는 것
			- 메모리 맵 입출력에서 언급된 메모리 접근 명령은 하드웨어 레벨에서 CPU가 직접 메모리와 입출력 장치를 제어하는 데 사용됩
				- "일반적인 메모리 접근 명령"은 CPU가 메모리 주소를 통해 데이터를 읽거나 쓰는 기본적인 명령어들을 의미
				- CPU가 직접 메모리에 접근할 때 사용하는 기계어 레벨의 명령어로, 로드(load), 스토어(store), 무브(move)와 같은 기본적인 메모리 조작 명령어들을 포함
				- 
	- 높은 수준의 작업 (High-Level Tasks)
		- 추상적인, 즉 직접적으로 눈에 보이지 않는 소프트웨어 관리 작업을 의미
			- = 운영체제 수준 작업 
			- = 사용자 에게 메모리 관리의 복잡성을 숨기고, 편리한 추상화를 제공
			- = 사용자 또는 프로그래머가 직접 관여하지 않는, 운영 체제가 제공하는 추상화된 서비스나 관리 기능을 의미
		- EX)
			- 운영체제 기능-프로그램
				- 운영 체제는 프로세스가 시작될 때 각 프로세스에 독립적인 가상 메모리 공간을 할당
			- 시스템콜 
				- 연관노트 확인 => [[시스템콜-CPU이중모드-과정\|시스템콜-CPU이중모드-과정]]


##### ㅡ [[실행환경-런타임환경-컴파일러-인터프리터-이해\|실행환경-런타임환경-컴파일러-인터프리터-이해]]
- 2. **운영 체제** - 큰 개념
    - 프로세스 관리
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 실행 시간(Execution Time)
	- 프로그램 시작 > 완료까지 걸린 전체 시간 의미
	- 이 시간은 프로그램이 수행하는 모든 작업과 프로세스를 포함
	- CPU 시간(프로그램이 CPU에서 실행되는 시간), I/O 시간(입출력 작업에 소요된 시간), 대기 시간(시스템 자원을 기다리는 시간) 등이 포함
- 런타임 시간(Runtime)
	- 프로그램이 실행되는 동안의 상태나 그 시간 동안 수행되는 작업의 시간을 의미
		- = 프로그램이 실제로 작동하고 있는 시간
- 용어정리 요약 : "두 단어는 같은 의미로 사용 가능"
	- **실행환경 (런타임환경) 정의**
		- 프로그램이 실행되기 위해 필요한 모든 자원(하드웨어 요소)과 서비스(운영체제, 라이브러리, 데이터베이스 등 프로그램)의 집합체
	- **환경**이 가진 두 가지 의미
		- 1. 추상화된 환경: 
			- 프로그램 코드가 실행되는 가상의 환경을 의미
		- 2. 실제 환경: 
			- 프로그램 코드가 실행되는 실제 하드웨어 시스템을 의미
			- 물리적인 컴퓨터나 서버를 포함
	- 비유예시
		- 배우 = 프로그램
		- 무대 = 실행환경
			- 배우가 연극을 하기 위해 연극도구, 장치가 모인 무대가 필요함 
			- 프로그램이 작동하기 위해선 하드웨어-운영체제-라이브러리-데이터베이스-인터넷 연결 등 다양한 요소들이 필요함
	- 상황예시
		- Node.js  =JavaScript 코드를 서버 측에서 실행할 수 있게 하는 환경을 제공
			- 1. **추상화 환경/가상환경** :  브라우저 외부에서 JavaScript를 실행할 수 있는 추상화된 환경을 의미
			- 2. **실제환경** : Node.js 자체도 하나의 프로그램/플랫폼으로, 사용자의 시스템에 설치되어 JavaScript 실행 환경을 제공
				- + 사용자는 Node.js 다운로드 > 설치 가능
- 1. **컴파일 언어**: 
	- 특징
		- EX) C, C++, Java(컴파일 후 가상 머신에서 인터프리트) 등 
		- 주의
			- Java는 컴파일러 언어지만 컴파일 후 가상머신에서 인터프리터 과정이 존재
			- 컴파일러만 사용되는 언어는 전통적인 컴파일러! 언어라고 표현 > 따라서 전통적인 컴파일러 언어! > C언어만 해당
		- 컴파일러 프로그램이 사용되어 해석>실행됨
		- 요약 :`소스코드 > 기계어 > 실행파일 > 실행`
			- 컴파일러는 소스 코드 전체를 먼저 기계어로 번역하고, 이렇게 번역된 코드를 실행 파일로 만듭 > 이 실행 파일은 나중에 언제든지 실행할 수 있습
			- 이 과정은 프로그램 실행 전에 완료되므로, 프로그램 실행 시에는 번역 과정 없이 바로 실행이 가능
		- 특징/장점/단점
			- 한 번 컴파일이 완료되면 컴파일된 프로그램/실행파일을 바로 사용 가능 = 빠른 실행 속도
			- 각 플랫폼에 맞게 각각 컴파일 필요
	- 컴파일 언어에서의 런타임은 컴파일된 실행 파일이 실제로 컴퓨터 하드웨어에서 실행되는 시간
		- = 프로그램이 시작되어 종료될 때까지 실제로 CPU에서 처리되는 시간
- 2. **인터프리터 언어**: 
	- 특징
		- EX) Python, Ruby, JavaScript 등이 인터프리터 언어
		- 주의
			-  인터프리터(-프로그램으로)만 해석 > 실행되는 **순수한 인터프리터** 언어는 거의 없으며 대체로 인터프리터가 탑재된 가상머신과 컴파일(-프로그램)을 혼합한 형태로 사용됨
		- 인터프리터 프로그램이 사용되어 해석 > 실행됨
		- 인터프리터 방식은 프로그램을 실행할 때 소스 코드를 기계어로 미리 변환하지 않고, 실행 시점에 한 줄씩 읽어서 처리
		- 이 방식은 실행 전에 전체 코드를 번역하지 않기 때문에 개발 과정에서 코드 수정 후 바로 결과를 볼 수 있는 장점
			- <> 컴파일러 언어와 달리 한 단계식 해석 > 실행되므로 처리 시간 증가
	- 인터프리터 언어에서는 소스 코드가 런타임에 한 줄씩 해석되고 실행 > 따라서 실행 시간은 소스 코드의 각 줄이 해석되고 실행되는 데 총 걸리는 시간을 의미
	- 
	- 관점에 따른 의미차이
		- 파이썬 언어 관점 > 인터프리터 용어 의미
			- 파이썬 프로그래밍 언어를 해석>실행하는 프로그램/환경
			- EX) 윈도우 터미널에서 `python` 입력 > 파이썬 인터프리터 프로그램 실행됨
		- VS코드 관점 > 인터프리터 용어
			- 파이썬 프로젝트에 대한 실행환경 **설정** 의미
				- + 설정
				- 파이썬 버전 및 가상환경 지정

##### ㅡ [[프로그램실행원리-CLI-cmd-GUI\|프로그램실행원리-CLI-cmd-GUI]]
- 2. **운영 체제** - 큰 개념
	- CLI와 GUI는 운영 체제가 제공하는 기본 인터페이스
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 프로그램 실행 원리
	- 사용자가 다운받은 모든 것은 프로그램/코드덩어리/집합/기능임. > 사용하기 위해선 2가지 방식 중 1가지를 이용해 실행-사용
	- 1. CLI(Command Line Interface) 방식
		- "사용자가 텍스트 기반 명령어 입력 > 기능 사용" | [[cmd단위-명령코드\|cmd단위-명령코드]]
		- CLI를 지원하는 프로그램을 사용하기 위한 프로그램 존재
			- = 명령어를 입력 > 실행하는데 사용되는 텍스트 기반 인터페이스
			- 인터페이스? =>
				- "서로 다른 요소와 상호작용하기 위한 방법 제공하는데 사용되는 용어/개념"
			- CMD (Command Prompt) = 명령 프롬프트
				- 윈도우 운영체제에서 프로그램을 사용하기 위한 프로그램으로 표현 가능
				- 윈도우 운영체제 내에서 커맨드 라인 인터페이스를 제공하는 프로그램
				- 사용자는 이를 통해 텍스트 기반 명령어를 입력하여 운영 체제를 관리하고, 파일 시스템을 탐색하며, 다양한 프로그램을 실행
			- 윈도우 파워셸(Windows PowerShell)
			- 터미널 (Terminal)
			- 콘솔 (Console)
				- 콘솔은 입력과 출력을 다루는 장치나 가상 환경을 의미도 존재
				- 
	- 2. GUI(Graphical User Interface) 방식 
		- "사용자가 그래픽 요소(버튼-아이콘-메뉴 등)사용 > 기능 사용"
		- 상황예시
			- 크롬 브라우저 아이콘 클릭 = 윈도우 운영체제(에) 명령코드 작성


##### ㅡ [[운영체제-cmd-터미널-명령코드\|운영체제-cmd-터미널-명령코드]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
	    - 시스템 호출 및 명령어-인터페이스
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 다양한 cmd 명령코드 이해 
	- = **프로그램**의 다양한 기능을 명령코드로 실행-사용 | [[프로그램실행원리-CLI-cmd-GUI\|프로그램실행원리-CLI-cmd-GUI]]
	- 프로그램? =>
		- 운영체제 OR 파이썬 OR 아나콘다 등등등 
		- 
- **cmd 단위 명령코드 구조이해** 
	- 프로그램 실행 명령코드
	- 기능 사용 명령코드
	- 추가적인 옵션 설정 명령코드
		- 플래그(Flag)=옵션(Option) 코드
		- '대시(`-`~) 로 시작'
			- EX)
			- 긴 형식 존재 - '`--version'
			- 짧은 형식 존재 - '`-r'
			- 
- **윈도우 단축키** =>
	- `Windows 키 + R` = 실행 프로그램 > cmd 검색
		- 명령 프롬프트(CMD)를 빠르게 실행
	- `Ctrl + C`
		- 이 키를 누르면 현재 실행 중인 명령을 중단하고 터미널로 돌아갈 수 있음
		- 
- 운영체제(프로그램)에서 사용되는 **CMD 단위 명령코드** =>
	- 사용자가 운영체제의 터미널 또는 커맨드 라인 인터페이스를 통해 작성하는 명령코드
	- 운영체제의 터미널에서 사용하는 명령코드는 일반적으로 사용자가 운영체제 내부의 기능을 손쉽게 사용할 수 있도록 돕는 **유틸리티 명령코드**
		- 운영체제 내부 기능 사용 = 기능 활성화 = 기능에 접근
		- 
	- `cd` 명령어(코드)-Change Directory
		- '작업 디렉토리 출력/이동-변경' | [[파일경로-절대경로-상대경로-기호표현#cmd-코드\|파일경로-절대경로-상대경로-기호표현#cmd-코드]]
		- 
	- `pwd` 명령코드
		- '리눅스, 유닉스 기반 운영체제'
		- 
	- `dir`-Directory
		- 기능
			- "현재 위치 디렉토리에 어떤 파일, 폴더 있는지 확인 기능"
			- 
		- 윈도우 시스템에서 모든 디렉토리에는 기본적으로 두 개의 숨겨진 디렉토리인 `.` (현재 디렉토리를 가리키는)와 `..` (상위 디렉토리를 가리키는)가 존재하기 때문에 > 최소2개 디렉토리 존재
		- 이러한 표시는 디렉토리의 구조와 위치를 파악하는 데 도움을 주는 시스템적 특성
			- + 파일과 디렉토리를 구분하기 위해 `<DIR>` 표시가 디렉토리 옆에 나타남
		- <span style="background:#d3f8b6">예시코드</span>
			- 항목의 크기 / 수정일자 / 시간 
			- `.` 디렉토리는 해당 위치 자체를 가리킴
			- `..` 디렉토리는 상위 디렉토리
	- `cls`-Clear Screen
		- 현재 창의 내용을 지우고 화면을 깨끗하게 지웁
	- `where` - 
		- "설치 경로 확인 명령코드"
		- <span style="background:#d3f8b6">예시코드</span>
		- 
	- `nslookup` 명령코드
		- 연관노트 : [[cmd단위-명령코드\|cmd단위-명령코드]]
			- pip
		- **윈도우 명령코드로서** 네트워크 문제를 진단하고 해결하는 데 유용한 도구/프로그램
		- 윈도우, 리눅스, 맥 등 여러 운영 체제에서 사용할 수 있는 네트워크 관리 명령어로, **DNS 조회**를 위해 사용되며, 운영 체제의 터미널이나 명령 프롬프트에서 실행
		- <span style="background:#d3f8b6">예시코드-출력결과</span>
		- 해당 표현 모두 가능 =>
			- `윈도우 명령코드` 표현 : 윈도우 환경에서 `nslookup`을 사용
			- `운영체제 명령코드` 표현 : 다양한 운영 체제에서 사용될 수 있기 때문
			- 운영체제에서 사용하는 `네트워크 명령코드` : 네트워크 문제 진단에 사용되므로
		- 사용예시
			- 시스템 관리자가 네트워크 문제를 진단하고자 할 때 `nslookup` 명령어를 사용
			- 관리자가 사내 네트워크에서 특정 웹사이트(예: example.com)에 연결이 안 될 때, 윈도우 명령 프롬프트에서 `nslookup example.com`을 실행
			- 이 명령은 example.com의 DNS 정보를 조회하여 해당 도메인의 IP 주소를 반환하고, 이 과정을 통해 DNS 서버가 정상적으로 작동하고 있는지, 해당 도메인의 IP 주소가 올바르게 해석되는지 등을 확인할 수 있습
				`ㅡ 이해 ㅇ : 출력된 결과를 보고 해당 서버와 로컬pc가 제대로 통신이 이뤄지고 있는지를 확인한다는 것`
	- `diskpart` 명령어 =  유틸리티 도구 = 프로그램 | [[파티셔닝-파티션-포매팅-포맷#- 윈도우-cmd-예시코드\|파티셔닝-파티션-포매팅-포맷#- 윈도우-cmd-예시코드]]
	- `ping`
		- 다른 노트 내용 확인


##### ㅡ [[윈도우-cmd-사용법\|윈도우-cmd-사용법]]
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 윈도우 cmd 사용법
	- 특정 폴더에서 바로 cmd 실행 가능
		- 해당 방법을 몰랐을 때 : 처음 위치부터 명령코드 이용 하나씩 접근
		- 1. 폴더 주소표시줄에서 cmd 입력
			- <span style="background:#d3f8b6">이미지</span>
		- 2. 폴더 빈 공간에 Shift + 마우스 오른쪽 클릭 > `여기서 명령 창 열기`
			- <span style="background:#d3f8b6">이미지</span>

##### ㅡ [[커널영역-사용자영역\|커널영역-사용자영역]]
- 2. **운영 체제** - 큰 개념
    - 운영 체제의 역할과 기능
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 커널 용어
	- 커널이라는 용어는 다음 두 가지 관점에서 이해 가능
	- 이 두 가지 의미는 서로 다른 관점을 제공하지만, 결국 커널은 운영체제와 메모리 양쪽 모두에서 핵심적인 기능을 담당
		- 1. 메모리 관점에서의 커널
			- 메모리에서 커널 영역은 운영체제의 핵심코드와 데이터가 저장되는 공간
		- 2. 운영체제 입장에서의 커널
			- <span style="background:#d3f8b6">운영체제-커널-이미지</span>
			- 운영 체제의 핵심 기능을 수행하는 기능 (코드와 서비스)
				- + 따라서 운영체제 안에 존재하지만 핵심기능이 아닌 기능들은 커널이라고 표현하지 X 
				- EX) 유저 인터페이스 기능 : 운영체제 핵심 기능(커널) X
			- 이는 시스템의 모든 관리 작업을 담당하며, 하드웨어 리소스의 관리, 프로세스와 메모리 관리, 입출력 관리 등의 중요한 역할을 수행
			- 
			- 
- 1. 커널영역(Kernel Space)
	- 메모리에서 운영 체제의 핵심 부분이 실행되는 곳
	- 운영체제는 하드웨어와 직접적으로 상호 작용
	- 일반적인 응용 프로그램이 직접 접근할 수 없는 보호된 영역
- 2. 사용자영역(User Space)
	- 일반 소프트웨어 애플리케이션이 실행되는 영역
		- = 사용자가 실행하는 **모든 프로그램** 포함
	- 프로그램? =>
		- 사용자 영역에서 각 프로그램은 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구성된 자신만의 독립적인 주소 공간을 가집
		- = 프로그램이 실행되기 위해서는 실제로 메모리 상에 주소 공간에 로드되어야 하며, 이 주소 공간 내에서 다양한 추상적인 구분(예: 코드 영역, 데이터 영역, 힙 영역, 스택 영역 등)이 존재
			- 코드 영역(Code Segment) : 프로그램의 실행 코드가 저장되는 곳
			- 데이터 영역(Data Segment): 전역 변수와 정적 변수가 저장되는 곳
			- 힙 영역(Heap Segment): 동적으로 할당된 메모리(예: C에서 malloc, C++에서 new)가 위치하는 곳
			- 스택 영역(Stack Segment): 함수의 매개변수, 지역 변수, 반환 주소 등이 저장되는 곳 + 함수 호출 시 할당되고, 함수가 반환될 때 해제
			- 
	- 사용자 영역의 프로그램은 커널 영역에 비해 제한된 접근 권한을 가지며, 시스템 리소스에 접근할 때는 커널을 통해야 함
		- = "사용자 영역의 프로그램이 시스템의 리소스나 서비스에 접근할 때는 커널, 즉 운영 체제의 중심적인 부분을 통해야 한다"
			- 위 문장은 운영 체제의 기능 중 하드웨어 자원 관리(보호)의 일환 = 사용자 프로그램이 하드웨어 자원에 직접적으로 접근하는 것이 아니라, 커널을 통해 이루어진다는 운영 체제의 중재 역할을 강조
			- EX)
				- 입출력(I/O) 관리
					- : 이는 사용자 영역의 프로그램이 입출력 장치를 사용하고자 할 때 커널을 통해 요청이 이루어지고, 커널이 이를 관리하고 조정
					- 
				- 저장 장치 관리
					- : 파일 시스템 접근이나 저장 장치 사용 역시 커널을 통해 이루어집 > 사용자 프로그램이 데이터를 저장하거나 읽고자 할 때, 이 작업들은 커널에 의해 중재되고 관리

##### ㅡ [[시스템자원-시스템리소스-resource-용어\|시스템자원-시스템리소스-resource-용어]]
- 컴퓨터 시스템
	- 1. **컴퓨터 구조** - 큰 개념
	- 2. **운영 체제** - 큰 개념
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 시스템 자원 = 시스템 리소스 = resource
	- 프로그램이 실행되기 위해 필요한 (실제 HW)요소들을 의미 > 따라서 주로 '시스템 리소스'라는 용어는 컴퓨터의 핵심 부품인 CPU, 메모리, 입출력 장치 등 의미
	- 
	- 주의
		- 시스템 자원이란 일반적으로 컴퓨터의 핵심 하드웨어 부품을 의미하지만, 보다 넓은 의미에서는 소프트웨어적인 요소도 포함
		- EX) 파일 시스템, 데이터베이스, 네트워크 대역폭, 시스템 포트 등도 시스템 자원에 포함
		- 
	- 시스템? =>
		- 상호관련(된) 요소(들의) 집합 > 이 요소들은 함께 작동하여 공통적인 목표를 수행
		- EX) 분산버전관리시스템
			- 여러 컴포넌트와 프로토콜들을 사용해 코드 버전관리를 처리하는 전체 구조 의미
			- 깃은 분산버전관리시스템/프로그램
		- 상황에 따라 시스템의 구성요소들은 달라짐.
			- 함수(Function):
				- 시스템 내의 요소들이 특정 기능을 수행할 때, 각 요소는 시스템 전체의 기능을 위해 특정 역할을 수행하는 '함수'로 해석 가능
			- 모듈(Module):
				- 프로그래밍 컨텍스트에서, 요소들은 시스템 내에서 독립적이거나 반독립적으로 기능하면서 특정 기능을 수행하는 '모듈'로 해석 가능 > 각각 함께 작동해 더 큰 시스템의 일부 구성
			- 프로그램(Program) :
				- 좀 더 확장된 소프트웨어 시스템에서는 각 요소가 개별적인 '프로그램'이 될 수 있으며, 이 프로그램들이 상호 작용하여 복잡한 작업을 수행
			- 실제 하드웨어 부품(HW-Component):
				- 하드웨어 시스템의 경우, 각 요소는 실제 물리적 부품이 될 수 있으며, 이들 부품이 서로 상호작용하여 전체 시스템이 기능


##### ㅡ [[파일경로-절대경로-상대경로-기호표현\|파일경로-절대경로-상대경로-기호표현]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 파일경로
	- 1. 절대경로
		- root 기준 = C드라이브 기준 > 위치설명 시작
		- ex) 
			- `C:\Program Files\Git`
		- 어느 곳에서든 경로에 접근할 수 있는 형태임
			- 왜? : C드라이브 즉, 루트지점을 기준으로 위치를 설명하고 있기 때문
		- 절대경로 사용상황/용도
			- ex_) "웹에 올려진 데이터를 사용할 때"
			- 
	- 2. 상대경로
		- "현재 작성하고 있는 코드파일 위치를 기준으로 연결하려는 파일 위치설명"
		- = 처음부터 위치 설명 x, 현재 위치 기준 설명 방법
		- ex)
			- `./src/compnents/Counter.js`
				- 현재 위치 > 앞으로 이동하는 느낌
			- `../../img/logo.jpg`
				- 현재 위치 > 뒤로 이동하는 느낌
		- 상대경로 사용상황/용도
			- "내 로컬 디렉토리 내부에서 파일 연결할 때"
	- 
	- 다양한 기호 표현 존재
		- <span style="background:#d3f8b6">예시코드1</span>
		- <span style="background:#d3f8b6">cmd-예시코드</span>
		- 
		- `/` - root 위치(경로) 선택(이동)됨
		- `./` - 현재 위치(경로) 선택됨
			- 생략가능
		- `../` - 상위 위치(경로) 선택됨



##### ㅡ [[FAT파일시스템-프로세스-이해\|FAT파일시스템-프로세스-이해]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==FAT 파일 시스템==
	- USB, SD카드 등 저용량 저장장치에서 많이 사용되는 방식
	- 불연속-연결 할당 방식 기반 + **단점을 보안**한 파일 시스템
		- <span style="background:#d3f8b6">기존 불연속-연결할당방식-이미지</span>
	- 단점? 보안? =>
		- 기존 : 블록 안에 다음 번지 블록 주소를 기억하는 방식 > 이런 방식으로 인한 단점이 존재했음
		- 각 블록에 포함된 다음 블록 주소를 한데 모아 **테이블**로 관리하면서 보안 가능
		- 테이블? =>
			- FAT = File Allocation Table
			- FAT12 / 16/ 32 등 존재
			- 뒤 숫자 의미 : 블록을 표현하는 비트수
			- 
	- <span style="background:#d3f8b6">FAT파일시스템-FAT영역테이블-이미지</span>
	- <span style="background:#d3f8b6">FAT시스템-파티션구조-이미지</span>
		- FAT12 방식을 사용 시 > 각 파이션 모습
		- 예약영역 / FAT 영역/ 루트 디렉토리 영역/ 데이터 영역 존재
	- <span style="background:#d3f8b6">FAT시스템-디렉토리엔트리-이미지</span>
		- 디렉토리 엔트리에는 어떠한 값?
		- 파일 이름 / 확장자 / 속성 / 예약영역 / 생성시간 / 마지막 접근시간 / 마지막 수정시간 / 시작블록 / 파일크기 
	- <span style="background:#d3f8b6">FAT파일시스템-과정이해-이미지</span>
		- FAT 파일 시스템 사용시 어떤 과정을 거쳐 `a.sh`파일위치에 접근하는지 확인 =>
		- FAT 영역에는 FAT 값 존재
		- 루트 디렉토리 영역에는 루트 디렉토리 값 존재
		- 데이터 영역에는 루트 디렉토리 이외 디렉토리 존재
		- 
		- 순서대로 읽으면 결국 `a.sh` 파일 시작점이 되는 블록 주소 확인가능
			- 루트 디렉토리 > home 디렉토리 첫 번째 주소 3
			- h 디렉토리 > minchul 디렉토리 첫 번째 주소 15
			- m 디렉토리 > 찾고자 하는 파일 첫 번째 주소 9 
			- 첫 번째 주소를 알았으니 FAT 영역에 존재하는 표 이용 하나의 데이터 완성! 접근 가능
			- 9 > 8 > 11> 13 > -1 


##### ㅡ [[유닉스파일시스템-프로세스-이해\|유닉스파일시스템-프로세스-이해]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==유닉스 파일 시스템==
	- 불연속-색인 할당 기반 파일 시스템
	- 색인 블록 = `i-node` = 인덱스 노드! 라고도 부름
	- i-node? =>
		- 파일 속성 정보와 **15개의 블록 주소 저장** 가능
		- 즉, i노드만 읽어도 파일의 속성값들과 어디에 저장되어 있는지 확인 가능
		- 즉, 유닉스 파일 시스템에서는 i노드가 핵심값
	- 
	- <span style="background:#d3f8b6">디렉토리 엔트리-테이블-이미지</span>
		- i노드 번호와 파일 이름값만 저장
	- <span style="background:#d3f8b6">유닉스 파일시스템-과정이해-동작원리이해-이미지1</span>
		- 1. =>
		- `i-node`값은 유닉스 파일 시스템 사용 시 한 파티션에 모여 저장됨 = i-node 파티션-영역 존재
		- 
		- 파일 시스템 동작원리-과정-예시
			- `a.sh` 파일을 접근해 나가는 과정 가정
			- 유닉스파일시스템 파티션 구조 확인 가능
				- 예약영역 / i-node 영역 / 데이터 영역
			- i노드 영역 > i노트 2번 확인 가능 = 루트 i노드 > 루트 디렉토리 접근하기 위한 데이터 주소 저장된 상황 따라서 가장 먼저 접근 
			- 루트 디렉토리 값 1번 블록 저장 확인 > 접근
			- home 디렉토리 i노드번호 3번 확인 가능 > i노드 3번에 접근 > 210 주소 확인 가능 > 해당 주소로 이동
			- minchul 디렉토리 i 노드번호 8번 확인 가능 > i노드 8번에 접근 > 121번 주소 확인 가능 > 해당 주소로 이동
			- 최종 원하는 파일 a.sh의 i노드 번호 9 확인 가능 > 9번 i노드에 접근 > 해당 데이터들이 98, 12, 13에 각각각 저장 확인
			- 
	- **Q.** 그렇다면 15개의 블록을 넘는 더 큰 파일이 저장되는 경우엔 어떻게 동작? = 1개 i노드만으로 부족한 경우
		- <span style="background:#d3f8b6">유닉스 파일시스템-과정이해-동작원리이해-이미지2</span>
		- 1. 1번 i노드 > 블록 주소 중 12개에는 직접 해당 데이터-블록 주소를 저장
		- 2. 1개의 노드로 충분하지 않다면 13번째 주소부터는 `단일 간접 블록` 주소를 저장
			- 파일 데이터를 저장한 블록 주소들이 저장된 블록 
				- = 즉 마치 다른 i-node 주소를 저장
		- 3. 이마저도 충분하지 않다면 14번째 주소에 `이중 간접 블록` 주소를 저장
			- 마치 다른 i-node를 추가적으로 연결
			- 다른 i-node에는 데이터를 저장한 주소가 저장된 상태
			- `단일 간접 블록`들의 주소를 저장한 블록
		- 4. 이마저도 충분하지 않다면 15번째 주소에 `삼중 간접 블록` 주소 저장
			- 이중 간접 블록들의 주소를 저장한 블록


##### ㅡ [[파티셔닝-파티션-포매팅-포맷\|파티셔닝-파티션-포매팅-포맷]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==파티셔닝, 포매팅==
	- **파티셔닝 작업-과정** =>
		- 메모리 주소공간을 구분하는 내용과 헷갈림 주의
			- 참고노트 : [[메모리-주소체계-주소공간-작동원리\|메모리-주소체계-주소공간-작동원리]]
			- 상황예시
				- **논리주소와 물리주소의 예시:** 
				- 프로그램이 메모리 주소 0x00123456에 데이터를 저장하려고 할 때, 이 주소는 논리 주소
				- 운영체제와 MMU는 이 논리 주소를 실제 물리 메모리 주소로 변환하여 데이터가 실제 메모리 셀에 저장
				- 
		- <span style="background:#d3f8b6">파티셔닝작업-그림이해-이미지</span>
		- 
		- 파티셔닝은 실제 하드웨어 장치의 저장 공간을 **논리적**으로 분할하는 작업을 의미
			- 논리적으로 분할? =>
			- 물리적으로 하드 드라이브를 분할하는 것이 아니라, 하드 드라이브 내의 데이터 **저장 영역**을 여러 개의 독립적인 파티션으로 나누는 것을 의미
		- 이 논리적 분할을 통해 사용자는 각 **파티션**이 마치 별도의 독립된 드라이브처럼 사용될 수 있도록 함
		- 장점/이유
			- **보안과 복구**: 
				- 하나의 디스크를 파티션으로 분리함으로써 하나의 파티션에 문제가 발생해도 다른 파티션에 있는 데이터는 안전하게 보호될 수 있습
			- **효율성**: 
				- 파티션을 사용하면 데이터 관리가 용이해지고, 필요에 따라 특정 파티션만 포맷하거나 변경할 수 있어 시스템 관리가 더욱 유연
			- **조직화**: 
				- 파티션을 통해 드라이브를 여러 구역으로 나누어 각각 다른 용도로 사용 가능 
				- EX)
					- 파티션을 설정한 후에는, 각 파티션에 적합한 파일 시스템을 생성하고 (예: ext4, NTFS 등), 이를 시스템에 마운트하여 실제로 데이터를 저장할 수 있게 됨
					- 
	- **주파티션(Primary Partition)** =>
		- 주 파티션은 디스크에 직접적으로 생성할 수 있는 가장 기본적인 파티션 유형 중 하나
		- 이 파티션은 **독립적으로 부팅** 가능 > 따라서 운영 체제를 설치할 수 있는 파티션으로 주로 사용
			- = 주 파티션은 각각의 파티션이 시스템에 의해 독립적으로 인식됨 > 필요에 따라 각각 다른 운영 체제를 설치하여 다중 부팅 환경을 구성하는 데 유용
		- 개수 제한 존재 
			- 대부분의 디스크 파티셔닝 스키마에서 주 파티션의 수는 최대 네 개로 제한
			- 이를 초과하여 더 많은 파티션을 생성하고 싶다면, 확장 파티션과 논리 파티션을 사용해야 함
		- 사례예시
			- 하나의 하드 드라이브에서 여러 운영 체제를 설치하고 싶은 경우, 각 운영 체제를 별도의 주 파티션에 설치할 수 있음 > 이렇게 하면, 각 운영 체제는 독립적으로 부팅하고 실행될 수 있습
			- 파티션 구성 예시
				- **디스크**: 500GB 하드 드라이브
				- **파티션 1**: 100GB, Windows 설치, 주 파티션
				- **파티션 2**: 150GB, Linux 설치, 주 파티션
				- **파티션 3**: 50GB, 다른 데이터 저장 용도, 주 파티션
				- **파티션 4**: 확장 파티션, 남은 공간 전체를 포함
				    - 내부에 여러 논리 파티션으로 세분화하여 데이터 저장용 등으로 활용
				    - 
		- 독립적으로 부팅? =
			- `독립적으로 부팅 가능`이라는 말은 컴퓨터를 종료한 후 다시 실행할 때, 사용자가 부트 매니저(예: GRUB, Windows Boot Manager)를 통해 여러 설치된 운영 체제 중에서 하나를 선택하여 부팅할 수 있다는 것을 의미
			- 한 번에 하나의 운영 체제만 실행될 수 있으며, 다른 운영 체제로 전환하고 싶다면 컴퓨터를 재부팅해야 하고, 이때 다시 부트 매니저에서 다른 운영 체제를 선택
			- 사용자가 필요에 따라 다른 운영 체제를 선택하여 작업환경을 바꿀 수 있음 > 따라서 이 기능은 하나의 컴퓨터에 여러 운영 체제를 설치하고자 할 때 매우 유용 (작업 요구사항이나 소프트웨어 호환성에 따라 Windows나 Linux 중에서 선택해 부팅할 수 있습)
			- 
	- 하나의 HDD에 어떻게 파티셔닝, 영역이 구획되어 있는지 **직접 확인 가능** =>
		- <span style="background:#d3f8b6">윈도우-디스크관리-파티션-이미지</span>
		- 이미지 요약=>
			- 윈도우 운영체제 검색 :  하드 디스크 파티션 만들기 및 포맷 
			- 디스크 관리 메뉴
			- C /1 / 4 / 5 / 6 파티션 존재 확인 가능
			- 어떠한 파일 시스템 사용 확인 가능
			- 
			- 파티션 테이블?
				- 요약 :  "파티션 테이블을 통해 각 파티션 정보를 확인한다"는 표현 = 윈도우에서 '속성' 메뉴에 들어가서 해당 파티션에 대한 세부 정보를 확인
					- 파티션 테이블은 디스크에 어떤 파티션이 존재하는지에 대한 정보를 저장하는 데이터 표
					- 윈도우의 디스크 관리 도구에서 각 파티션을 우클릭 > `속성` 탭 > 세부정보 확인 가능
					- 디스크 관리 도구에서 파티션의 '속성'을 확인할 때 이 파티션 테이블에서 가져온 데이터를 보는 것
					- 
			- 파티션 정보 : 크기 / 타입 / **시작 및 끝 포인트 정보** 존재 > 각각의 정보는 파티션 관리 및 디스크의 데이터 구조를 이해하는 데 중요한 역할
			- 헷갈림-주의 : 
				- 디스크 관리에서 `파티션 정보` 확인 가능. 하지만 `시작 - 끝 포인트 정보` 확인불가
				- = 디스크 관리 도구는 사용자가 직관적으로 파티션의 포맷, 용량, 상태 등의 정보를 쉽게 확인할 수 있도록 디자인되어 있지만, 파티션의 시작과 끝 위치 같은 좀 더 상세한 정보는 기본적으로 표시되지 않습
				- 왜?
					- 오프셋 정보는 시스템 관리자나 고급 사용자에게만? 필요한 정보이기 때문
					- 이러한 정보는 보다 전문적인 디스크 관리 소프트웨어나 명령줄 유틸리티를 통해 접근할 수 있습
					- = 특정한 관리 도구나 명령어를 통해 접근 가능한 파일이나 디스크의 메타데이터에 해당하며, 일반 사용자보다는 시스템 관리자나 고급 사용자가 필요로 하는 정보
					- 예를 들어, Windows의 `diskpart` 명령어나 Linux의 `fdisk` 같은 명령줄 도구를 사용하여 이러한 정보를 확인
					- 
		- <span style="background:#d3f8b6">윈도우-cmd-예시코드</span>
			- 코드설명 =>
			- `diskpart` 명령어 =  유틸리티 도구 = 프로그램
				- 과정이해
					- 시작 메뉴에서 '명령 프롬프트'를 검색하고, 관리자 권한으로 실행
					- `diskpart` 명령을 입력하여 도구를 시작
					- `list disk`를 입력하여 사용 가능한 디스크 목록을 보고, 관심 있는 디스크 번호를 확인
					- `select disk X` (X는 디스크 번호)를 입력하여 특정 디스크를 선택
					- `list partition`을 입력하여 해당 디스크의 파티션 목록과 함께 각 파티션의 세부 정보를 확인
					- 
				- 오프셋은 `diskpart` 명령어에서 해당 파티션의 데이터가 하드 드라이브 상에서 어디서 시작하는지를 나타내는 정보로, 이는 파티션의 물리적인 위치를 알려줍
				- 오프셋 값은 보통 메가바이트(MB)나 기가바이트(GB) 단위로 표시되며, 이는 디스크의 물리적 배치와 직접적인 관련이 존재
				- 오프셋은 파티션의 시작 지점만을 나타내며, 끝 지점은 오프셋과 파티션 크기를 합산하여 계산
					- EX)
					- 예를 들어, `diskpart`의 출력에서 '파티션 3'의 경우
					- 오프셋은 389 MB에서 시작
					- 크기가 223 GB
					- 따라서 이 파티션의 끝 지점은 시작 오프셋에 파티션의 크기를 더하여 계산
					- 
	- **포매팅 작업-과정** =>
		- "포맷하다"와 "포매팅하다"는 같은 의미
		- 정의/의미/기능
			- 컴퓨터의 저장 매체를 사용할 수 있는 상태로 만들기 위해 데이터 저장 구조를 초기화하는 과정
				- = 드라이브 내에 파일 시스템을 생성하여 파일들이 저장되고 관리될 수 있도록 준비하는 작업을 의미
				- = 어떤 방식으로 파일을 저장-관리할지 결정 후 새로운 데이터를 쓸 준비를 하는 작업
			- 즉, 포매팅하다! = 데이터 저장 구조 초기화, 파일 시스템을 설정, 호환성 확인하다! 의미
			- 
		- 상황예시
			- 새로운 외장 하드 드라이브를 구매했다고 가정
			- 이 드라이브를 처음 사용하기 전에는 일반적으로 포맷하는 과정을 거침
				- + 새 드라이브는 공장에서 포맷되어 나오기는 하지만, 때로는 기본 설정된 파일 시스템이 사용자의 운영체제나 특정 요구와 맞지 않을 수 있습
			- 이 과정에서 사용자는 NTFS, FAT32, exFAT 등 원하는 파일 시스템을 선택하여 포맷할 수 있습
			- 포맷하거나 포매팅하라는 명령을 실행하면, 선택한 파일 시스템에 맞게 드라이브의 저장 구조가 설정


##### ㅡ [[파일시스템-파일단위-이해\|파일시스템-파일단위-이해]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==파일==
	- 메타데이터?=>
		- 파일에 대한 데이터로, 파일을 설명하거나 분류하는 데 사용되는 데이터
			- = 파일에 어떻게 접근/열고/내용을 확인하고/쓰고 등 응용프로그램에 필요한 데이터를 제공
		- 파일의 생성 날짜, 수정 날짜, 파일 크기, 파일 타입 등과 같은 정보 > 이러한 정보들은 파일 시스템에 의해 관리
	- 속성? =>
		- 파일의 메타데이터를 구체적으로 설명하는 항목일 수 있으며, 파일의 보안 설정, 읽기/쓰기 권한, 숨김 상태 등의 정보
		- 파일의 접근 권한, 타임스탬프, 파일 크기와 같은 속성 정보
		- 
	- 파일을 이루는 정보 존재 =>
		- 1. 실제로 파일에 저장된 정보
			- 실질적인 데이터 단위 : 레코드(record) 
		- 2. 파일을 실행하거나 접근하는 데 필요한 **메타데이터** 
		- 3. 부가 정보 = 파일의 **속성**
			- 주의 : 두 용어 사이에는 약간의 차이가 있을 뿐, `파일의 메타데이터`와 `파일 속성`은 서로 밀접하게 연관되어 있으며, 종종 같은 의미로 사용
			- EX) `파일 속성 `/ `파일 메타데이터` >  안에 `파일 크기` 존재
			- 
	- `마우스 우클릭 > 속성` 통해 직접 확인 가능
		- <span style="background:#d3f8b6">파일의 속성-확장자-이미지</span>
		- 이미지 요약 =>
		- 유형 / 크기 / 보호 / 생성날짜 / 마지막 접근 날짜 / 마지막 수정 날짜 / 생성자 / 소유자 / 위치
		- `유형` = `파일 확장자` = `파일 종류`
			- 운영체제에게 해당 파일을 확인하기 위해선 어떠한 프로그램이 필요한지 or 어떠한 프로그램으로부터 생성된 파일인지 알려줌
			- EX) 
				- Microsoft Excel 워크시트(.xlsx)
				- 텍스트 문서(.txt)
				- HTML Document(.html)
				- 실행파일
				- 목적파일
				- 코드파일
				- 워드프로세서 파일
				- 라이브러리 파일
				- 멀티미디어 파일 = 이미지 파일, 동영상 파일
				- 백업 및 보관 파일


##### ㅡ [[파일시스템-폴더-디렉토리구조-이해\|파일시스템-폴더-디렉토리구조-이해]]
- 2. **운영 체제** - 큰 개념
    - 파일 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==폴더(또는 디렉토리)==
	- 용어
		- 최상위 디렉토리 = 루트 디렉토리 
		- 서브 디렉토리
		- 
	- 이러한 파일들을 효율적으로 관리하고 **구조화**하기 위해 사용하는 단위
	- **구조화**하다! = **계층적**으로 관리하다!
		- 구조화? 계층적? =>
		- 단일 계층이 아닌 여러 계층으로 파일 및 폴더를 관리한다면 > `트리 구조 디렉토리` 표현 사용
		-  <span style="background:#d3f8b6">트리구조 디렉토리-이미지</span>
			- 같은 내용-구조-개념을 가지고 있지만 운영체제에 따라서 표기법 다름
			- 리눅스 운영체제 =>
			- `/` 2가지 의미 가짐
				- 1. 루트 디렉토리 위치
				- 2. 디렉토리 간 구분자
				- 
		- <span style="background:#d3f8b6">예시코드1</span>
		- 
	- 디렉토리 엔트리 표현 이해
		- 복기: `폴더는 파일들을 효과적으로 관리하기 위해 사용되는 논리적인 단위`
		- 사용자의 관점에서 보면, 폴더는 파일이 아닌, 파일을 담는 컨테이너로 생각할 수 있습
		- 하지만 운영 체제 관점에서는 디렉토리(폴더)도 파일의 한 형태로 간주합 > 이는 디렉토리가 파일의 메타데이터, 위치, 권한 정보 등을 저장하는 특별한 형태의 파일이기 때문
		- 요약 => 
			- `디렉토리`는 `특별한 정보를 포함한 파일`로 표현 = 구분짓지 않는다
			- 파일 내부에는 `파일과 관련된 정보` 존재
			- 디렉토리 내부에는 `해당 디렉토리에 담겨 있는 파일-대상과 관련된 정보` 존재
			- 
		- 디렉토리 내부 정보는 **테이블 형태 = 표 형태**로 구성
		- 테이블 형태 = 표 형태? =>
			- 즉 디렉토리 테이블-데이터가 존재하기 때문에 구조=계층=위치를 파악 가능 > 접근이 가능해지고 있던 것
			- <span style="background:#d3f8b6">디렉토리테이블-이미지</span>
				- 이미지 설명 =>
				- 각 엔트리(행)에 담기는 정보 존재 = 디렉토리 테이블 존재
					- 대상의 이름 존재
					- 보조기억장치 내 저장된 위치 정보 존재
				- 그림이해
					- home 디렉토리 테이블이 존재 
					- 따라서 minchul 디렉토리 위치 확인 가능 = 접근가능
					- minchul 디렉토리 테이블 존재
					- .... 



---------------

# ㅡ 3. **네트워킹 기초** - 큰 개념


##### ㅡ [[프로토콜-종류\|프로토콜-종류]]
- 3. **네트워킹 기초** - 큰 개념
    - 네트워킹 모델 및 프로토콜
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==프로토콜 종류==
	- TCP (Transmission Control Protocol) =>
		- 네트워크 상에서 서로 다른 컴퓨터/네트워크 장치 간 신뢰성 있게, 순서대로, **오류 없**이 도달하도록 보장 중요한 **규칙**/프로토콜
		- 이는 연결 지향적인 프로토콜로, 데이터 전송 과정에서 데이터의 **순서**와 **무결성**을 관리
		- 
		- 상황예시
			- 웹 페이지를 로드하는 과정을 생각. 이 과정은 사용자가 인지하지 못하는 사이에 자동으로 일어남
				- `즉 내가 하고 있던 행동 내부에선 TCP 프로토콜이 실행되고 있던 것`
			- 사용자가 웹 브라우저에서 특정 웹사이트 주소(URL)를 입력하면, 브라우저는 해당 웹 서버에 TCP를 사용하여 연결을 요청 
			- 
	- IP (Internet Protocol) =>
		- 데이터 패킷이 송신자로부터 수신자까지 올바르게 전송되도록 하는 규칙과 절차를 정의하는 네트워크 통신 프로토콜
		- IPv4나 IPv6 같은 프로토콜은 데이터 패킷이 올바른 목적지로 라우팅되는 방법을 정의
		- IP는 데이터를 목적지까지 전달하는 역할(라우팅)을 하며, 이는 연결을 관리하지 않는 비연결성 프로토콜
		- 
		- 주의 
			- "IP"라는 용어만 보고는 그것이 IP 주소를 의미하는지, 아니면 인터넷 프로토콜 자체를 의미하는지 확실하게 알 수 없음 
			- 다만 IP 주소와 관련된 문장에서는 "주소"라는 단어가 함께 사용
			- 네트워크 프로토콜과 관련된 논의에서는 IP가 프로토콜을 지칭하는 경우가 많음
			- 
		- IP 주소
			- "인터넷 프로토콜 주소(Internet Protocol Address)"를 의미
			- 이는 인터넷과 같은 네트워크 상에서 컴퓨터나 다른 디바이스를 식별하는 데 사용되는 고유 번호 = 장치의 주소
			- 각 장치는 네트워크 내에서 통신할 때 이 IP 주소를 사용하여 식별
			- 
		- 
	- HTTP (Hyper Text Transfer Protocol) 하이퍼텍스트 =>
		- 웹 서버와 웹 브라우저 간에 문서와 데이터를 주고받을 때 사용하는 규칙을 정의
			- = 웹 페이지의 요청과 전송을 관리하는 데 사용
		- 예시이해
			- 요약 : http 주소를 가진 웹사이트는 보안수준이 낮은 사이트다! 라고 표현 가능 > 따라서 **https 프로토콜** 사용!
			- 
			- a 라는 웹 사이트 존재 가정 > 해당 웹 사이트 주소 : `http://www.naver.com/` 가정
			- 해당 주소 의미 : 
				- 해당 웹 사이트는 http 프로토콜 로직을 사용 해 서버와 통신하는 중
				- 해당 프로토콜은 사용자가 입력한 데이터/정보가 **있는 그대로** 서버쪽으로 전송되는 규칙/특징을 가지고 있음
			- 있는 그대로? =>
				- 아이디 : 이건휘, 비번 : 1234 입력  > 그대로 전송됨
				- 따라서 만약 해커가 중간에 데이터를 **스니핑**한다면 사용자의 아이디/비번을 바로 알 수 있음
			- 스니핑(Sniffing) 용어 ? => 
				- 네트워크 트래픽을 모니터링하고 분석하여 정보를 수집하는 해킹 기술
				- 네트워크상에서 전송되는 데이터 패킷을 가로채어 그 내용을 엿보는 행위
		- HTTPS(HyperText Transfer Protocol Secure) 프로토콜? =>
			- 요약 : HTTP주소 <> HTTPS 주소 차이점은 보안수준!
				- 웹 사이트 주소 - `https://`
				- 서버쪽으로 전송되는 데이터가 암호화된 상태로 전송 > 따라서 중간에 강탕하러다로 사용자의 아이디/비번을 바로 확인할 수 없음
			- HTTPS는 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 프로토콜을 사용하여 데이터를 암호화
			- 
	- SSH 프로토콜 "Secure Shell" = 네트워크 프로토콜
		- 다른 컴퓨터 접속? =>
			- 이 기술은 주로 원격 위치의 컴퓨터(클라우드 서버pc)를 관리하거나 파일을 전송하는 데 사용되며, 데이터의 암호화를 통해 보안을 제공
			- 
		- 인터넷이나 네트워크를 통해 **다른 컴퓨터/서버**에 **접속**하고 명령을 실행할 수 있는 통신 규칙 집합
			- = 원격 위치에서 컴퓨터를 관리하거나 파일을 전송할 때 사용
			- 
		- 상황예시
			- AWS에서 EC2 인스턴스를 운영할 때, 관리자나 개발자는 SSH를 사용하여 해당 인스턴스에 안전하게 접속 > 서버의 설정을 변경하거나 업데이트를 설치하고, 필요한 소프트웨어를 관리할 수 있습
			- 서버 관리자는 서버에 **물리적**으로 **접근**하지 않고도 자신의 컴퓨터에서 SSH를 사용하여 원격으로 서버에 로그인 > 컴퓨터를 관리 가능
			- 
		- SSH 데이터 교환 규칙/특징
			- 이 프로토콜은 암호화된 통신 채널을 제공/SSH를 사용하면 데이터가 암호화여 데이터의 기밀성과 무결성을 보장
				- = 데이터 암호화 + 인증 과정 발생! > 접근권한 확인 위함
				- = 네트워크를 통해 데이터를 도청하더라도 정보를 해석할 수 없습
	- ICMP
		- 에코 요청 ? =>
			- '에코 요청을 보낸다'라고 할 때, 이는 '네트워크 장치의 상태를 점검하기 위해 진단 메시지를 보낸다'와 같은 의미로 해석 가능 
				- = 이 메시지(에코요청)는 네트워크의 연결 상태와 해당 장치의 반응 시간을 검사하는 진단용으로 사용 > 이 과정을 통해 해당 서버의 가용성과 응답 시간을 측정하며, 네트워크의 전반적인 성능과 안정성을 평가
		- ㅡ 본문내용
		- 네트워크 연결의 상태를 진단하기 위해 사용됩
		- **에코 요청**은 네트워크상의 다른 장치(이 경우 `www.google.com` 서버)가 도달 가능하고 응답 가능한 상태인지 확인하기 위해 사용


##### ㅡ [[DNS-DHCP-서버이해-웹작동과정\|DNS-DHCP-서버이해-웹작동과정]]
- 3. **네트워킹 기초** - 큰 개념
    - 네트워크의 기본 개념
	    - 네트워크 구성요소
    - 네트워크 주소 지정
- 4. **웹 기술** - 큰 개념
	- 3. **웹 백엔드 기술**
	    - 웹 서버와 웹 어플리케이션 서버
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 사용자 편의성? =>
	- DNS 시스템 덕분에 사용자는 복잡한 IP 주소를 직접 기억하고 입력할 필요 없이, 기억하기 쉬운 도메인 이름을 통해 웹사이트에 쉽게 접근할 수 o
- 와이파이 공유기? =>
	- 가정용 와이파이 공유기는 DHCP 서버의 기능을 내장하고 있습
		- +(서버 기능 내장 = 서버 역할을 수행하도록 하는 SW/프로그램 존재)
	- 즉, 와이파이 공유기 기능 = DHCP 서버 기능
		- 공유기가 네트워크에 연결된 각 장치에 자동으로 IP 주소를 할당하고, 네트워크 설정을 관리하는 역할을 한다는 것을 의미
	- DHCP 서버로서의 와이파이 공유기 예시
		- **네트워크 연결 요청**: 가정에서 새로운 스마트폰, 랩톱, 태블릿 등을 와이파이 네트워크에 연결하려고 할 때, 해당 장치는 네트워크에 액세스하기 위해 IP 주소를 요청
		- **IP 주소 할당**: 와이파이 공유기는 DHCP 서버로서 작동하여 연결 요청을 받고, 사용 가능한 IP 주소 풀에서 IP 주소를 하나 선택하여 요청한 장치에 할당
		- **네트워크 구성 정보 제공**: IP 주소 외에도, DHCP 서버는 네트워크 마스크, 게이트웨이 주소, DNS 서버 주소 등 네트워크 구성에 필요한 추가 정보를 제공
		- **네트워크 접속 완료**: 할당받은 IP 주소와 네트워크 설정을 사용하여 장치는 인터넷이나 로컬 네트워크의 다른 장치와 통신할 수 있게 됩
- ㅡㅡㅡㅡ 본문 내용
	- **DHCP(Dynamic Host Configuration Protocol) 서버** =>
		- 의미/기능
			- 네트워크에 새로운 장치가 연결될 때 이 장치에 IP 주소를 자동으로 할당하는 역할 > DHCP 서버의 작용은 사용자 PC가 네트워크에 처음 연결되는 순간, 즉 네트워크 초기화 단계에서 발생
			- 
		- 복기 : `서버용어 - 관점에 따른 용어 ` / 기존기록 확인 / 네트워크
		- 따라서 와이파이 공유기도 내장 소프트웨어를 통해 DHCP 서버로 기능할 수 있습
		- EX) 
			- **와이파이 공유기**는 일반적으로 DHCP(Dynamic Host Configuration Protocol) 서버로 설정되어, 네트워크에 연결된 각 장치에 자동으로 IP 주소를 할당합
			- 이와 같이, 공유기는 단순한 라우팅 기능을 넘어 다양한 네트워크 관리 기능을 수행할 수 있는 서버 역할 수행
			- 
	- **도메인 서버(DNS : Domain Name Server)** =>
		- <span style="background:#d3f8b6">DNS서버-도메인서버-작동과정-이미지</span>
		- DNS 서버는 'naver.com'이라는 도메인 이름을 해당하는 IP 주소로 변환하는 역할 > DNS는 인터넷 사용의 **편의성**을 크게 향상
		- 
	- DHCP와 DNS 서버의 역할을 포함하여 클라이언트PC<>서버PC 사이에 발생하는 **웹 페이지 로딩 과정/프로세스** =>
		- 전체과정 요약 : `사용자 PC <> DHCP 서버(IP 주소 할당) → 웹 브라우저 <> DNS 서버 → 사용자PC-웹 브라우저-HTTP요청 <> 웹 서버(요청에 대한 응답) → 웹 브라우저(콘텐츠 렌더링)`
		- 
		- **네트워크 시작 및 IP 주소 할당** =>
			-   1. 
				- 사용자의 PC가 부팅되며 네트워크에 연결을 시도 > 이때, PC는 네트워크 상에서 통신을 위해 IP 주소가 필요
			  - 2. 
				  - 사용자의 PC는 DHCP 서버에 IP 주소 할당을 요청
				  - DHCP 서버는 사용 가능한 IP 주소를 제공하고, PC는 할당받은 IP 주소를 사용하여 네트워크에 연결
				  - 
		- **웹 페이지 요청 및 로딩 과정**
			- 1.
				- 사용자가 웹 브라우저의 주소창에 'naver.com'과 같은 웹사이트 주소를 입력
				- 입력된 주소는 먼저 DNS 서버로 전송되어 IP 주소로 변환
			-   2. 
				- DNS 서버는 'naver.com' 도메인 이름에 해당하는 IP 주소를 찾아 웹 브라우저에게 응답
				- 이 과정은 인터넷 사용의 편의성을 크게 향상
			- 3. 
				- 브라우저는 DNS로부터 받은 IP 주소를 사용하여 해당 웹 서버에 HTTP 요청을 전송
				- 이 요청은 웹 서버와 직접적으로 이루어집
			- 4. 
				- 웹 서버는 요청받은 데이터를 처리하고, 웹 페이지나 다른 리소스를 HTTP 응답으로 브라우저에 전송
			-   5. 
				- 브라우저는 서버로부터 받은 응답 데이터를 분석하고, 화면에 웹 페이지를 렌더링
				- 이 과정은 사용자에게 시각적으로 인터페이스를 제공함으로써 인터넷 서핑을 가능하게 함



##### ㅡ [[패킷-데이터전송-담는단위-정보요소\|패킷-데이터전송-담는단위-정보요소]]
- 3. **네트워킹 기초** - 큰 개념
    - 네트워크 통신 및 보안
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==패킷==
	- 헷갈림-주의
		- `쿠키`와 다름
		- 둘 다 '작은 데이터 조각'이라는 점에서 비슷하게 느껴질 수 있음
		- 
		- 패킷 :  네트워크의 데이터 전송 메커니즘의 데이터를 (담는) 단위 (패킷 단위 안에 다양한 데이터 존재)
		- 쿠키 : 웹 상의 사용자 세션 정보를 유지하는 데 사용되는 실제 데이터 조각/정보 파일/텍스트 파일
	- 배경이해
		- 인터넷이나 다른 네트워크에서 정보를 교환할 때, 전송할 데이터는 여러 개의 작은 부분, 즉 '패킷'으로 나누어져 이동-교환됨
	- 의미/기능
		- 패킷은 네트워크 통신의 기본 (데이터 교환/전송)단위 > 따라서 네트워크의 성능과 안정성을 진단하는 데 중요한 역할
		- 패킷은 네트워크를 통해 전송되는 데이터의 작은 조각(이면서 동시에 담는 단위)
		- 각 패킷은 전송할 정보의 일부분을 담고 있음 > 각 패킷은 네트워크 상의 다른 노드로 독립적으로 전송되며, 최종 목적지에서 다시 조립
			- + 이 과정/매커니즘은 네트워크의 효율성과 데이터 손실 최소화에 기여
			- 
	- 패킷 용어 비유 이해1
		- 연필 한 다스 = 연필 묶음/개수 단위 
			- 1다스 = (묶음 단위에는 연필이) 12개 
			- 12개 = 1번 연필/ 2번연필 / 3번 연필....
		- 패킷= 데이터 전송의 기본 단위
			- 패킷 내에 포함되는 각 정보를 연필 다스의 각 연필로 비유한다면, 각 연필이 **패킷 내의 다양한 정보 요소**(예: 헤더, 페이로드, 트레일러 등)로 볼 수 있습
	- 패킷 내의 다양한 정보 요소? =>
		- 메타데이터? =>
			- 출발지 주소(Source Address): 패킷을 보내는 장치의 주소
			- 목적지 주소(Destination Address): 패킷이 도착해야 할 장치의 주소
			- 프로토콜(Protocol): 데이터를 어떻게 처리할지 결정하는 데 사용되는 프로토콜 정보
			- 순서 번호(Sequence Number): 여러 패킷으로 나뉘어 전송되는 데이터를 올바른 순서로 재조립하기 위해 사용되는 번호
		- ㅡㅡㅡㅡ본문내용
		- **헤더(Header):** 
			- 패킷의 시작부분('머리' 부분)에 위치하며, 패킷을 올바르게 전송하고 처리하기 위한 제어 정보와 **메타데이터**를 포함 (각 연필에 적힌 브랜드나 강도 등의 정보에 비유)
		- **페이로드(Payload):** 
			- 사용자가 실제로 전송하고자 하는 데이터를 담고 있는 부분 (연필 다스에서 연필을 담고 있는 상자)
				- + 전송하고자 하는 데이터?
					- 이 부분은 이메일의 본문, 웹 페이지의 HTML 코드, 파일의 내용 등 실제로 교환하고자 하는 데이터
			- 헤더 다음에 위치하며, 패킷의 '몸통'에 해당
		- **트레일러(Trailer):** 
			- 일부 네트워크 프로토콜에서 사용되며, 패킷의 끝부분에 위치
			- 주로 데이터의 무결성을 검증하는 데 사용되는 정보(예: **체크섬**)를 포함할 수 있습 (연필 다스 포장의 봉인 스티커나 검사 표시에 비유)
				- + 체크섬(Checksum): 패킷의 무결성을 확인하기 위한 값 > 수신측에서는 이 값을 사용하여 패킷의 오류를 검출할 수 있습


##### ㅡ [[티켓용어-이해-오류로그\|티켓용어-이해-오류로그]]
- **네트워크 통신 및 보안**
	- 특정 테크니컬 이슈 또는 문제에 대한 핸들링과 관련된 키워드를 포함
		- 시스템 운영이나 문제 해결 과정에서 발생하는 일련의 프로세스를 추적하는 데 사용되는 요소
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 티켓 용어(Ticket)
	- 다양한 데이터? = 다양한 기능?
		- **문제 기록 = 다양한 데이터 기록** 
			- 문제의 발생 시간, 우선순위, 담당자 ,상세 설명, 영향을 받은 시스템 등을 기록
		- **추적 및 관리**:
			- 문제 해결 과정을 기록-추적하고, 각 단계의 진행 상황을 기록-관리
		-  **협업 지원**:
			- 문제 해결을 위해 해당 기록을 팀원 간의 협업과 커뮤니케이션 시 사용
		- **우선순위 설정**:
			- 문제의 심각도와 긴급성을 기반으로 우선순위를 설정
		- **보고 및 분석**:
			- 해결된 티켓을 분석하여 향후 유사한 문제가 발생하지 않도록 예방 조치를 계획
		- 상황예시
			- 문제 기록 : 
				- 고객이 서버 다운 문제를 보고하면 티켓이 생성됩 > 티켓에는 문제 발생 시간, 상세 설명, 영향을 받은 시스템 등이 기록됩
			- 추적 및 관리 : 
				- IT 팀은 티켓을 통해 문제 해결 과정을 추적하고, 각 단계의 진행 상황을 관리
			- 협업 지원: 
				- 문제 해결을 위해 팀원들이 티켓을 통해 소통하고, 필요한 정보를 공유
			- 우선순위 설정: 
				- 문제의 심각도와 긴급성에 따라 티켓의 우선순위가 설정됩
			- 보고 및 분석: 
				- 문제가 해결된 후, 티켓 데이터를 분석하여 향후 유사한 문제가 발생하지 않도록 예방 조치를 계획
	- ㅡㅡㅡㅡ본문내용
	- 의미 차이 주의
		- 오류 로그(Error Log) 
			- 시스템이나 애플리케이션에서 발생한 오류를 기록한 파일이나 데이터(주로 기술적인 세부 사항을 포함) > 따라서 문제의 원인을 진단하는 데 사용
		- 티켓이라는 용어가 디지털 기록이라는 점에서는 오류 로그와 비슷, 하지만 오류 로그 이상의 **기능**을 포함
			- + 기능
			- 해당 문맥에서 기능이라는 의미 : 더 광범위한/더 다양한 상황에서 두루두루 사용된다는 것.
	- 티켓은 **다양한 데이터**가 기록된 파일이나 데이터임 > 따라서 협업과 커뮤니케이션 시 사용 됨
		- = 문제가 발생했을 때 이를 추적하고 해결하는 과정을 관리하기 위한 디지털 기록
		- = 티켓은 단순한 기록 이상의 역할
		- > 따라서 티켓은 문제 해결을 효율적으로 관리해줌 = 문제를 추적하고 해결


##### ㅡ [[Incident프로세스-SLA기반티켓관리-이해\|Incident프로세스-SLA기반티켓관리-이해]]
- 3. **네트워킹 기초** - 큰 개념
    - **네트워크 통신 및 보안**
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- Incident 프로세스
	- **정의**: 
		- IT 서비스 관리에서 발생하는 모든 유형의 문제(Incident)를 **식별**하고, **기록**하고, **해결**하는 전체 과정을 포괄
	- 이 과정은 문제가 발생했을 때 신속하고 효율적으로 대응하여 서비스의 정상 운영을 복구하는 것을 목표
- 해당 프로세스 상황예시
	- 서버 다운 문제 발생 가정 : 데이터센터의 서버가 예기치 않게 다운
	- 문제 식별 및 보고: 
		- 시스템 모니터링 도구가 서버 다운을 감지하고, 자동으로 Incident 티켓을 생성
	- 우선순위 설정: 
		- 다운된 서버가 중요한 웹 애플리케이션을 호스팅하고 있어, Incident의 우선순위가 높게 설정
	- 조사 및 진단: 
		- IT 팀이 로그 파일을 분석하여 문제의 원인을 파악
		- 예를 들어, 하드웨어 고장으로 인한 서버 다운임을 확인
	- 해결 및 복구: 
		- IT 팀이 고장난 하드웨어를 교체하고 서버를 재부팅하여 정상 운영을 복구
	- 문서화 및 사후 검토: 
		- 해결 과정을 문서화하고, 유사한 문제가 발생하지 않도록 예방 조치를 계획
- SLA(Service-Level Agreement) 기반 티켓 관리
	- 정의: 
		- 서비스 제공업체와 고객 간의 서비스 수준 협약(SLA)을 준수하면서 문제를 해결하는 프로세스
		- SLA : 
			- 고객이 공급업체로부터 기대하는 서비스 수준을 기술한 문서 = 해당 서비스의 성과를 측정하는 기준과 합의된 서비스 수준을 달성하지 못할 경우 구제책이나 불이익 등을 함께 명시한 체계적인 계약서
			- 응답 시간, 해결 시간, 가용성 등 서비스 수준을 정의
	- 해당 프로세스 상황예시
		- 네트워크 성능 저하 문제: 고객이 네트워크 속도 저하를 보고
		- 티켓 생성 및 응답 시간
			- 고객의 문제 보고 후, SLA에 명시된 대로 15분 내에 응답해야 합 > 티켓 시스템이 자동으로 티켓을 생성하고, 담당자에게 알림을 보냅
		- 해결 시간 관리
			- SLA에 따라 2시간 내에 문제를 해결해야 합 > 네트워크 팀이 즉시 문제를 조사하고, 네트워크 장비를 점검하여 속도 저하의 원인을 파악
		- 문제 해결: 
			- 네트워크 장비의 설정 오류를 수정하여 속도 저하 문제를 해결
		- 문서화 및 보고: 
			- 해결 과정을 문서화하고, 고객에게 해결 상황을 보고 > SLA 준수 여부를 기록
- 차이점 요약
	- : `Incident 프로세스와 SLA 기반 티켓 관리는 모두 문제 발생 시 이를 처리하는 과정을 의미하지만, Incident 프로세스는 모든 유형의 문제를 포괄적으로 다루고, SLA 기반 티켓 관리는 SLA 기준에 따라 문제를 처리하는 데 중점`
	- 범위:
		- Incident 프로세스: 모든 유형의 문제를 포괄적으로 처리 > 문제의 신속한 해결과 서비스 복구 중점
		- SLA 기반 티켓 관리: SLA에 명시된 기준에 따라 문제를 처리 > SLA 준수를 통한 서비스 품질 유지+문제해결 중점
	- > 따라서 SLA에 명시된 기준에 따라 문제를 식별하고 처리하기 때문에, Incident 프로세스에서는 문제로 인식될 상황이 SLA 기반 티켓 관리에서는 문제로 인식되지 않을 수 있습
		- 예시 1: SLA 기준 내의 응답 시간
			- Incident 프로세스: 시스템 응답 시간이 1초에서 2초로 증가한 상황을 문제로 인식하여 처리할 수 있습
			- SLA 기반 티켓 관리: SLA에서 3초 이하의 응답 시간이 허용된 경우, 1초에서 2초로 증가한 상황을 문제로 인식하지 않을 수 있습


---
# ㅡ 4. **웹 기술** - 큰 개념

##### ㅡ [[개발환경-코드편집기\|개발환경-코드편집기]]
- 1. 웹의 기본 개념
	- 프로그래밍과 코드 편집, 그리고 개발 도구 - 웹 개발과 관련하여 백엔드나 프론트엔드 개발에 필요한 도구와 환경을 설정
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 개발환경=프로그램=코드편집기 다양한 형태
- 공통점 : 코드를 작성 > 편집이 가능한 환경 제공하는 프로그램
	- (파이썬 인터프리터) **온라인 서비스**
		- 파이썬 코드작성 로컬에 설치x 가능
		- EX) 구글 코랩(colab) , Repl.it
	- **텍스트편집기** 방식 = 텍스트에디터
		- EX) atom, `vi`, `vim`
		- 특징 : `에디터프로그램=IDE`보다 상대적으로 가벼움 > 코드 편집에 중점
	- **통합개발환경=IDE 방식=코드 에디터 프로그램**
		- EX) VS코드
			- GUI기반 코드 에디터 프로그램
		- 특징 : `텍스트편집기`보다 무거움 
			- 당연 > 코드 편집 기능 이외 추가적인 다양한 기능을 제공 
			- 디버깅, 빌드, 프로젝트 관리, 자동 완성, 코드 분석 
	- **대화형 개발환경 프로그램** 
		- EX) 주피터노트북=주피터=노트북
		- 특징
			- 대화형 :  "코드 실행 > 결과 바로 확인 가능"

##### ㅡ [[웹페이지-이해-이미지\|웹페이지-이해-이미지]]
- 4. **웹 기술** - 큰 개념
	- 1. 웹의 기본 개념
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:#d3f8b6">사람화면-컴퓨터화면-이미지</span>

##### ㅡ [[웹브라우저-쿠키-작동과정-이해\|웹브라우저-쿠키-작동과정-이해]]
- 1. 웹의 기본 개념
    - 웹 표준과 프로토콜 (HTTP, HTTPS)
	    - 쿠키
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==쿠키(cookie) 기술/용어 존재==
	- **의미/특징/장점/단점**
		- 쿠키는 인터넷 사용자가 어떤 웹사이트를 방문할때 사용자의 컴퓨터에 설치되는 작은 기록 정보파일로서, 쿠키에 담긴 정보는 사용자가 같은 웹사이트를 방문할 때 마다 읽히고 수시로 새로운 정보로 바뀐다.
		- 작은 기록 정보 파일 = 텍스트 파일 = 사용자/개인정보를 **식별**할 수 있는 기술
		- 식별? =>
			- 서버는 쿠키에 포함된 정보를 통해 사용자가 이전에 인증받은 것을 확인하고, 다시 로그인할 필요 없이 서비스를 이용할 수 있도록 함
			- 쿠키-기술 덕분에 웹사이트는 사용자의 로그인 상태를 유지할 수 있으며, 이는 사용자 경험을 크게 향상
				- = 이를 통해 사용자가 웹사이트에 다시 방문하거나 페이지를 이동해도 이전의 상태(예: 로그인 상태, 장바구니 내용 등)를 기억하여 더 편리한 웹 서핑 경험을 제공
				- 
			- 따라서 쿠키 기술이 없었을 때, 이는 서버가 요청을 받을 때마다 각 요청을 독립적인 것으로 처리하며, 이는 이전의 요청이나 사용자의 상태 정보를 기억하지 못한다는 의미 > 따라서, 사용자가 누구인지, 이전에 어떤 요청을 했는지 등의 정보를 서버가 유지할 수 없었습
			- 이해예시
				- `온라인 쇼핑을 할 때 사용자가 장바구니에 상품을 추가해도, 페이지를 전환할 때마다 그 상태가 유지되지 않아 장바구니에 상품이 남아있지 않는 문제가 발생`
		- 단점
			- 쿠키에 저장되는 정보들을 통해 사생활 침해 가능성 존재
			- 쿠키를 보완/개선 > Google의 FLoC 기술 개발 = 사용자의 프라이버시 보호 + 효율적인 광고 타겟팅을 가능
			- 
	- **쿠키 사용 과정-예시** =>
		- <span style="background:#d3f8b6">웹브라우저-쿠키-작동과정-이미지</span>
		- 이미지 요약 =>
		- 1. 클라이언트 PC 서버에 요청
			- + 
			- 헷갈림 주의
				- 사용자가 PC에서 크롬 브라우저 아이콘을 클릭하여 브라우저를 실행하는 것은 서버에 직접 요청을 보내는 행위가 x. 이는 단지 로컬 컴퓨터 상에서 브라우저를 시작하는 행위일 뿐
				- `ㅡ 이해 ㅇ : 잘 못 알고 있었음. 처음 브라우저를 클릭하는 행위는 서버에 요청을 보내는 행위 x `
		- 2. 서버에서 쿠기 생성
		- 3. 서버에서 요청에 대한 응답 값을 보내면서 쿠기도 같이 보냄
		- 4. 클라이언트 쪽에서 쿠키파일 보관 진행
			- + 
			- 사용자의 웹 브라우저에 의해 저장되고 관리
			- 쿠키가 웹 브라우저에 어떻게 저장되고 있는지 직접 확인 가능 =>
				- 크롬 브라우저
				- f12 = 개발자도구/메뉴
				- 상단메뉴
				- Application 탭
				- Storage
				- cookies 탭 존재
					- 클릭 할 때마다 생성되는 것을 확인 가능
					- 
			- 쿠키 사용 예시 =>
				- 구글 크롬
				- 계정확인 
				- 개인정보 보호 및 맟춤설정 메뉴 존재
				- 광고설정 메뉴 존재
		- 5. 이후 해당 서버에 요청을 보낼 떄 같이 보냄
			- + 
			- `비유 이해 : a라는 사람이 방금전 이 웹사이트 요청을 보냈었어 = 방문 했었음!!`
			- 웹 브라우저에서 쿠키는 사용자의 로그인 정보(일반적으로 사용자 ID나 세션 ID)를 저장 > 사용자가 해당 웹사이트에 다시 방문할 때, 웹 브라우저는 저장된 쿠키와 함께 웹 사이트의 서버에 요청을 전송
		- 6. 서버는 쿠키파일 확인 후 사용자 식별 진행 > 생략할 건 생략하고 응답 


##### ㅡ [[인코딩-디코딩-유니코드\|인코딩-디코딩-유니코드]]
- 4. **웹 기술** - 큰 개념
	- 1. 웹의 기본 개념
	    - 웹 표준과 프로토콜 (HTTP, HTTPS)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 데이터가 컴퓨터에 저장될 때, 컴퓨터에서 출력될 때 특정 형식으로 변환하는 과정 
- 1. **인코딩 - Encoding** =>
	- 사용자 > 컴퓨터 
	- 특정 데이터를 컴퓨터에서 사용 가능한 형태로 변환하는 과정
	- EX)
		- 사람이 이해할 수 있는 형태(텍스트 데이터) > 컴퓨터가 이해할 수 있는 형태로 변환
		- 유니코드(Unicode) 인코딩
			- 문자/이미지/오디오 파일 > 숫자 매핑/변환
				- 
	- 다양한 인코딩 방식 = 데이터 변환 방식
		- <span style="background:#d3f8b6">텍스트 데이터 인코딩 방식</span>
			- ASCII
			- UTF-8
			- UTF-16
			- UTF-32
			- cp949
			- 
- 2. **디코딩 - Decoding** =>
	- 컴퓨터 > 사용자 
	- 컴퓨터가 이해할 수 있는 형태 > 사용자가 이해할 수 있는 형태 변환
	- EX) 
		- 유니코드(Unicode) 디코딩
			- 숫자형태 > 문자형태

### ㅡ 3. 웹 백엔드


##### ㅡ [[라우팅-라우트-매커니즘-용어\|라우팅-라우트-매커니즘-용어]]
- 4. **웹 기술** - 큰 개념
	- 3. **웹 백엔드 기술**
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 웹 애플리케이션
	- 라우팅(Routing) 용어
		- 요약 : 과정을 의미
		- 웹 서버가 클라이언트로부터 받은 요청을 어떻게 처리할지 결정하는 전체적인 프로세스를 의미
		- 라우팅은 클라이언트의 요청을 분석하고 해당 요청을 처리할 적절한 핸들러나 함수에 전달하는 과정을 포함
		- 
	- 라우트(Route) 용어 
		- 요약 : 과정속에 존재하는 구체적인 경로/지점/규칙 의미
		- 라우트는 라우팅 프로세스 중에 설정된 개별적인 경로를 의미
			- = 각 라우트는 특정 요청 URL >  그 요청을 처리할 함수를 연결하는 규칙이나 경로를 정의
		- 즉, 특정 요청을 어떻게 처리할지에 대한 구체적인 규칙
		- 
	- 상황예시
		- 클라이언트  : 특정 페이지/데이터 요청
		- 웹 서버 : 요청받은 데이터 분석 > 요청 처리/응답
		- 즉 웹 서버에는 요청을 처리하는 로직/함수 존재
		- 이러한 `요청로직 <> 처리로직`을 연결하는 매커니즘/구조를 라우트! 표현 사용
		- 
	- 예시
		- 요약 : 특정 URL이 호출될 때 실행될 함수를 지정
		- Flask 웹 프레임워크에서는 `@app.route()` 데코레이터(표현식-함수)를 사용하여 **특정 경로/요청**와 **함수(요청 처리 로직)** 를 연결하는 방식으로 라우트를 정의
		- 이는 전체 라우팅 과정의 일부
		- 
- 매커니즘 용어
	- 특정 기능이나 작업이 어떠한 과정을 거쳐 작동, 완성되는지 설명하는데 사용
	- '특정 목적을 달성하기 위해 필요한 일련의 개념 / 단계적인 방법 / 과정별 절차 / 내용 등 포괄하는 용어
	- 
	- ex) 라우팅 매커니즘
		- 시스템이 어떻게 작동, 어떤 단계를 거쳐 최종 결과에 도달하는지 설명
	- ex) 빵 만들기 매커니즘
		- 빵 만들기는 단계적인 절차/과정 존재
		- 원료 투입 > 반죽 혼합 > 발효 > 굽기 > 빵 꺼내기 



##### ㅡ [[서버유형-서버의미-호스팅-배포\|서버유형-서버의미-호스팅-배포]]
- 3. **웹 백엔드 기술**
    - 웹 서버와 웹 어플리케이션 서버
	   - 애플리케이션 서버의 역할과 종류
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 요약 : 
	- 컴퓨터를 서버로 활용하는 경우, 서버의 역할은 주로 세 가지로 구분됨
		- 웹 서버, 애플리케이션 서버, 데이터베이스 서버
	- 여기서 말하는 **서버** 용어는 2가지 의미를 가짐
		- 소프트웨어(서버측 프로그램)
		- 물리적 컴퓨터(서버용 PC) = 하드웨어
	- 소규모 환경에서는 이 세 가지 서버(소프트웨어 의미)기능을 한 대의 컴퓨터에서 실행하는 것이 가능하지만, 대규모 환경에서는 각 기능을 별도의 컴퓨터에서 운영하여 더 높은 효율과 안정성을 달성할 수 있음
	- ㅡㅡㅡㅡ
	- **서버 유형**
		- 웹 서버와 애플리케이션 서버 서로 다른 수준의 요청받은 로직을 처리하는 복잡도를 가질 뿐 결국 사용자의 요청에 따른 적절한 데이터를 제공하는 공통된 기능을 수행
		- 
		- 1. 웹서버
			- 정적 파일 서핑, 간단한 서버 사이드 스크립트 처리
			- 웹 서버는 HTTP를 통해 웹 페이지나 파일을 클라이언트에 제공
			- ex) 
				- 사용자가 웹 브라우저를 통해 특정 웹 페이지를 요청할 때, 웹 서버는 해당 HTML 파일, CSS 스타일시트, JavaScript 파일 등을 찾아 사용자에게 전송
				- 
		- 2. 애플리케이션 서버
			- 웹 서버보다 복잡한 비즈니스 로직 처리 = 클라이언트의 요청에 따라 동적인 콘텐츠를 생성하고 제공
			- ex)
				- 온라인 쇼핑몰에서 사용자가 주문을 하면, 애플리케이션 서버는 사용자의 주문 정보를 처리하고, 재고를 확인하고, 결제를 처리하고, 주문 상태를 업데이트하는 등 여러 단계의 처리 작업을 수행
				- 
		- 3. 데이터베이스 서버
			- 데이터의 저장, 검색, 수정 등을 관리하며, 클라이언트 또는 다른 서버의 데이터 요청에 응답
			- 
	- **호스팅 용어**
		- 로컬환경에 있는 것을 온라인(웹 서버)에 공개 > 외부 사용자들이 접근할 수 있도록 하는 서비스/기능 의미
		- 해당 서비스를 이용 시 웹 서버는 저장된 데이터(콘텐츠, 코드파일-프로그램)를 관리 + 요청에 따른 응답
	- **배포 용어**
		- 완성된 프로그램을 호스팅 서비스를 이용해 외부 사용자가 접근 가능하게 하는 과정 자체를 의미.


##### ㅡ [[워드프레스-프로그램-이해\|워드프레스-프로그램-이해]]
- 4. **웹 기술** - 큰 개념
	- 3. **웹 백엔드 기술**
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==Wordpress-워드프레스==
	- 실행환경? =>
		- 이란 WordPress를 구동하기 위해 필요한 소프트웨어 구성요소들을 의미
		- WordPress를 효과적으로 구축하고 운영하기 위해서는 LAMP 환경이 일반적으로 사용
	- ㅡㅡㅡㅡ본문내용
	- **배경설명**
		- WordPress를 이용해 블로그를 구축하려 할 때, WordPress가 원활하게 동작하기 위해 필요한 **실행 환경**을 구축해야 함
	- **어떤 프로그램**?
		- 사용자가 웹사이트의 콘텐츠를 쉽게 생성, 편집, 관리, 사용자와 상호작용 할 수 있도록 다양한 기능을 제공
			- = CMS의 핵심 기능은 사용자가 웹 개발 지식이 많지 않아도 웹사이트를 효과적으로 관리하고 업데이트할 수 있게 해주는 것
		- 즉, 워드프레스는 단순한 디자인 도구를 넘어서, **콘텐츠 관리 시스템(CMS)**  = 복합적인 플랫폼
	- **워드프레스(CMS) 다양한 기능**
		- 사용자가 콘텐츠를 쉽게 추가하고, 수정하며, 관리할 수 있는 **인터페이스**를 **제공** (이 모든 것은 데이터베이스와의 상호작용을 통해 이루어짐)
		- 1. 콘텐츠 게시
			- 사용자는 워드프레스의 관리 **대시보드**를 통해 글을 작성하고, 이미지를 추가하며, 페이지를 생성할 수 있습
				- = 사용자와의 상호작용을 위한 클라이언트 측에서는 **웹 기반의 인터페이스**를 제공
		- 2. 테마와 플러그인, SEO 최적화
			- 사용자는 다양한 테마를 선택하여 사이트의 외관을 변경할 수 있고, 플러그인을 이용해 기능을 확장할 수 있음
				- + 워드프레스는 '**템플릿**'이라는 형태로 사전에 디자인된 웹사이트 구조를 제공 > 사용자는 이 **테마**를 선택하여 웹사이트의 외관을 손쉽게 설정
			- 검색 엔진 최적화(SEO)를 위한 다양한 도구와 플러그인을 제공합
		- 3. 사용자 상호작용
			- 워드프레스는 댓글, 검색, 사용자 등록과 같은 기능을 통해 방문자와의 상호작용을 지원
	- **특징**
		- 워드프레스는 웹 기반의 콘텐츠 관리 시스템(CMS)으로, 웹 서버에 설치되어야 함 + 웹 호스팅 서비스 필요
		- 왜?
			- 요약 : 워드프레스가 동작하기 위해 필요한 구성 요소들은 웹 서버 환경에서 실행되기 떄문
			- = 워드프레스는 웹 서버 소프트웨어(예: 아파치, Nginx)와 데이터베이스 서버와 긴밀하게 상호작용하면서 작동
				- + 어떻게 상호작용?  : 웹 서버는 워드프레스의 PHP 파일을 해석>실행>처리하고, 워드프레스는 데이터베이스 서버에 콘텐츠를 저장하고 검색함
				- 
				- 복기 : `워드프레스(CMS) 다양한 기능`
				- 워드프레스가 제공하는 기능들이 실시간으로 동작 되야함/제공 되야함
				- 해당 프로그램은 웹 서버에서 실행되는 PHP 언어로 작성되었고, 해당 프로그램이 제공하는 기능인 `콘텐츠 게시=데이터 관리`를 위해선  MySQL이나 MariaDB 같은 데이터베이스를 사용해야 하기 때문/접근이 가능해야 함
				- 
	- 워드프레스를 이용해 웹사이트나 블로그를 운영하는 **대략적인 프로세스**
		- 웹 호스팅 서비스 선택
			- 워드프레스를 설치하려면 웹 호스팅 계정이 필요
		- 워드프레스(프로그램) 설치
		- 테마 선택
			- 워드프레스는 다양한 무료 및 유료 테마를 제공
		- 플러그인 추가
			- 추가 기능을  웹사이트에 추가하려면 워드프레스 플러그인을 설치
			- 
	- **WP 프로그램 두가지 형태 존재**
		- 1. WordPress.com을 이용하는 경우
			- 웹 호스팅 서비스? =>
				- 웹 서버를 포함하여 웹사이트의 호스팅에 필요한 다양한 서비스와 기술을 제공하는 서비스
			- 서브-메인 도메인 주소 =>
				- 서브 도메인(Subdomain)
					- 서브 도메인 부분 = 호스트 이름 표현 가능
					- 호스트 이름은 네트워크상에서 컴퓨터나 서비스를 식별하는 데 사용되는 이름
					- 도메인 이름 시스템(DNS)에서 호스트 이름/서브 도메인(`yourblog`)은 해당 메인 도메인 내에서 구분되는 특정 섹션 또는 페이지를 가리킴. 보통 URL에서 가장 왼쪽에 위치
				- 메인 도메인(Main Domain)
					- 메인 도메인(`tistory.com`)은 티스토리 웹사이트의 주 도메인을 나타냄
				- 예시
					- `yourblog.tistory.com` 주소
					- `yourblog`는 사용자가 자신의 블로그를 개별적으로 식별할 수 있게 해주는 **서브 도메인 부분**이고, `tistory.com`은 모든 사용자가 공유하는 **메인 도메인** 부분
					- 티스토리에서 각 사용자는 자신만의 고유한 서브 도메인을 가지며, 이는 모두 같은 메인 도메인(`tistory.com`) 아래에 위치
			- ㅡㅡㅡㅡ본문내용
			- 프로그램과 **호스팅 서비스**까지 사용한다는 의미 (사용 편의성을 제공) > 따라서 도매인 구매 - 연결 - 호스팅 서버 구매 과정 x 
			- 기본적으로 제공되는 **무료 도메인**은 사용자의 사이트 주소가 'yourwebsite.wordpress.com' 형식을 갖게 됩 > 이는 WordPress.com의 도메인을 사용한다는 것을 의미 
			- 유료 플랜을 이용하면 사용자 정의 도메인 이름(예: 'yourwebsite.com')을 사용할 수 있습
				- 요약 =>
				- 무료 도메인 사용 시 wordpress.com 도메인 이름 사용
				- 유료 플랜 사용 시 wordpress.com 도메인 사용할 필요 x 
		- 2. WordPress.org를 사용 경우 
			- 자체 호스팅/직접 관리? =>
				- 요약 : `지금까지 해온 작업들이 워드프레스를 설치하고 호스팅하기 위함임. ( AWS EC2 인스턴스 생성 등등등)`
					- WordPress.org 자체는 단지 소프트웨어이며, 사용자는 워드프레스 소프트웨어를 직접 자신의 호스팅 계정/서버에 설치 필요
					- 자신이 직접 도메인 구매 + 도메인 연결/등록 + 호스팅용 서버 설치  및 환경 구성
			- ㅡㅡㅡㅡ본문내용
			- 워드프레스 프로그램만 사용! 의미 
				- = '**자체 호스팅/직접 관리**' 워드프레스
			- 자유와 유연성을 얻을 수 있지만, 직접 도메인 구매 및 호스팅 관리 필요
			- WP 자체 호스팅 서비스를 사용하지 않았기 때문에 웹사이트 주소에 'wordpress.com'이 반드시 포함될 필요 x 




----
# ㅡ 5. **데이터베이스 시스템** - 큰 개념


##### ㅡ [[데이터분류-구조-형식-규모\|데이터분류-구조-형식-규모]]
- 5. **데이터베이스 시스템** - 큰 개념
	- 데이터의 기본 개념
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==데이터 분류==
	- **구조와 형식에 따라 분류 가능 (가장 주된 분류 방식)**
		- 1. 정형 데이터 (Structured Date) = 조화된 데이터
			- 분석에 사용할 수 있는 형태로 잘 정리된/가공된 데이터를 의미
			- = 정해진 규칙에 따라 데이터가 저장된 형태
			- = **테이블 형태**로 저장된 데이터 = 엑셀 형태
			- 테이블 형태? =>
				- 레코드(행) / 필드(열) / 필드명 (머릿글)
				- 정형 데이터만 데이터베이스 시스템 관리 가능
				- 
		- 2. 비정형 데이터  (Un Structured Date)
			- 동영상, 이미지, 음성파일, 쇼셜미디어텍스트, 이메일 등 데이터 형식이 잘 정리되지 않은 데이터 의미
			- = 정해진 구조가 없는 데이터
			- = 정해진 규칙/구조가 없어 값의 의미를 파악하기 힘든 데이터
				- > 특징 추출해 반정형 or 정형 데이터로 변환하는 과정 필요
			- 
		- 3. 반정형 데이터 - Semi structured Data
			- 데이터베이스 정형적인 구조를 따르지 않지만, 태그나 마커가 포함되어 있어 존재하는 규칙에 따라 분석에 활용할 수 있는 데이터 
			- ex) html, xml, json
			- 
	- **분석 규모(양)에 따라 분류**
		- 1. 빅데이터 - Big Date
			- 정형 - 비정형 - 반정형 데이터세트의 집합 의미
			- 방대한 데이터 규모 자체를 의미
		- 2. 스몰데이터 - Smaill Data
			- 양이 적다는 의미 보다는 (개인의 취향, 생활방식 등 사소한 행동에서 나오는) 개인화된 데이터들을 의미
				- 빅데이터 : 특정 집단의 공통 특징을 구분하기 위해 사용
				- 스몰 : 개인의 차별화된 특성을 파악하기 위해 사용
				- 
	- **기타 관계에 따라 분류**
		- 1. 메타 데이터 - Meta Data
			- 파일에 저장된 정보를 찾고 관리하기 위한 부가 정보 의미
				- ex) 데이터 저장 위치, 저장 날짜 등등
			- 데이터에 대한 데이터
		- 2. 원시 데이터 - Raw Date - 참조 데이터
			- 데이터가 생성된 최초 상태 = 가공되지 않은 원본 상태
			- 수집된 데이터가 분석에 바로 사용 가능하든, 추가적인 처리 과정을 요구하든, 그 초기 상태의 데이터는 모두 원시 데이터 표현 가능

##### ㅡ [[DB-데이터베이스시스템-이해\|DB-데이터베이스시스템-이해]]
- 5. **데이터베이스 시스템** - 큰 개념
    - **데이터의 기본 개념**
        - 저장 및 관리 방식: 파일 시스템 vs. 데이터베이스
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==실습==
	- 엑셀 > power pivot 기능 활용 (ms오피스 노트 확인)
	- 배경설명
		- 고객관리팀 / 제품팀 / 판매팀 > 서로 다른 부서지만 공통적으로 관리해야 하는 데이터 값들이 존재 이러한 상황에선 파일시스템보다 DB시스템 방식이 유용
		- 파일단위로 저장된 값 > 엑셀로 불러옴 > 현재 각각 다른 테이블에 데이터 저장된 상태임
		- DB시스템은 다른 테이블에 저장되어 있더라도 연관성 있는 값끼리 연결할 필요성이 있을 때/공통된 값들이 존재할 때 표현 가능 = DB 특징 
		- <span style="background:#d3f8b6">엑셀-DB실습-이미지1</span>
			- 고객정보 데이터 파일 존재
				- 고객번호/이름/성별/전화번호/이메일/등급 정보 존재
			- 제품정보 데이터 파일 존재
				- 제품번호/제품분류/제품명/매입가격/판매가격/제품특징 정보 존재
			- 판매정보 데이터 파일 존재
				- 고객정보 + 제품정보 + 추가적인 정보 존재
	- <span style="background:#d3f8b6">엑셀-DB실습-이미지2</span>
		- 지금까지 한 작업 :  가지고 있는 파일시스템 단위 데이터를 데이터베이스 구조를 잡은것
	- 테이블 형태 데이터
	- <span style="background:#d3f8b6">테이블 형태로 저장된 데이터 예시-이미지</span>
	- <span style="background:#d3f8b6">잘못된 테이블 형식 예시-이미지</span>
		- 1. 머리글 2줄임 = 규칙 위배
		- 2. 머리글 2줄 , "판매날짜" 새로운 필드로 빼야됨
		- 3. 데이터를 중복해서 작성해야 함


