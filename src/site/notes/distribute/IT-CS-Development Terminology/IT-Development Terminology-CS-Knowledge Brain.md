---
{"dg-publish":true,"permalink":"/distribute/it-cs-development-terminology/it-development-terminology-cs-knowledge-brain/","tags":["개발용어_CS지식","목차"],"noteIcon":""}
---

### 날짜 2023-11-06 15:18



----
# <디지털 환경-세계 인프라 아키텍처>


##### - [[디지털인프라-개발직군-직무-역량 이해\|디지털인프라-개발직군-직무-역량 이해]]
- 디지털 인프라
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- <span style="background:#d3f8b6">디지털 인프라 아키텍처 기반 다양한 개발직군 이해-이미지</span>
	- 웹 기술/개발 관련 직군
		- 제품/서비스(만) 기획 직무
		- UI/UX 제품-서비스 기획 직무
			- 웹 디자인 직무
			- 웹 퍼블리셔 직무
				- 실제 개발을 담당하는 직무들 =>
				- 프론트엔드 개발 - 화면에 보이는 로직구현
				- 백엔드 개발 - 안 보이는 서버쪽 로직구현
				- DBA - 데이터베이스 개발
					- 
	- 기획자/디지털 마케터 : 
		- 하나의 서비스를 성공적으로 진행되게 하기 위한 기능명세서/기획안 작성
		- 예시 =>
			- 네이버에서 특정한 서비스/기능을 사용자들에게 제공 
			- 화면을 사용자친화적 >  어떻게 디자인? 어떤 색? 어떻게 배치? 어떤 내용? 
		- 
	- 클라이언트 측:
	    - 운영체제 개발자: 운영체제의 설계와 개발을 담당
	    - 소프트웨어 개발자: 클라이언트 응용 프로그램을 개발
	    - 프론트엔드 개발자: 웹이나 모바일 애플리케이션의 사용자 인터페이스 개발
	    - 
	- 서버 측:
	    - 백엔드 개발자: 서버 사이드 로직, 데이터베이스 관리, 서버와 클라이언트 간의 통신을 담당
		- DBA(Database Administrator) : 데이터베이스의 설계, 구현, 유지보수, 보안 강화 등을 담당하며, 이를 통해 데이터의 안정성과 접근성을 확보
		- 
	- 네트워크 영역:
	    - 시스템 엔지니어/데브옵스: 클라이언트와 서버 간의 원활한 통신과 상호작용을 보장하며, 인프라의 배포, 관리, 운영을 담당
- <span style="background:#d3f8b6">디지털 인프라 기반 다양한 개발역량-이미지</span>
	- app 개발을 위한 UX/UI 이해 = 분석-설계-기획
	- app 개발을 위한 언어 이해
		- app 개발을 위한 프레임워크/라이브러리 이해
	- 개발한 app 유저와 커뮤니케이션 영역 프론트 이해
	- 개발한 app을 서비스화 하기 위한 서버 이해
		- 서버영역에서 비즈니스 흐름 처리/로직 백엔드 이해
	- 데이터를 수집-저장-관리를 위한 데이터베이스 이해
	- 형상관리-빌드-배포자동화-테스트자동화 이해
	- app 개발을 위한 물리/가상 환경/장비 이해



---
----


# <컴퓨터 시스템>



##### - [[시스템-프로그램-용어이해\|시스템-프로그램-용어이해]]
- 컴퓨터 시스템
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- "시스템" 용어
	- 다양한 문맥에서 사용
	- 개별적인 구성 요소들이 서로 상호작용하여 특정한 목표나 기능을 달성하기 위해 함께 작동하는 집합체 의미
	- 따라서 각각의 프로그램, 모듈, 컴포넌트 상호작용을 한다면 시스템! 용어 사용 가능
		- 프로그램 = 코드(파일)덩어리 
			- 모듈 <=> 컴포넌트 용어
				- : '각 컴포넌트는 인터페이스를 통해 상호작용'
				- 특정 기능 담당 독립적인 코드단위/수행 단위
				- 프로그램 일부 
	- ex)
		- DB 시스템(Database System)
			- 데이터베이스 관리 시스템(DBMS)과 데이터베이스로 구성
			- 데이터의 저장, 검색, 관리 등을 효율적으로 수행하기 위해 상호작용
		- 컴퓨터 (시스템) (Computer System)
			- 하드웨어(프로세서, 메모리, 입출력 장치 등)와 소프트웨어(운영 체제, 응용 프로그램 등)가 결합 > 각 하드웨어 구성요소와 소프트웨어가 상호작용하여 컴퓨터가 원활하게 동작
		- 파일 시스템(File System)
			- 파일과 데이터를 효율적으로 저장, 검색, 관리하기 위해 운영 체제에 의해 사용되는 시스템
			- 디스크 내의 데이터를 조직화하고, 파일에 대한 접근 및 관리를 가능하게 하는 여러 구성요소로 이루어져 있습


# ㅡ 1. **컴퓨터 구조** - 큰 개념

##### - [[비트(bit)용어\|비트(bit)용어]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 비트 용어 이해
	- 비트 정의
		- 비트(bit)는 'binary digit'의 줄임말
		- 컴퓨터는 모든 데이터/정보를 이진 형태로 처리하기 때문에, 비트는 컴퓨터가 데이터를 처리하는 기본 단위로 사용
		- 1비트는 **데이터의 크기 단위**이며, 컴퓨터나 기타 디지털 시스템에서 정보를 저장하고 처리하는 가장 작은 단위 > 따라서 "1비트를 처리한다"는 것은 실제로 '데이터 포인트 한 개를 처리한다'는 것과 동일한 의미를 가지며, 이 데이터 포인트는 0 또는 1의 값 중 하나를 가질 수 있음
	- 비트와 데이터 표현 
		- <span style="background:#d3f8b6">비트-스위치-이해-이미지</span>
			- 이미지 설명 =>
			- 4비트 상황 = 스위치가 4개인 상황
			- 스위치/비트 1개 당 표현할 수 있는 경우의 수 2가지.
			- 따라서 현재 4비트인 상황에서 표현할 수 있는 경우의 수/종류는 16개!
			- 
		- 1비트는 두 가지 상태(0 또는 1)를 나타낼 수 있습
		- 이는 하나의 비트가 표현 가능한 데이터의 '개수' 또는 '가능성'을 의미. 
		- 즉, 1비트에 의해 표현될 수 있는 값의 경우의 수/종류는 두 가지.
		- 
	- 메모리와 비트
		- 메모리에서 1비트의 용량은 그 메모리가 저장할 수 있는 정보의 최소 단위를 나타냅
			- 주의 : 1비트는 두 가지 가능한 정보 값을 저장할 수 있는 최소 단위로, 크기가 '2'를 의미하지는 않습
		- 1비트는 0 또는 1, 즉 두 가지의 다른 상태를 나타낼 수 있으므로, 메모리에서 1비트는 두 가지 가능한 상태를 저장할 수 있는 공간을 의미
		- = 1비트는 두 가지 상태를 표현할 수 있는 **용량**을 가진다고 이해
		- 
	- 요약 : 비트는 데이터 최소/기본 크기 단위 (데이터 포인트 1개..) 이지만, 이는 동시에 그 비트로 표현할 수 있는 데이터 값의 '경우의 수' 또한 나타냅. + 메모리 입장에선 1비트는 2가지 값 상태를 표현할 수 있는 용량을 가지고 있음을 의미
	- 
	- <span style="background:#d3f8b6">비트-진법-손풀이-이미지</span>
		- 이미지 설명 =>
		- 10진수로 표현된 512 숫자 존재
		- 특정한 진법으로 표현되어 있는 숫자는 `각 자리 숫자 x 해당 진법의 자리값` 끼리 더하면 해당 값이 나온다.
		- 
		- 이미지 설명 =>
		- 2진수로 표현된 1001 숫자 존재
		- `각 자리 숫자 x 해당 진법의 자리값` 끼리 더하면 1001 이진수 값에 대한 십진수 값을 파악 가능



##### - [[CPU-메모리저장된값-이용과정\|CPU-메모리저장된값-이용과정]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
    - 메모리 계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>



##### - [[저장장치-캐시계층-구조\|저장장치-캐시계층-구조]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- **캐시 메모리** 계층 존재
	- ==캐시 메모리? =>== | [[캐시메모리-성능-작동원리\|캐시메모리-성능-작동원리]]
	- 
	- 현재 대부분의 마이크로프로세서는 여러 레벨의 캐시(L1, L2, 때로는 L3까지)를 내장하고 있음
	- L1, L2, L3 캐시는 각기 독립적인 레벨의 캐시 메모리로 존재
	- 주의
		- 캐시 메모리는 L1, L2, L3과 같은 여러 레벨로 나눌 수 있지만, 반드시 모든 시스템이 이 세 가지 레벨을 모두 갖추고 있는 것은 아닙
		- 오래된 컴퓨터 시스템에서는 L1과 L2 캐시만을 사용할 수도 있고, 고성능 시스템에서는 L1, L2, L3 캐시를 모두 활용하여 데이터 처리 효율을 높일 수 있습
		- 
	- L1 캐시
		- 거의 모든 현대 프로세서에 존재하며, CPU 코어에 매우 가까워서 가장 빠른 액세스 속도를 제공
	- L2 캐시
		- L1보다는 느리고 크지만, 여전히 빠른 데이터 접근을 제공하여 CPU의 성능을 향상
	- L3 캐시
		- 주로 멀티코어 프로세서에서 볼 수 있으며, 여러 코어 사이에 데이터를 공유하는 데 도움을 줍
		- 
	- 
	- 다양한 형태-구조 캐시 메모리 존재 = 캐시 메모리 위치
		- CPU 내부에도 존재할 수 있고, 과거에는 CPU와 RAM 사이에 위치하는 외부 캐시로 구현
		- 현대의 컴퓨터 아키텍처에서는 주로 내부 캐시를 말합
		- 과거 컴퓨터 아키텍처에서는 CPU 외부에 별도의 캐시 메모리를 두는 경우가 더 흔했음 > 하지만 기술의 발전으로, 특히 반도체 제조 공정이 미세화되면서, 캐시 메모리를 CPU 칩 내부에 통합할 수 있게 되었습 > 내부 통합 캐시는 더 짧은 지연 시간과 빠른 접근 속도를 제공하며, CPU의 성능을 대폭 향상
		- 
		- <span style="background:#d3f8b6">계층적 캐시 메모리-이미지</span>
			- 
		- <span style="background:#d3f8b6">멀티코어 프로세서 캐시 메모리-이미지</span>
			- L3코어가 공유되는 형태
			- L1, L2 각각 코어에 존재
		- <span style="background:#d3f8b6">분리형 캐시 메모리-이미지</span>
			- 멀티코어 구조와 비슷하지만, L1 캐시 메모리가 분리된 구조



##### - [[플래시메모리-기반보조기억장치\|플래시메모리-기반보조기억장치]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 1. ==플래시 메모리(Flash Memory) 기반 보조기억장치==
	- ex) SSD(Solid State Drive), USB(Universal Serial Bus)
		- 
	- 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치 > 따라서 비플래시 메모리 즉, hdd와 모양이 많이 다름
		- 
	- 플래시 메모리(Flash Memory)
		- 플래시 메모리는 실제로 존재하는 물리적인 하드웨어 요소(물리적인 저장 매체) 이면서 동시에 그 하드웨어가 데이터를 저장하고 관리하는 '기술' 의미도 포함
		- 플래시 메모리의 핵심 기능은 데이터를 저장하는 것이며, 이러한 저장 기능은 다양한 형태와 용도로 전자 기기에서 구현
			- = 보조기억장치에만 한정되지 않는다는 점을 이해 = 범용성이 높다
			- ex) 휴대폰, 태블릿, USB 드라이브 등에서도 널리 사용
			- 
		- ==플래시 메모리를 이루고 있는 저장 단위/용어== => [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
		- 
	- 특징
		- 플래시 메모리에서는 비플래시-하드디스크와 달리 데이터를 직접 수정하거나 덮어쓰는 것이 불가능
			- = 수정된 새로운 데이터는 항상 새로운 공간에 저장
		- ~ 특징으로 인한 플래시 메모리에서 데이터를 업데이트할 때의 기본적인 동작 프로세스 - 상황예시
			- <span style="background:#d3f8b6">플래시메모리-가비지 컬렉션 과정-이미지</span>
			- 이미지 설명 =>
				- 한 칸 = 한 페이지 가정
				- 새로운 데이터 c 를 저장 = 블록 x 3번 페이지에 저장
				- 1번 페이지에 존재하던 A데이터를 수정을 진행. A > A' 
				- 따라서 1번 페이지에 존재하던 A데이터는 필요없는 값이 되어버림 = Invalid 상태
				- 가비지 컬렉션 진행
					- 1. 기존 x블록에 존재하는 유요한 페이지들만을 새로운 블록으로 복사
					- 2. 기존 x 블록 삭제
				- 
		- 이 과정을 통해 유효하지 않은 페이지는 지워지고, 해당 공간은 새로운 데이터 저장을 위해 다시 사용 가능해집 > 이러한 프로세스-과정은 메모리의 수명을 연장하고, 데이터의 무결성과 안정성을 보장
		- 시스템은 정기적으로 또는 필요할 때 'Invalid' 상태의 페이지를 정리하는 **가비지 컬렉션**을 수행
		- 가비지 컬렉션? =>
			- 유요한 페이지들만 새로운 블록으로 복사한 후 기본 블록을 삭제해 공간을 정리하는 기능/과정
			- 상황예시
				- 워드 문서를 편집하고 저장할 때를 생각
				- 처음 문서를 저장하면 해당 데이터는 플래시 메모리의 특정 페이지에 기록
				- 이후 같은 문서를 수정하고 다시 저장하면, 수정된 새로운 데이터는 새로운 페이지에 저장되고, 원래 페이지에 있던 데이터는 'Invalid' 상태가 됩
				- 즉, 원본 데이터는 여전히 메모리에 남아 있지만, 시스템은 그 데이터를 더 이상 유효한 정보로 인식하지 않습 이렇게 유효하지 않게 된 데이터는 나중에 가비지 컬렉션 과정에서 지워지게 됩
					- 
	- 플래시 메모리 종류
		- 1. NAND (넨드) 플래시 메모리
			- 대용량 저장 장치로 주로 사용 > 따라서 특별한 언급이 없다면 플래시 메모리는 넨드! 를 의미
		- 2. NOR 플래시 메모리


##### - [[플래시메모리-저장단위-크기단위\|플래시메모리-저장단위-크기단위]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==플래시 메모리를 이루고 있는 저장 단위/용어== 
	- <span style="background:#d3f8b6">플래시메모리-저장단위-용어-이미지</span>
	- 셀 (cell)
		- 플래시 메모리에서 데이터를 저장하는 가장 작은 단위
		- 예시를 통한 이해
			- 셀! : 데이터를 저장할 수 있는 공간/집
			- 비트! : 0과 1을 표현할 수 있는 사람 한 명
		- 셀들이 모여 MB, GB, TB 저장 장치가 됨
		- 하나의 셀에 몇 비트를 저장할 수 있는지에 따라서 **종류**가 달라짐 | [[비트(bit)용어\|비트(bit)용어]]
			- ==종류==? | [[플래시메모리-셀-종류-비트\|플래시메모리-셀-종류-비트]]
			- 
	- 데이터 저장단위/크기 단위
		- 1. 셀들이 모여 페이지(page)
			- 다양한 페이지 상태 표현 존재
				- 1. Free 상태
					- 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태
				- 2. Valid 상태
					- 이미 유요한 데이터를 저장하고 있는 상태
				- 3. Invalid 상태
					- 유효하지 않은 데이터(쓰레기 값)을 저장하고 있는 상태
		- 2. 페이지들이 모여 블록(block)
		- 3. 블록들이 모여 플레인(plane)
		- 4. 플레인들이 모여 다이(di)
		- 
	- 플래시 메모리 내부적인 특징
		- 데이터 읽기/쓰기 시 사용하는 기본 단위와 데이터 삭제 시 사용되는 기본 단위가 다르다
		- 읽기/쓰기는 페이지 단위로 이루어짐
		- 삭제는 블록 단위로 이루어짐 = 삭제 시 읽기/쓰기 보다 더 큰 단위로 삭제됨





##### - [[플래시메모리-셀-종류-비트\|플래시메모리-셀-종류-비트]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==종류==
	- 1. 한 셀에 1비트 저장 플래시 메모리 = SLC 타입 = 싱글 레벨 셀
		- 특징/장점
			- 하나의 셀에 1비트-정보 저장 가능 
				- = 하나의 셀로 두 개의 정보 표현 가능
				- EX) 1과 0 표현 가능
			- 1비트 저장으로 인한 빠른 입출력
				- 이해예시 :  하나의 공간/집에 1명만 살고 있으면 빠르게 밖으로 나갈 수 있음.
			- 긴 수명
			- 용량 대비 고가격
				- 이해예시 : 한 집에 혼자서 살고 있음. 따라서 혼자서 월세 내야함
				- 
	- 2. 한 셀에 2비트 저장 플래시 메모리 = MLC 타입 = 멀티 레벨 셀
		- 특징/장점
			- <span style="background:#d3f8b6">MLC타입-비트-이미지</span>
			- 하나의 셀에 2비트-정보 
				- = 하나의 셀로 4가지 정보 표현 가능
			- SLC보다 느린 입출력
				- 이해예시 : 하나의 공간/집에 2명이 살고 있으니 1명이 존재했을 때보다 느리게 나갈 수 있음
			- SLC보다 짧은 수명
				- 이해예시 : 입구에서 충돌이 발생하니까....
			- SLC보다 저렴
			- SLC보다 시중에서 많이 사용
				- SLC보다 저렴 + 더 많이 저장-표현이 가능하기 떄문
					- 
	- 3. 한 셀에 3비트 저장 플래시 메모리 = TLC 타입 = 트리플 레벨 셀
		- 특징/장점
			- 하나의 셀에 4비트-정보
				- = 하나의 셀로 8가지 정보 표현 가능
			- MLC보다 느린 입출력
			- MLC보다 짧은 수명
			- MLC보다 시중에서 많이 사용
				- 
	- 4. 한 셀에 4비트 저장 플래시 메모리 = QLC 타입 = 쿼드 레벨 셀
		- 
	- 종류에 따라서 메모리 **성능**, **가격**, **수명**이 달라짐.
		- <span style="background:#d3f8b6">다양한종류-셀-특징표-이미지</span>
	- 성능? =>
		- 셀 당 비트 수가 증가할수록 즉, SLC에서 QLC로 갈수록, 셀 내에서 데이터를 읽고 쓰는 **과정이 복잡**해집
		- 과정이 복잡? =>
			- 메모리의 읽기 및 쓰기 속도에 직접적인 영향을 미치며, 비트 수가 많을수록 처리 속도가 느려질 수 있습
	- 수명? =>
		- 셀의 수명은 주로 쓰기 **사이클**(데이터를 쓰고 지우는 횟수)에 의해 결정
			- = 셀이 견딜 수 있는 쓰기/삭제 작업의 횟수에 의해 결정되며, 이 횟수가 소진되면 메모리 셀이 더 이상 정상적으로 기능하지 못하게 됩
			- 사이클 횟수가 많다 = 셀이 한번에 처리/저장하는 양이 적다 = 셀이 받는 부하가 적다 = 수명이 길다 = 마모가 적다
			- 
			- "높은 데이터 쓰기 사이클을 지원한다"는 문장 존재
				- = 데이터를 저장하고 삭제하는 과정을 더 많이 견딜 수 있음을 의미
				- = 더 높은 내구성을 가진다는 것을 의미
				- = 메모리 수명이 더 길다는 것을 의미
			- 
		- SLC 메모리가 한 셀에 데이터를 한 비트만 저장 > 그 셀이 받는 부하가 적어 다른 유형의 메모리보다 더 많은 쓰기/삭제 작업을 견딜 수 있음
		- QLC 메모리는 한 셀에 더 많은 데이터를 저장 = 한 셀에 4비트를 저장
			- = 비트 수가 증가 > 표현할 수 있는, 한번에 처리할 수 있는 경우의 수 증가 > 메모리의 셀은 더 높은 수준의 전기적 스트레스와 복잡한 데이터 관리를 경험
			- = 셀 당 처리하는 정보량이 많기 때문에 더 민감하게 반응하여 더 빠른 성능 저하를 가져오고, 따라서 쓰기 사이클이 감소
		- 즉, QLC는 더 많은 데이터를 저장할 수 있지만, 이는 셀이 더 빨리 마모되는 원인이 되어 전체적인 메모리 수명을 단축
		- 
	- 가격? =>
		- 셀 당 비트 수가 증가하면 해당 메모리 셀이 더 많은 데이터를 저장할 수 있으므로, 이론적으로는 저장 용량이 늘어남 > 그렇다면 더 많은 데이터를 저장하면 더 비싸겠군! > X
		- 저장할 수 있는 데이터의 양이 메모리의 단가를 결정하는 유일한 요소는 X
		- 가격 결정에는 여러 요소가 작용
		- EX) 성능측면과 내구성 측면
			- QLC 메모리는 한 셀에 4비트를 저장할 수 있어 용량 대비 비용이 낮지만, 이는 성능과 내구성의 저하를 수반 > 수명이 짧음
			- SLC는 더 빠른 데이터 액세스와 높은 쓰기/지우기 사이클을 제공하기 때문에, 고성능을 요구하는 응용 프로그램에서 선호


##### ㅡ [[캐시메모리-성능-작동원리\|캐시메모리-성능-작동원리]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
			- 캐시
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==캐시 메모리? =>==
	- CPU 내부에 존재하는 레지스터보다 용량이 크고, 메모리보다 용량이 작지만 속도는 빠른 SRAM 기반 저장 장치
		- = 따라서 RAM에 존재하는 모든 내용을 미리 저장할 순 없다.
	- 캐시 메모리는 CPU가 실행 후 생성된 결과물 중 자주 사용되는 데이터를 **임시 저장**
	- 임시 저장? =>
		- CPU가 미래에 다시 접근할 가능성이 높은 데이터를 **예측**해 **미리 저장** 후 > 빠르게 제공하여 처리 속도를 향상시키고, 메인 메모리와의 데이터 전송 횟수를 줄이는 역할
		- 예측 > 미리저장? =>
			- 예측이 성공하면 캐시히트(Cache Hit 용어) 발생! 표현 사용
				- <span style="background:#d3f8b6">캐시히트-이미지</span>
					- 이미지 설명 =>
					- 예측이 성공한 상황 > 따라서 메모리까지 접근하지 x 
					- 상황예시
						- 자주 사용하는 값을 클라이언트가 서버에 데이터 요청 > 서버는 매번 응답 = 비효율
						- 웹 서버 자주 사용하는 데이터 클라이언트 측-캐시 저장 후 재요청 시 직접 반환 = 효율적
							- = 빈번하게 접근하는 데이터는 L1 캐시에 저장되어 빠르게 액세스할 수 있으며, 덜 접근하는 데이터는 L2 또는 L3 캐시에 저장됩
						- 자주 사용하는 값? =>
							- 정적 데이터/정적 자원
								- 웹 페이지 이미지
								- 스타일시트, 스크립트 
								- 
			- 예측이 실패하면 캐시 미스(Cache Miss 용어) 발생! 표현 사용
				- <span style="background:#d3f8b6">캐시미스-이미지</span>
			- 이러한 상황에서 사용하는 공식 존재 = 캐시 적중률!
				- 캐시 히트 횟수 / (히트 횟수 + 캐시 미스 횟수)
				- Long Tail 법칙 그래프 존재
				- 
			- 성능을 높인다! = CPU가 사용할 법한 데이터를 잘 예측한다
			- 참조 지역성의 원리 : CPU가 메모리에 접근할 때 주된 **경향성/패턴/규칙**을 바탕으로 만들어진 원리
			- 경향성 존재? =>
				- 1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
				- 2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다 = 공간 지역성
				- 
	- <span style="background:#d3f8b6">캐시메모리 존재이유-이미지</span>
	- CPU가 메모리에 접근하는 시간은 CPU 연산 속도보다 느리다.
	- CPU와 메인 메모리 사이의 데이터 전송 속도 차이/메모리 접근 시간/데이터 처리 속도를 완화하기 위한 방법 중 하나 = 중간에 캐시 메모리를 배치
		- = 이는 **프로세서의 성능**을 결정하는 중요한 요소 중 하나
		- ==프로세서(Processor) 성능? =>== | [[프로세서(Processor)-CPU-성능\|프로세서(Processor)-CPU-성능]]


##### ㅡ [[프로세서(Processor)-CPU-성능\|프로세서(Processor)-CPU-성능]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==프로세서(Processor) 성능? =>==
	- 프로세서는 그 프로그램을 실행하는 하드웨어 장치를 의미 
	- = CPU(Central Processing Unit)를 가리키는 용어로 사용
	- 
	- 각 용어는 프로세서 성능 향상의 다양한 이점을 나타내며, 비록 서로 연결되어 있기는 하지만, 각각이 강조하는 부분은 다릅
	- 1. **응답시간 단축:** 
		- 프로세서의 향상된 성능은 컴퓨터가 사용자가 입력한 명령어을 더 빠르게 처리하게 해, 사용자와 시스템 간의 상호작용이 빨라지게 합
		- 
	- 2. **로딩속도 향상:** 
		- 향상된 프로세서는 사용자가 입력한 명령어를 pc가 해석한 이후 작업인 = 메모리와의 데이터 교환을 더욱 빠르게 할 수 있어, 필요한 데이터나 애플리케이션의 로딩 시간이 단축
			- = 메모리와 데이터 교환 속도 = 데이터 처리 속도= 액세스 속도
			- = 사용자가 프로그램이나 파일을 더 빠르게 열 수 있게 합
		- 
	- 3. **서버 부하 감소:** 
		- 서버측 pc 성능 향상 이점.
		- 서버 내 프로그램을 동시에 처리할 수 있는 작업량이 증가
		- = 서버가 더 많은 사용자 요청을 처리할 수 있게 하고, 서비스의 가용성과 신뢰성을 높입


##### ㅡ [[컴퓨터구조-이미지\|컴퓨터구조-이미지]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 이미지
	- 전체구조도
	- 시스템버스
	- 시스템버스-cpu-작동예시
	- 메인보드-마더보드(mother board)-시스템보드(system board)
	- 중앙처리장치CPU-이미지
	- 주기억장치-RAM-메인메모리
	- <span style="background:#d3f8b6">보조기억장치-HDD-SSD</span>
	- 아두이노-라즈베리파이-이미지
	- 
- SSD (Solid State Drive)
	- <span style="background:#d3f8b6">SSD내부-이미지</span>
	- 전통적인 하드 드라이브보다 빠른 데이터 액세스 속도를 제공하는 저장 장치로, 여러 핵심 구성 요소를 포함
	- SSD 컨트롤러
		- SSD의 작동을 제어하며, 데이터 읽기/쓰기, 에러 수정, 웨어 레벨링 등의 작업을 관리
	- DRAM (Dynamic Random-Access Memory)
		- 데이터를 일시적으로 저장하여 SSD 컨트롤러가 빠르게 접근할 수 있도록 하는 버퍼 역할
	- 낸드 플래시 메모리 (NAND Flash Memory)
		- SSD에서 데이터를 영구적으로 저장하는 주요 구성 요소

##### ㅡ [[CPU-레지스터-작동과정예시\|CPU-레지스터-작동과정예시]]
- 1. **컴퓨터 구조** - 큰 개념
    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- 1~4번 레지스터 작동과정 예시
	- <span style="background:#d3f8b6">1~4번 레지스터 작동과정-이미지</span>
	- 
	- 실행할 프로그램(명령어와 데이터들)이 메모리에서 1000번 ~ 1500번에 저장되어 있음
	- `프로그램 카운터`에 실행될 메모리 처음 위치가 저장됨
		- = 즉 1000번지에 존재하는 값이 필요함
	- (접근해야 하니까...)프로그램 카운터에 있던 주소 값이 `메모리 주소 레지스터`에 해당값이 복사된다 
	- 메모리 주소 레지스터에 저장된 주소위치는 `주소버스`를 통해 메모리로 전달 + 동시에 제어장치에서 생성된 제어신호는 `제어버스`통해 메모리로 전달
	- 메모리가 주소값+명령-제어신호를 받은 후 명령어대로 1000번지에 저장된 값을 CPU쪽으로 `데이터버스`를 통해 보내준다. = `메모리 버퍼 레지스터`에 보내준다. 
	- 위 작업/메모리에서 보내진 값이 `메모리 버퍼 레지스터`에 저장이 되면 동시에 다음작업 수행을 위해 `프로그램 카운터`에 있던 값을 증가시킨다. (순차적인 실행 흐름위해)
	- 메모리 에서 받은 값이 `명령어 레지스터`에 할당된다. 즉 1000번지에 존재하던 값이 해당 레지스터에 할당된다.
	- 순차적인 실행 흐름? =>
		- 순차적인 실행 흐름이 끊기는 경우 존재
			- 1. 인터럽트(Interrupt) 발생 시
				- 인터럽트 용어
					- 1. **인터럽트 과정**: 
						- 이는 CPU가 현재 실행 중인 프로세스나 작업을 일시적으로 중단하고, 더 높은 우선순위를 가진 작업을 처리하고 이 작업이 완료되면, CPU는 원래 수행 중이던 작업으로 돌아가 계속 수행 과정/매커니즘을 의미
						- 이 과정은 시스템의 효율성과 반응성을 향상
							- = 특정한 신호나 사건에 반응하여 시스템의 응답성과 효율성을 높이는 추상화된 용어
							- =  하드웨어 또는 소프트웨어에 의해 발생하는 이벤트에 대응하는 CPU의 작동 방식을 지칭하는 용어
							- =  CPU가 다양한 태스크와 요청 사이에서 멀티태스킹을 수행하는 과정을 묘사하는 용어
							- 
					- 2. **인터럽트 신호**: 
						- 인터럽트는 또한 CPU에게 현재 작업을 중단하라고 알리는 전기적인 신호로도  이해 가능
						- 이 신호는 하드웨어 장치나 소프트웨어 프로그램에서 발생
				- 
			- 2. (일반적인 상황) 프로그램 내 실행 흐름 변경:
				- 이는 프로그래머가 프로그램의 논리에 따라 의도적으로 실행 순서를 변경하는 경우
				- EX) 프로그래밍 언어(고급언어)로 조건문 작성을 통해 실행 순서 변경하는 상황
				- 위 예시 내부과정 이해 =>
					- <span style="background:#d3f8b6">파이썬 예시코드</span>
						- 파이썬 코드는 실행될 때, 파이썬 인터프리터에 의해 내부적으로 CPU가 이해할 수 있는 명령어로 변환되고 있음
						- `a > b`가 참일 경우: (CONDITIONAL JUMP) 저수준 명령어 실행되어 > "a is greater"를 출력하는 코드의 위치로 점프
						- 즉, 내부적으로 이러한 점프가 있기에 프로그램의 실행 흐름을 적절하게 제어가 되고 있던 것
					- 파이썬과 같은 고급 언어로 조건문을 작성할 때 내부적으로는직접 저수준 명령 코드를 작성하지 않지만, 컴파일러나 인터프리터는 그러한 조건문을 저수준의 명령어로 변환
					- 저수준 명령어? =>
						- JUMP, CONDITIONAL JUMP 등이 포함
						- 일반적인 사용자나 개발자는 파이썬과 같은 고급 프로그래밍 언어를 사용할 때, 그 언어의 문법과 코드 표현식을 이해하고 사용할 줄 알면 충분 =  사용자가 저수준의 명령어를 직접 다루지 않아도 됨. 이 모든 저수준 작업은 파이썬 인터프리터에 의해 추상화되어 처리됩
					- 왜? 
						- 파이썬과 같은 고급 프로그래밍 언어로 작성된 코드는 컴퓨터에서 직접 실행될 수 있는 형태가 아님
					- 주의
						- 이 과정에서 실제 메모리 주소가 변경되는 것은 아니고, `프로그램 카운터`가 가리키는 명령어의 위치가 변경되는 것
							- = 조건문 실행 시 이 프로그램 카운터의 값이 변경되어 다음에 실행할 명령어의 위치를 결정


##### ㅡ [[다양한종류-레지스터\|다양한종류-레지스터]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==다양한종류-레지스터==
	- : 각각 다른 역할/기능 수행 = 각각 다른 종류 데이터 저장
	- ==1~4번 레지스터 작동과정 예시== | [[CPU-레지스터-작동과정예시\|CPU-레지스터-작동과정예시]]
	- 
	- 1. 프로그램 카운터(Program Counter, PC)
		- CPU가 다음에(미리..) 실행할 명령어/메모리에서 가져올 명령어 주소 저장
			- = 현재 실행 중인 명령어의 주소를 가리키며, 프로그램의 실행 흐름을 관리하는 데 사용
	- 2. 명령어 레지스터(Instruction Register, IR)
		- 현재 실행 중인 명령어를 저장
		- 메모리에 존재하는 명령어들의 주소를 저장 = 제어장치가 해석할 명령어 저장
	- 3. 메모리 주소 레지스터(Memory Address Register, MAR)
		- CPU가 데이터를 저장 OR 사용하던 특정 메모리 위치에 접근할 필요가 있을 때, 그 위치의 주소 정보를 MAR에 저장
		- 메모리 컨트롤러는 이 주소를 사용하여 해당 메모리 위치와 데이터를 교환
		- MAR은 메모리와 CPU 사이의 데이터 통신을 원활하게 하기 위해 필수적인 레지스터
	- 4. 메모리 버퍼 레지스터(Memory Buffer Register, MBR) 또는 메모리 데이터 레지스터(Memory Data Register, MDR
		- 메모리에서 읽은/가져온 데이터나 메모리에 쓸 데이터를 임시로 저장하는 역할
		- 예시상황
			- CPU입장에서 데이터를 보낸다 = 데이터를 쓴다 = 메모리입장에선 데이터를 받는다
				- 반대로, CPU가 데이터를 메모리에 쓸 때, 그 데이터는 먼저 MBR/MDR에 저장된 후, 해당 메모리 주소로 전송됩
			- CPU입장에서 데이터를 받는다 = 데이터를 읽는다 = 메모리입장에서 데이터를 보낸다.
				- CPU가 메모리에서 데이터를 읽을 때, 해당 데이터는 먼저 MBR/MDR에 저장되고, 이후 CPU로 전송됩
	- 5. 상태 레지스터(Status Register) 또는 플래그 레지스터(Flag Register): 
		- 기존기록 확인
	- 6. 범용 레지스터(General Purpose Registers)
		- 프로그램 내에서 다양한 용도로 사용 = 범용 레지스터는 그 활용도가 훨씬 넓고 유연 = 다른 레지스터 기능들 범용적 수행
		- 다양한 용도? =>
			- 데이터 저장, 중간 계산 결과의 보관, 주소 계산, 루프 카운팅 등 
			- 다양한 데이터와 메모리에서 가져올 명령어 주소 값을 임시로 저장 사용
	- 7. 스택 포인터(Stack Pointer, SP)
		- 기존노트 확인 : [[자료구조-용어\|자료구조-용어]]
	- 8. 베이스 레지스터
		- ==유효한 메모리 주소에 접근하기 위한 두 가지 방식== | [[유효한메모리주소-접근방식\|유효한메모리주소-접근방식]]


##### ㅡ [[RAM메모리-작동원리-성능\|RAM메모리-작동원리-성능]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 중앙 처리 장치 (CPU)
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==RAM의 기본적인 작동 원리==
	- 데이터 상호작용 순서 =>
	- 1. CPU(연산처리 진행) <> 2. RAM (실행할 대상/프로그램 존재) <> 3. 보조기억장치 (보관할 대상/프로그램 존재)
	- 상황예시
		- 사용자가 컴퓨터에서 'a'라는 프로그램을 실행
		- 운영 체제는 보조기억장치에서 'a' 프로그램을 찾는다
		- 프로그램 'a'는 보조기억장치에서 RAM으로 복사 = 프로그램의 코드와 필요한 데이터가 메모리로 옮겨집 > (프로그램을 종료하면 RAM의 해당 작업 공간은 비워진다)
		- CPU는 RAM에서 'a' 프로그램을 읽어서 명령어를 처리하기 시작
		- 즉,  보조기억장치에 있는 프로그램을 실행할 때, 그 프로그램은 **RAM으로 복사됨** > 이는 실행 중인 프로그램이 빠르게 데이터에 접근하고 처리할 수 있게 해 주며, 보조기억장치에서는 해당 프로그램이 사라지지 않고 그대로 유지
		- RAM으로 복사됨? =>
			- <span style="background:#d3f8b6">RAM용량-성능-이미지</span>
				- : 보조기억 장치는 3개의 프로그램을 가지고 있는 상태. 하지만 RAM은 용량이 작아 1개만 가지고 있을 수 있는 상태 > RAM 용량-사이즈가 커지면 한번에 많은 프로그램을 가지고 있을 수 있는 상태
				- 
			- 따라서 한 번에 여러 프로그램을 실행하거나 무거운 프로그램을 실행하려면 **RAM 용량**이 높아야 한다. (한 번에 여러 프로그램 = 많은 공간)
			- 실행하고 있는 프로그램(명령어+데이터)가 RAM 위에 저장/할당/복사 된 상태
			- RAM 용량? =>
				- RAM의 용량이 크다 = 성능이 좋다


##### ㅡ [[RAM-종류\|RAM-종류]]
- 1. **컴퓨터 구조** - 큰 개념
    - 컴퓨터의 기본 구성 요소
	    - 메모리-계층구조
- <span style="background:rgba(240, 200, 0, 0.2)">키워드/문장 기록 =></span>
- ==RAM 램의 종류==
	- 크게 4가지 존재.
	- 
	- 1. DRAM(Dynamic RAM) = 디램
		- 특징/장점/단점
			- 디램이 가진 장점으로 인해 일반적으로 메모리에 많이 사용됨
			- 메모리 셀에 데이터를 저장하기 위해 커패시터와 트랜지스터를 사용
			- 커패시터는 전하를 저장하는 방식. > 시간이 지남에 따라 **누설**되어 그 전하를 잃게 되는 특징 존재 (저장된 데이터가 동적으로 사라짐) > 이 때문에 DRAM은 저장된 정보를 유지하기 위해 주기적으로 새로 고쳐줘야 하는데, 이 과정을 "**리프레시(refresh)**"라고 함
			- 새로 고쳐준다? =>
				- DRAM의 각 셀에는 1비트의 데이터를 저장하기 위해 한 개의 커패시터와 한 개의 트랜지스터가 사용
				- 데이터는 커패시터에 전하의 형태로 저장되며, 전하의 유무로 1과 0을 표현
				- "정보를 고쳐준다"는 말은 커패시터에 전하를 다시 충전하여 데이터를 원래의 상태로 유지시키는 행위를 의미
			- 전하 누설? =>
				- DRAM 특성 상 사용하는 커패시터는 지속적으로 전하를 잃는다. 즉, 전원이 켜져 있는 동안에도 커패시터의 전하 누설로 인해 데이터가 점차 사라지기 때문에, 전원 공급 중이더라도 주기적으로 리프레시(재활성화)가 필요
				- = SRAM과 차이점 : 구조적 차이로 인해 전원 공급 중 데이터가 안정적으로 유지
				- 
	- 2. SRAM(Satic RAM) = 에스램
		- 특징
			- 전원이 공급되는 한 저장된 데이터가 사라지지 않는 RAM
			- DRAM보다 일반적으로 빠른 속도 > DRAM보다 가격이 높다
			- 주로 캐시 메모리에서 사용
			- 
	- Q. DRAM <> SRAM 어떤 것을 사용?
		- <span style="background:rgba(205, 244, 105, 0.55)">D-S-RAM표-이미지</span>
		- DRAM과 SRAM은 각각의 요구상황과 해당 RAM이 가진 특성을 고려하여 선택
		- 1. 비용 효율성 차이
			- DRAM은 SRAM보다 훨씬 비용 효율적
			- = "소비전력이 낮다"는 장기적으로 "비용적으로 효율적이다"같은 의미
			- 왜?
				- SRAM을 구성하는 데는 더 많은 트랜지스터가 필요하며, 이로 인해 SRAM은 같은 양의 데이터를 저장하기 위해 DRAM보다 더 많은 공간을 차지하고 더 비쌉 
				- = 대량의 메모리가 필요한 시스템에서는 DRAM이 훨씬 경제적
				- 
		- 2. 밀도의 차이
			- "밀도가 높다"는 표현은 물리적 공간 대비 데이터를 저장할 수 있는 용량이 크다는 것을 의미하며, "집적도가 높다"는 같은 양의 공간에서 더 많은 데이터를 저장할 수 있다는 것을 의미. 따라서 같은 맥락에서 사용
			- DRAM은 SRAM에 비해 더 높은 데이터 밀도를 제공. > 이는 DRAM이 더 적은 공간을 사용하여 더 많은 데이터를 저장할 수 있음을 의미
				- = 대용량 메모리를 필요로 하는 응용 프로그램에서 DRAM이 선호
				- 
		- 3. 용도의 차이 
			- SRAM은 그의 빠른 접근 속도 덕분에 캐시 메모리 같이 빠른 데이터 접근이 필수적인 상황에 주로 사용 
			- DRAM은 시스템의 주 메모리와 같이 큰 용량이 요구되지만 접근 속도가 SRAM만큼 민감하지 않은 경우에 사용
			- 
	- 3. SDRAM (Synchronous DRAM) - 에스디 
		- = SDR(Single Date Rate) SDRAM 표현 가능
		- 발전된 형태의 DRAM
		- = 클럭 신호화 동기화된 DRAM 표현 가능
		- 
	- 4. DDR SDRAM (Double Data Rate SDRAM)
		- <span style="background:rgba(205, 244, 105, 0.55)">SDR과 DDR 차이점-이미지</span>
		- 의미/특징
			- 최근 가장 대중적으로 사용되는 RAM 종류 중 하나
			- 발전된 형태의 SDRAM = **대역폭**을 넓혀 속도를 빠르게 만든 SDRAM
			- 대역폭이란? =>
				- 데이터를 이동 시 주고 받는 길의 너비  > 너비가 클수록 한번에 주고받을 수 있는 데이터 양이 많다진다 =  속도가 빨라진다
		- DDR2 SDRAM도 존재
			- <span style="background:rgba(205, 244, 105, 0.55)">SDR-DDR2-차이점-이미지</span>
			- DDR SDRAM 의미 생각 > 2의 제곱승으로 성능이 좋아짐
			- EX) 2 > 4 > 8 > 16 ....

